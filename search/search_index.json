{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Recurrent Inertial Graph-based Estimator (RING) \u00a4 \u2139\ufe0f Tip: Check out my new plug-and-play interface for inertial motion tracking (RING included) here . Installation \u00a4 Supports Python=3.10/3.11/3.12 (tested). Install with pip using pip install imt-ring Typically, this will install jax as cpu-only version. Afterwards, gpu-enabled version can be installed with pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html Documentation \u00a4 Available here . Quickstart Example \u00a4 import ring import numpy as np T : int = 30 # sequence length [s] Ts : float = 0.01 # sampling interval [s] B : int = 1 # batch size lam : list [ int ] = [ 0 , 1 , 2 ] # parent array N : int = len ( lam ) # number of bodies T_i : int = int ( T / Ts ) # number of timesteps X = np . zeros (( B , T_i , N , 9 )) # where X is structured as follows: # X[..., :3] = acc # X[..., 3:6] = gyr # X[..., 6:9] = jointaxis # let's assume we have an IMU on each outer segment of the # three-segment kinematic chain X [ ... , 0 , : 3 ] = acc_segment1 X [ ... , 2 , : 3 ] = acc_segment3 X [ ... , 0 , 3 : 6 ] = gyr_segment1 X [ ... , 2 , 3 : 6 ] = gyr_segment3 ringnet = ring . RING ( lam , Ts ) yhat , _ = ringnet . apply ( X ) # yhat: unit quaternions, shape = (B, T_i, N, 4) Known fixes \u00a4 Offscreen rendering with Mujoco \u00a4 mujoco.FatalError: an OpenGL platform library has not been loaded into this process, this most likely means that a valid OpenGL context has not been created before mjr_makeContext was called Solution: import os os . environ [ \"MUJOCO_GL\" ] = \"egl\" Windows-related: ImportError: DLL load failed while importing ... \u00a4 ImportError: DLL load failed while importing _multiarray_umath: Das angegebene Modul wurde nicht gefunden. Solution: 1. pip uninstall -y jax jaxlib 2. conda install -c conda-forge jax Publications \u00a4 The following publications utilize this software library, and refer to it as the Random Chain Motion Generator (RCMG) (more specifically the function ring.RCMG ): RNN-based Observability Analysis for Magnetometer-Free Sparse Inertial Motion Tracking Plug-and-Play Sparse Inertial Motion Tracking With Sim-to-Real Transfer RNN-based State and Parameter Estimation for Sparse Magnetometer-free Inertial Motion Tracking Other useful ressources \u00a4 Particularly useful is the following publication from Roy Featherstone - A Beginner\u2019s Guide to 6-D Vectors (Part 2) Contact \u00a4 Simon Bachhuber (simon.bachhuber@fau.de)","title":"Home"},{"location":"#recurrent-inertial-graph-based-estimator-ring","text":"\u2139\ufe0f Tip: Check out my new plug-and-play interface for inertial motion tracking (RING included) here .","title":"Recurrent Inertial Graph-based Estimator (RING)"},{"location":"#installation","text":"Supports Python=3.10/3.11/3.12 (tested). Install with pip using pip install imt-ring Typically, this will install jax as cpu-only version. Afterwards, gpu-enabled version can be installed with pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html","title":"Installation"},{"location":"#documentation","text":"Available here .","title":"Documentation"},{"location":"#quickstart-example","text":"import ring import numpy as np T : int = 30 # sequence length [s] Ts : float = 0.01 # sampling interval [s] B : int = 1 # batch size lam : list [ int ] = [ 0 , 1 , 2 ] # parent array N : int = len ( lam ) # number of bodies T_i : int = int ( T / Ts ) # number of timesteps X = np . zeros (( B , T_i , N , 9 )) # where X is structured as follows: # X[..., :3] = acc # X[..., 3:6] = gyr # X[..., 6:9] = jointaxis # let's assume we have an IMU on each outer segment of the # three-segment kinematic chain X [ ... , 0 , : 3 ] = acc_segment1 X [ ... , 2 , : 3 ] = acc_segment3 X [ ... , 0 , 3 : 6 ] = gyr_segment1 X [ ... , 2 , 3 : 6 ] = gyr_segment3 ringnet = ring . RING ( lam , Ts ) yhat , _ = ringnet . apply ( X ) # yhat: unit quaternions, shape = (B, T_i, N, 4)","title":"Quickstart Example"},{"location":"#known-fixes","text":"","title":"Known fixes"},{"location":"#offscreen-rendering-with-mujoco","text":"mujoco.FatalError: an OpenGL platform library has not been loaded into this process, this most likely means that a valid OpenGL context has not been created before mjr_makeContext was called Solution: import os os . environ [ \"MUJOCO_GL\" ] = \"egl\"","title":"Offscreen rendering with Mujoco"},{"location":"#windows-related-importerror-dll-load-failed-while-importing","text":"ImportError: DLL load failed while importing _multiarray_umath: Das angegebene Modul wurde nicht gefunden. Solution: 1. pip uninstall -y jax jaxlib 2. conda install -c conda-forge jax","title":"Windows-related: ImportError: DLL load failed while importing ..."},{"location":"#publications","text":"The following publications utilize this software library, and refer to it as the Random Chain Motion Generator (RCMG) (more specifically the function ring.RCMG ): RNN-based Observability Analysis for Magnetometer-Free Sparse Inertial Motion Tracking Plug-and-Play Sparse Inertial Motion Tracking With Sim-to-Real Transfer RNN-based State and Parameter Estimation for Sparse Magnetometer-free Inertial Motion Tracking","title":"Publications"},{"location":"#other-useful-ressources","text":"Particularly useful is the following publication from Roy Featherstone - A Beginner\u2019s Guide to 6-D Vectors (Part 2)","title":"Other useful ressources"},{"location":"#contact","text":"Simon Bachhuber (simon.bachhuber@fau.de)","title":"Contact"},{"location":"api/","text":"API \u00a4 RING \u00a4 RING ( lam , Ts , ** kwargs ) \u00a4 Creates the RING network. Parameters: lam ( list [ int ] | None ) \u2013 parent array, if None must be given via ringnet.apply(..., lam=lam) Ts \u2013 sampling interval of IMU data; time delta in seconds Returns: AbstractFilter \u2013 ring.ml.AbstractFilter: An instantiation of ring.ml.ringnet.RING with trained parameters. Examples: >>> import ring >>> import numpy as np >>> >>> T : int = 30 # sequence length [s] >>> Ts : float = 0.01 # sampling interval [s] >>> B : int = 1 # batch size >>> lam : list [ int ] = [ 0 , 1 , 2 ] # parent array >>> N : int = len ( lam ) # number of bodies >>> T_i : int = int ( T / Ts ) # number of timesteps >>> >>> X = np . zeros (( B , T_i , N , 9 )) >>> # where X is structured as follows: >>> # X[..., :3] = acc >>> # X[..., 3:6] = gyr >>> # X[..., 6:9] = jointaxis >>> >>> # let's assume we have an IMU on each outer segment of the >>> # three-segment kinematic chain >>> X [:, :, 0 , : 3 ] = acc_segment1 >>> X [:, :, 2 , : 3 ] = acc_segment3 >>> X [:, :, 0 , 3 : 6 ] = gyr_segment1 >>> X [:, :, 2 , 3 : 6 ] = gyr_segment3 >>> >>> ringnet = ring . RING ( lam , Ts ) >>> >>> yhat , _ = ringnet . apply ( X ) >>> # yhat : unit quaternions, shape = (B, T_i, N, 4) >>> # yhat[b, :, i] is the orientation from body `i` to parent body `lam[i]` >>> >>> # use `jax.jit` to compile the forward pass >>> jit_apply = jax . jit ( ringnet . apply ) >>> yhat , _ = jit_apply ( X ) >>> >>> # manually pass in and out the hidden state like so >>> initial_state = None >>> yhat , state = ringnet . apply ( X , state = initial_state ) >>> # state: final hidden state, shape = (B, N, 2*H) Source code in src/ring/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def RING ( lam : list [ int ] | None , Ts : float | None , ** kwargs ) -> ml . AbstractFilter : \"\"\"Creates the RING network. Params: lam: parent array, if `None` must be given via `ringnet.apply(..., lam=lam)` Ts : sampling interval of IMU data; time delta in seconds Returns: ring.ml.AbstractFilter: An instantiation of `ring.ml.ringnet.RING` with trained parameters. Examples: >>> import ring >>> import numpy as np >>> >>> T : int = 30 # sequence length [s] >>> Ts : float = 0.01 # sampling interval [s] >>> B : int = 1 # batch size >>> lam: list[int] = [0, 1, 2] # parent array >>> N : int = len(lam) # number of bodies >>> T_i: int = int(T/Ts) # number of timesteps >>> >>> X = np.zeros((B, T_i, N, 9)) >>> # where X is structured as follows: >>> # X[..., :3] = acc >>> # X[..., 3:6] = gyr >>> # X[..., 6:9] = jointaxis >>> >>> # let's assume we have an IMU on each outer segment of the >>> # three-segment kinematic chain >>> X[:, :, 0, :3] = acc_segment1 >>> X[:, :, 2, :3] = acc_segment3 >>> X[:, :, 0, 3:6] = gyr_segment1 >>> X[:, :, 2, 3:6] = gyr_segment3 >>> >>> ringnet = ring.RING(lam, Ts) >>> >>> yhat, _ = ringnet.apply(X) >>> # yhat : unit quaternions, shape = (B, T_i, N, 4) >>> # yhat[b, :, i] is the orientation from body `i` to parent body `lam[i]` >>> >>> # use `jax.jit` to compile the forward pass >>> jit_apply = jax.jit(ringnet.apply) >>> yhat, _ = jit_apply(X) >>> >>> # manually pass in and out the hidden state like so >>> initial_state = None >>> yhat, state = ringnet.apply(X, state=initial_state) >>> # state: final hidden state, shape = (B, N, 2*H) \"\"\" from pathlib import Path import warnings config = dict ( use_100Hz_RING = True , use_lpf = True , lpf_cutoff_freq = ml . _LPF_CUTOFF_FREQ , ) config . update ( kwargs ) if Ts is not None and ( Ts > ( 1 / 40 ) or Ts < ( 1 / 200 )): warnings . warn ( \"RING was only trained on sampling rates between 40 to 200 Hz \" f \"but found { 1 / Ts } Hz\" ) if Ts is not None and Ts == 0.01 and config [ \"use_100Hz_RING\" ]: # this set of parameters was trained exclusively on 100Hz data; it also # expects F=9 features per node and not F=10 where the last features is # the sampling interval Ts params = Path ( __file__ ) . parent . joinpath ( \"ml/params/0x1d76628065a71e0f.pickle\" ) add_Ts = False else : # this set of parameters was trained on sampling rates from 40 to 200 Hz params = Path ( __file__ ) . parent . joinpath ( \"ml/params/0x13e3518065c21cd8.pickle\" ) add_Ts = True ringnet = ml . RING ( params = params , lam = None if lam is None else tuple ( lam ), jit = config . pop ( \"jit\" , False ), name = \"RING\" , ) ringnet = ml . base . ScaleX_FilterWrapper ( ringnet ) if config [ \"use_lpf\" ]: ringnet = ml . base . LPF_FilterWrapper ( ringnet , config [ \"lpf_cutoff_freq\" ], samp_freq = None if Ts is None else 1 / Ts , quiet = True , ) ringnet = ml . base . GroundTruthHeading_FilterWrapper ( ringnet ) if add_Ts : ringnet = ml . base . AddTs_FilterWrapper ( ringnet , Ts ) return ringnet RING \u00a4 Source code in src/ring/ml/ringnet.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class RING ( ml_base . AbstractFilter ): def __init__ ( self , params = None , lam = None , jit : bool = True , name = None , forward_factory = make_ring , ** kwargs , ): \"Untrained RING network\" self . forward_lam_factory = partial ( forward_factory , ** kwargs ) self . params = self . _load_params ( params ) self . lam = lam self . _name = name if jit : self . apply = jax . jit ( self . apply , static_argnames = \"lam\" ) def apply ( self , X , params = None , state = None , y = None , lam = None ): if lam is None : assert self . lam is not None lam = self . lam return super () . apply ( X , params , state , y , tuple ( lam )) def init ( self , bs : Optional [ int ] = None , X = None , lam = None , seed : int = 1 ): assert X is not None , \"Providing `X` via in `ringnet.init(X=X)` is required\" if bs is not None : assert X . ndim == 4 if X . ndim == 4 : if bs is not None : assert bs == X . shape [ 0 ] else : bs = X . shape [ 0 ] X = X [ 0 ] # (T, N, F) -> (1, N, F) for faster .init call X = X [ 0 : 1 ] if lam is None : assert self . lam is not None lam = self . lam key = jax . random . PRNGKey ( seed ) params , state = self . forward_lam_factory ( lam = lam ) . init ( key , X ) if bs is not None : state = jax . tree . map ( lambda arr : jnp . repeat ( arr [ None ], bs , axis = 0 ), state ) return params , state def _apply_batched ( self , X , params , state , y , lam ): if ( params is None and self . params is None ) or state is None : _params , _state = self . init ( bs = X . shape [ 0 ], X = X , lam = lam ) if params is None and self . params is None : params = _params elif params is None : params = self . params else : pass if state is None : state = _state yhat , next_state = jax . vmap ( self . forward_lam_factory ( lam = lam ) . apply , in_axes = ( None , 0 , 0 ) )( params , state , X ) return yhat , next_state @staticmethod def _load_params ( params : str | dict | None | Path ): assert isinstance ( params , ( str , dict , type ( None ), Path )) if isinstance ( params , ( Path , str )): return pickle_load ( params ) return params def nojit ( self ) -> \"RING\" : ringnet = RING ( params = self . params , lam = self . lam , jit = False ) ringnet . forward_lam_factory = self . forward_lam_factory return ringnet def _pre_save ( self , params = None , lam = None ) -> None : if params is not None : self . params = params if lam is not None : self . lam = lam @staticmethod def _post_load ( ringnet : \"RING\" , jit : bool = True ) -> \"RING\" : if jit : ringnet . apply = jax . jit ( ringnet . apply , static_argnames = \"lam\" ) return ringnet __init__ ( params = None , lam = None , jit = True , name = None , forward_factory = make_ring , ** kwargs ) \u00a4 Untrained RING network Source code in src/ring/ml/ringnet.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def __init__ ( self , params = None , lam = None , jit : bool = True , name = None , forward_factory = make_ring , ** kwargs , ): \"Untrained RING network\" self . forward_lam_factory = partial ( forward_factory , ** kwargs ) self . params = self . _load_params ( params ) self . lam = lam self . _name = name if jit : self . apply = jax . jit ( self . apply , static_argnames = \"lam\" ) RCMG \u00a4 RCMG \u00a4 Source code in src/ring/algorithms/generator/base.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 class RCMG : def __init__ ( self , sys : base . System | list [ base . System ], config : jcalc . MotionConfig | list [ jcalc . MotionConfig ] = jcalc . MotionConfig (), setup_fn : Optional [ types . SETUP_FN ] = None , finalize_fn : Optional [ types . FINALIZE_FN ] = None , add_X_imus : bool = False , add_X_imus_kwargs : dict = dict (), add_X_jointaxes : bool = False , add_X_jointaxes_kwargs : dict = dict (), add_y_relpose : bool = False , add_y_rootincl : bool = False , add_y_rootincl_kwargs : dict = dict (), add_y_rootfull : bool = False , add_y_rootfull_kwargs : dict = dict (), sys_ml : Optional [ base . System ] = None , randomize_positions : bool = False , randomize_motion_artifacts : bool = False , randomize_joint_params : bool = False , randomize_hz : bool = False , randomize_hz_kwargs : dict = dict (), imu_motion_artifacts : bool = False , imu_motion_artifacts_kwargs : dict = dict (), dynamic_simulation : bool = False , dynamic_simulation_kwargs : dict = dict (), output_transform : Optional [ Callable ] = None , keep_output_extras : bool = False , use_link_number_in_Xy : bool = False , cor : bool = False , disable_tqdm : bool = False , ) -> None : \"Random Chain Motion Generator\" # add some default values randomize_hz_kwargs_defaults = dict ( add_dt = True ) randomize_hz_kwargs_defaults . update ( randomize_hz_kwargs ) randomize_hz_kwargs = randomize_hz_kwargs_defaults sys , config = utils . to_list ( sys ), utils . to_list ( config ) sys_ml = sys [ 0 ] if sys_ml is None else sys_ml for c in config : assert c . is_feasible () self . gens = [] for _sys in sys : self . gens . append ( _build_mconfig_batched_generator ( sys = _sys , config = config , setup_fn = setup_fn , finalize_fn = finalize_fn , add_X_imus = add_X_imus , add_X_imus_kwargs = add_X_imus_kwargs , add_X_jointaxes = add_X_jointaxes , add_X_jointaxes_kwargs = add_X_jointaxes_kwargs , add_y_relpose = add_y_relpose , add_y_rootincl = add_y_rootincl , add_y_rootincl_kwargs = add_y_rootincl_kwargs , add_y_rootfull = add_y_rootfull , add_y_rootfull_kwargs = add_y_rootfull_kwargs , sys_ml = sys_ml , randomize_positions = randomize_positions , randomize_motion_artifacts = randomize_motion_artifacts , randomize_joint_params = randomize_joint_params , randomize_hz = randomize_hz , randomize_hz_kwargs = randomize_hz_kwargs , imu_motion_artifacts = imu_motion_artifacts , imu_motion_artifacts_kwargs = imu_motion_artifacts_kwargs , dynamic_simulation = dynamic_simulation , dynamic_simulation_kwargs = dynamic_simulation_kwargs , output_transform = output_transform , keep_output_extras = keep_output_extras , use_link_number_in_Xy = use_link_number_in_Xy , cor = cor , ) ) self . _n_mconfigs = len ( config ) self . _size_of_generators = [ self . _n_mconfigs ] * len ( self . gens ) self . _disable_tqdm = disable_tqdm def _compute_repeats ( self , sizes : int | list [ int ]) -> list [ int ]: \"how many times the generators are repeated to create a batch of `sizes`\" S , L = sum ( self . _size_of_generators ), len ( self . _size_of_generators ) def assert_size ( size : int ): assert self . _n_mconfigs in utils . primes ( size ), ( f \"`size`= { size } is not divisible by number of \" + f \"`mconfigs`= { self . _n_mconfigs } \" ) if isinstance ( sizes , int ): assert ( sizes // S ) > 0 , f \"Batchsize or size too small. { sizes } < { S } \" assert sizes % S == 0 , f \"`size`= { sizes } not divisible by { S } \" repeats = L * [ sizes // S ] else : for size in sizes : assert_size ( size ) assert len ( sizes ) == len ( self . gens ), f \"len(`sizes`)= { len ( sizes ) } != { len ( self . gens ) } \" repeats = [ size // size_of_gen for size , size_of_gen in zip ( sizes , self . _size_of_generators ) ] assert 0 not in repeats return repeats def to_lazy_gen ( self , sizes : int | list [ int ] = 1 , jit : bool = True ) -> types . BatchedGenerator : return batch . generators_lazy ( self . gens , self . _compute_repeats ( sizes ), jit ) @staticmethod def _number_of_executions_required ( size : int ) -> int : _ , vmap = utils . distribute_batchsize ( size ) eager_threshold = utils . batchsize_thresholds ()[ 1 ] primes = iter ( utils . primes ( vmap )) n_calls = 1 while vmap > eager_threshold : prime = next ( primes ) n_calls *= prime vmap /= prime return n_calls def _generators_ncalls ( self , sizes : int | list [ int ] = 1 ): \"Returns list of unbatched sequences as numpy arrays.\" repeats = self . _compute_repeats ( sizes ) sizes = list ( jnp . array ( repeats ) * jnp . array ( self . _size_of_generators )) reduced_repeats = [] n_calls = [] for size , repeat in zip ( sizes , repeats ): n_call = self . _number_of_executions_required ( size ) gcd = utils . gcd ( n_call , repeat ) n_calls . append ( gcd ) reduced_repeats . append ( repeat // gcd ) jits = [ N > 1 for N in n_calls ] gens = [] for i in range ( len ( repeats )): gens . append ( batch . generators_lazy ([ self . gens [ i ]], [ reduced_repeats [ i ]], jits [ i ]) ) return gens , n_calls def to_list ( self , sizes : int | list [ int ] = 1 , seed : int = 1 ) -> list [ tree_utils . PyTree [ np . ndarray ]]: \"Returns list of unbatched sequences as numpy arrays.\" gens , n_calls = self . _generators_ncalls ( sizes ) data = [] batch . generators_eager ( gens , n_calls , lambda d : data . extend ( d ), seed , self . _disable_tqdm ) return data def to_folder ( self , path : str , sizes : int | list [ int ] = 1 , seed : int = 1 , overwrite : bool = True , file_prefix : str = \"seq\" , save_fn : Callable [[ PyTree [ np . ndarray ], str ], None ] = partial ( utils . pickle_save , overwrite = True ), verbose : bool = True , ): i = 0 def callback ( data : list [ PyTree [ np . ndarray ]]) -> None : nonlocal i data = utils . replace_elements_w_nans ( data , verbose = verbose ) for d in data : file = utils . parse_path ( path , file_prefix + str ( i ), file_exists_ok = overwrite ) save_fn ( d , file ) i += 1 # cleanup del data gens , n_calls = self . _generators_ncalls ( sizes ) batch . generators_eager ( gens , n_calls , callback , seed , self . _disable_tqdm ) def to_pickle ( self , path : str , sizes : int | list [ int ] = 1 , seed : int = 1 , overwrite : bool = True , ) -> None : data = tree_utils . tree_batch ( self . to_list ( sizes , seed ), backend = \"numpy\" ) utils . pickle_save ( data , path , overwrite = overwrite ) def to_eager_gen ( self , batchsize : int = 1 , sizes : int | list [ int ] = 1 , seed : int = 1 , shuffle : bool = True , transform = None , ) -> types . BatchedGenerator : data = self . to_list ( sizes , seed ) assert len ( data ) >= batchsize return self . eager_gen_from_list ( data , batchsize , shuffle , transform ) @staticmethod def eager_gen_from_list ( data : list [ tree_utils . PyTree ], batchsize : int , shuffle : bool = True , transform = None , ) -> types . BatchedGenerator : data = data . copy () n_batches , i = len ( data ) // batchsize , 0 def generator ( key : jax . Array ): nonlocal i if shuffle and i == 0 : random . shuffle ( data ) start , stop = i * batchsize , ( i + 1 ) * batchsize batch = tree_utils . tree_batch ( data [ start : stop ], backend = \"numpy\" ) batch = utils . pytree_deepcopy ( batch ) if transform is not None : batch = transform ( batch ) i = ( i + 1 ) % n_batches return batch return generator __init__ ( sys , config = jcalc . MotionConfig (), setup_fn = None , finalize_fn = None , add_X_imus = False , add_X_imus_kwargs = dict (), add_X_jointaxes = False , add_X_jointaxes_kwargs = dict (), add_y_relpose = False , add_y_rootincl = False , add_y_rootincl_kwargs = dict (), add_y_rootfull = False , add_y_rootfull_kwargs = dict (), sys_ml = None , randomize_positions = False , randomize_motion_artifacts = False , randomize_joint_params = False , randomize_hz = False , randomize_hz_kwargs = dict (), imu_motion_artifacts = False , imu_motion_artifacts_kwargs = dict (), dynamic_simulation = False , dynamic_simulation_kwargs = dict (), output_transform = None , keep_output_extras = False , use_link_number_in_Xy = False , cor = False , disable_tqdm = False ) \u00a4 Random Chain Motion Generator Source code in src/ring/algorithms/generator/base.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def __init__ ( self , sys : base . System | list [ base . System ], config : jcalc . MotionConfig | list [ jcalc . MotionConfig ] = jcalc . MotionConfig (), setup_fn : Optional [ types . SETUP_FN ] = None , finalize_fn : Optional [ types . FINALIZE_FN ] = None , add_X_imus : bool = False , add_X_imus_kwargs : dict = dict (), add_X_jointaxes : bool = False , add_X_jointaxes_kwargs : dict = dict (), add_y_relpose : bool = False , add_y_rootincl : bool = False , add_y_rootincl_kwargs : dict = dict (), add_y_rootfull : bool = False , add_y_rootfull_kwargs : dict = dict (), sys_ml : Optional [ base . System ] = None , randomize_positions : bool = False , randomize_motion_artifacts : bool = False , randomize_joint_params : bool = False , randomize_hz : bool = False , randomize_hz_kwargs : dict = dict (), imu_motion_artifacts : bool = False , imu_motion_artifacts_kwargs : dict = dict (), dynamic_simulation : bool = False , dynamic_simulation_kwargs : dict = dict (), output_transform : Optional [ Callable ] = None , keep_output_extras : bool = False , use_link_number_in_Xy : bool = False , cor : bool = False , disable_tqdm : bool = False , ) -> None : \"Random Chain Motion Generator\" # add some default values randomize_hz_kwargs_defaults = dict ( add_dt = True ) randomize_hz_kwargs_defaults . update ( randomize_hz_kwargs ) randomize_hz_kwargs = randomize_hz_kwargs_defaults sys , config = utils . to_list ( sys ), utils . to_list ( config ) sys_ml = sys [ 0 ] if sys_ml is None else sys_ml for c in config : assert c . is_feasible () self . gens = [] for _sys in sys : self . gens . append ( _build_mconfig_batched_generator ( sys = _sys , config = config , setup_fn = setup_fn , finalize_fn = finalize_fn , add_X_imus = add_X_imus , add_X_imus_kwargs = add_X_imus_kwargs , add_X_jointaxes = add_X_jointaxes , add_X_jointaxes_kwargs = add_X_jointaxes_kwargs , add_y_relpose = add_y_relpose , add_y_rootincl = add_y_rootincl , add_y_rootincl_kwargs = add_y_rootincl_kwargs , add_y_rootfull = add_y_rootfull , add_y_rootfull_kwargs = add_y_rootfull_kwargs , sys_ml = sys_ml , randomize_positions = randomize_positions , randomize_motion_artifacts = randomize_motion_artifacts , randomize_joint_params = randomize_joint_params , randomize_hz = randomize_hz , randomize_hz_kwargs = randomize_hz_kwargs , imu_motion_artifacts = imu_motion_artifacts , imu_motion_artifacts_kwargs = imu_motion_artifacts_kwargs , dynamic_simulation = dynamic_simulation , dynamic_simulation_kwargs = dynamic_simulation_kwargs , output_transform = output_transform , keep_output_extras = keep_output_extras , use_link_number_in_Xy = use_link_number_in_Xy , cor = cor , ) ) self . _n_mconfigs = len ( config ) self . _size_of_generators = [ self . _n_mconfigs ] * len ( self . gens ) self . _disable_tqdm = disable_tqdm to_list ( sizes = 1 , seed = 1 ) \u00a4 Returns list of unbatched sequences as numpy arrays. Source code in src/ring/algorithms/generator/base.py 180 181 182 183 184 185 186 187 188 189 190 def to_list ( self , sizes : int | list [ int ] = 1 , seed : int = 1 ) -> list [ tree_utils . PyTree [ np . ndarray ]]: \"Returns list of unbatched sequences as numpy arrays.\" gens , n_calls = self . _generators_ncalls ( sizes ) data = [] batch . generators_eager ( gens , n_calls , lambda d : data . extend ( d ), seed , self . _disable_tqdm ) return data System \u00a4 System \u00a4 System object. Create using System.create(path_xml) Source code in src/ring/base.py 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 @struct . dataclass class System ( _Base ): \"System object. Create using `System.create(path_xml)`\" link_parents : list [ int ] = struct . field ( False ) links : Link link_types : list [ str ] = struct . field ( False ) link_damping : jax . Array link_armature : jax . Array link_spring_stiffness : jax . Array link_spring_zeropoint : jax . Array # simulation timestep size dt : float = struct . field ( False ) # geometries in the system geoms : list [ Geometry ] # root / base acceleration offset gravity : jax . Array = struct . field ( default_factory = lambda : jnp . array ([ 0 , 0 , - 9.81 ])) integration_method : str = struct . field ( False , default_factory = lambda : \"semi_implicit_euler\" ) mass_mat_iters : int = struct . field ( False , default_factory = lambda : 0 ) link_names : list [ str ] = struct . field ( False , default_factory = lambda : []) model_name : Optional [ str ] = struct . field ( False , default_factory = lambda : None ) omc : list [ MaxCoordOMC | None ] = struct . field ( True , default_factory = lambda : []) def num_links ( self ) -> int : return len ( self . link_parents ) def q_size ( self ) -> int : return sum ([ Q_WIDTHS [ typ ] for typ in self . link_types ]) def qd_size ( self ) -> int : return sum ([ QD_WIDTHS [ typ ] for typ in self . link_types ]) def name_to_idx ( self , name : str ) -> int : return self . link_names . index ( name ) def idx_to_name ( self , idx : int , allow_world : bool = False ) -> str : if allow_world and idx == - 1 : return \"world\" assert idx >= 0 , \"Worldbody index has no name.\" return self . link_names [ idx ] def idx_map ( self , type : str ) -> dict : \"type: is either `l` or `q` or `d`\" dict_int_slices = {} def f ( _ , idx_map , name : str , link_idx : int ): dict_int_slices [ name ] = idx_map [ type ]( link_idx ) self . scan ( f , \"ll\" , self . link_names , list ( range ( self . num_links ()))) return dict_int_slices def parent_name ( self , name : str ) -> str : return self . idx_to_name ( self . link_parents [ self . name_to_idx ( name )]) def add_prefix ( self , prefix : str = \"\" ) -> \"System\" : return self . replace ( link_names = [ prefix + name for name in self . link_names ]) def change_model_name ( self , new_name : Optional [ str ] = None , prefix : Optional [ str ] = None , suffix : Optional [ str ] = None , ) -> \"System\" : if prefix is None : prefix = \"\" if suffix is None : suffix = \"\" if new_name is None : new_name = self . model_name name = prefix + new_name + suffix return self . replace ( model_name = name ) def change_link_name ( self , old_name : str , new_name : str ) -> \"System\" : old_idx = self . name_to_idx ( old_name ) new_link_names = self . link_names . copy () new_link_names [ old_idx ] = new_name return self . replace ( link_names = new_link_names ) def add_prefix_suffix ( self , prefix : Optional [ str ] = None , suffix : Optional [ str ] = None ) -> \"System\" : if prefix is None : prefix = \"\" if suffix is None : suffix = \"\" new_link_names = [ prefix + name + suffix for name in self . link_names ] return self . replace ( link_names = new_link_names ) def _replace_free_with_cor ( self ) -> \"System\" : # check that # - all free joints connect to -1 # - all joints connecting to -1 are free joints for i , p in enumerate ( self . link_parents ): link_type = self . link_types [ i ] if ( p == - 1 and link_type != \"free\" ) or ( link_type == \"free\" and p != - 1 ): raise InvalidSystemError ( f \"link= { self . idx_to_name ( i ) } , parent=\" f \" { self . idx_to_name ( p , allow_world = True ) } ,\" f \" joint= { link_type } . Hint: Try setting `config.cor` to false.\" ) def logic_replace_free_with_cor ( name , olt , ola , old , ols , olz ): # by default new is equal to old nlt , nla , nld , nls , nlz = olt , ola , old , ols , olz # old link type == free if olt == \"free\" : # cor joint is (free, p3d) stacked nlt = \"cor\" # entries of old armature are 3*ang (spherical), 3*pos (p3d) nla = jnp . concatenate (( ola , ola [ 3 :])) nld = jnp . concatenate (( old , old [ 3 :])) nls = jnp . concatenate (( ols , ols [ 3 :])) nlz = jnp . concatenate (( olz , olz [ 4 :])) return nlt , nla , nld , nls , nlz return _update_sys_if_replace_joint_type ( self , logic_replace_free_with_cor ) def freeze ( self , name : str | list [ str ]): if isinstance ( name , list ): sys = self for n in name : sys = sys . freeze ( n ) return sys def logic_freeze ( link_name , olt , ola , old , ols , olz ): nlt , nla , nld , nls , nlz = olt , ola , old , ols , olz if link_name == name : nlt = \"frozen\" nla = nld = nls = nlz = jnp . array ([]) return nlt , nla , nld , nls , nlz return _update_sys_if_replace_joint_type ( self , logic_freeze ) def unfreeze ( self , name : str , new_joint_type : str ): assert self . link_types [ self . name_to_idx ( name )] == \"frozen\" assert new_joint_type != \"frozen\" return self . change_joint_type ( name , new_joint_type ) def change_joint_type ( self , name : str , new_joint_type : str , new_arma : Optional [ jax . Array ] = None , new_damp : Optional [ jax . Array ] = None , new_stif : Optional [ jax . Array ] = None , new_zero : Optional [ jax . Array ] = None , seed : int = 1 , warn : bool = True , ): \"By default damping, stiffness are set to zero.\" from ring.algorithms import get_joint_model q_size , qd_size = Q_WIDTHS [ new_joint_type ], QD_WIDTHS [ new_joint_type ] def logic_unfreeze_to_spherical ( link_name , olt , ola , old , ols , olz ): nlt , nla , nld , nls , nlz = olt , ola , old , ols , olz if link_name == name : nlt = new_joint_type q_zeros = jnp . zeros (( q_size )) qd_zeros = jnp . zeros (( qd_size ,)) nla = qd_zeros if new_arma is None else new_arma nld = qd_zeros if new_damp is None else new_damp nls = qd_zeros if new_stif is None else new_stif nlz = q_zeros if new_zero is None else new_zero # unit quaternion if new_joint_type in [ \"spherical\" , \"free\" , \"cor\" ] and new_zero is None : nlz = nlz . at [ 0 ] . set ( 1.0 ) return nlt , nla , nld , nls , nlz sys = _update_sys_if_replace_joint_type ( self , logic_unfreeze_to_spherical ) jm = get_joint_model ( new_joint_type ) if jm . init_joint_params is not None : sys = sys . from_str ( sys . to_str ( warn = warn ), seed = seed ) return sys @staticmethod def joint_type_simplification ( typ : str ) -> str : if typ [: 4 ] == \"free\" : if typ == \"free_2d\" : return \"free_2d\" else : return \"free\" elif typ [: 3 ] == \"cor\" : return \"cor\" elif typ [: 9 ] == \"spherical\" : return \"spherical\" else : return typ @staticmethod def joint_type_is_free_or_cor ( typ : str ) -> bool : return System . joint_type_simplification ( typ ) in [ \"free\" , \"cor\" ] @staticmethod def joint_type_is_spherical ( typ : str ) -> bool : return System . joint_type_simplification ( typ ) == \"spherical\" @staticmethod def joint_type_is_free_or_cor_or_spherical ( typ : str ) -> bool : return System . joint_type_is_free_or_cor ( typ ) or System . joint_type_is_spherical ( typ ) def findall_imus ( self , names : bool = True ) -> list [ str ] | list [ int ]: bodies = [ name for name in self . link_names if name [: 3 ] == \"imu\" ] return bodies if names else [ self . name_to_idx ( n ) for n in bodies ] def findall_segments ( self , names : bool = True ) -> list [ str ] | list [ int ]: imus = self . findall_imus ( names = True ) bodies = [ name for name in self . link_names if name not in imus ] return bodies if names else [ self . name_to_idx ( n ) for n in bodies ] def _bodies_indices_to_bodies_name ( self , bodies : list [ int ]) -> list [ str ]: return [ self . idx_to_name ( i ) for i in bodies ] def findall_bodies_to_world ( self , names : bool = False ) -> list [ int ] | list [ str ]: bodies = [ i for i , p in enumerate ( self . link_parents ) if p == - 1 ] return self . _bodies_indices_to_bodies_name ( bodies ) if names else bodies def find_body_to_world ( self , name : bool = False ) -> int | str : bodies = self . findall_bodies_to_world ( names = name ) assert len ( bodies ) == 1 return bodies [ 0 ] def findall_bodies_with_jointtype ( self , typ : str , names : bool = False ) -> list [ int ] | list [ str ]: bodies = [ i for i , _typ in enumerate ( self . link_types ) if _typ == typ ] return self . _bodies_indices_to_bodies_name ( bodies ) if names else bodies def children ( self , name : str , names : bool = False ) -> list [ int ] | list [ str ]: \"List all direct children of body, does not include body itself\" p = self . name_to_idx ( name ) bodies = [ i for i in range ( self . num_links ()) if self . link_parents [ i ] == p ] return bodies if ( not names ) else [ self . idx_to_name ( i ) for i in bodies ] def findall_bodies_subsystem ( self , name : str , names : bool = False ) -> list [ int ] | list [ str ]: \"List all children and children's children; does not include body itself\" children = self . children ( name , names = True ) grandchildren = [ self . findall_bodies_subsystem ( n , names = True ) for n in children ] bodies = tree . flatten ([ children , grandchildren ]) return bodies if names else [ self . name_to_idx ( n ) for n in bodies ] def scan ( self , f : Callable , in_types : str , * args , reverse : bool = False ): \"\"\"Scan `f` along each link in system whilst carrying along state. Args: f (Callable[..., Y]): f(y: Y, *args) -> y in_types: string specifying the type of each input arg: 'l' is an input to be split according to link ranges 'q' is an input to be split according to q ranges 'd' is an input to be split according to qd ranges args: Arguments passed to `f`, and split to match the link. reverse (bool, optional): If `true` from leaves to root. Defaults to False. Returns: ys: Stacked output y of f. \"\"\" return _scan_sys ( self , f , in_types , * args , reverse = reverse ) def parse ( self ) -> \"System\" : \"\"\"Initial setup of system. System object does not work unless it is parsed. Currently it does: - some consistency checks - populate the spatial inertia tensors - check that all names are unique - check that names are strings - check that all pos_min <= pos_max (unless traced) - order geoms in ascending order based on their parent link idx - check that all links have the correct size of - damping - armature - stiffness - zeropoint - check that n_links == len(sys.omc) \"\"\" return _parse_system ( self ) def render ( self , xs : Optional [ Transform | list [ Transform ]] = None , camera : Optional [ str ] = None , show_pbar : bool = True , backend : str = \"mujoco\" , render_every_nth : int = 1 , ** scene_kwargs , ) -> list [ np . ndarray ]: \"\"\"Render frames from system and trajectory of maximal coordinates `xs`. Args: sys (base.System): System to render. xs (base.Transform | list[base.Transform]): Single or time-series of maximal coordinates `xs`. show_pbar (bool, optional): Whether or not to show a progress bar. Defaults to True. Returns: list[np.ndarray]: Stacked rendered frames. Length == len(xs). \"\"\" return ring . rendering . render ( self , xs , camera , show_pbar , backend , render_every_nth , ** scene_kwargs ) def render_prediction ( self , xs : Transform | list [ Transform ], yhat : dict | jax . Array | np . ndarray , # by default we don't predict the global rotation transparent_segment_to_root : bool = True , ** kwargs , ): \"\"\"`xs` matches `sys`. `yhat` matches `sys_noimu`. `yhat` are child-to-parent. Note that the body in yhat that connects to -1, is parent-to-child! \"\"\" return ring . rendering . render_prediction ( self , xs , yhat , transparent_segment_to_root , ** kwargs ) def delete_system ( self , link_name : str | list [ str ], strict : bool = True ): \"Cut subsystem starting at `link_name` (inclusive) from tree.\" return ring . sys_composer . delete_subsystem ( self , link_name , strict ) def make_sys_noimu ( self , imu_link_names : Optional [ list [ str ]] = None ): \"Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'}\" return ring . sys_composer . make_sys_noimu ( self , imu_link_names ) def inject_system ( self , other_system : \"System\" , at_body : Optional [ str ] = None ): \"\"\"Combine two systems into one. Args: sys (base.System): Large system. sub_sys (base.System): Small system that will be included into the large system `sys`. at_body (Optional[str], optional): Into which body of the large system small system will be included. Defaults to `worldbody`. Returns: base.System: _description_ \"\"\" return ring . sys_composer . inject_system ( self , other_system , at_body ) def morph_system ( self , new_parents : Optional [ list [ int | str ]] = None , new_anchor : Optional [ int | str ] = None , ): \"\"\"Re-orders the graph underlying the system. Returns a new system. Args: sys (base.System): System to be modified. new_parents (list[int]): Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system. Returns: base.System: Modified system. \"\"\" return ring . sys_composer . morph_system ( self , new_parents , new_anchor ) @staticmethod def from_xml ( path : str , seed : int = 1 ): return ring . io . load_sys_from_xml ( path , seed ) @staticmethod def from_str ( xml : str , seed : int = 1 ): return ring . io . load_sys_from_str ( xml , seed ) def to_str ( self , warn : bool = True ) -> str : return ring . io . save_sys_to_str ( self , warn = warn ) def to_xml ( self , path : str ) -> None : ring . io . save_sys_to_xml ( self , path ) @classmethod def create ( cls , path_or_str : str , seed : int = 1 ) -> \"System\" : path = Path ( path_or_str ) . with_suffix ( \".xml\" ) exists = False try : exists = path . exists () except OSError : # file length too length pass if exists : return cls . from_xml ( path , seed = seed ) else : return cls . from_str ( path_or_str , seed = seed ) def coordinate_vector_to_q ( self , q : jax . Array , custom_joints : dict [ str , Callable ] = {}, ) -> jax . Array : \"\"\"Map a coordinate vector `q` to the minimal coordinates vector of the sys\"\"\" # Does, e.g. # - normalize quaternions # - hinge joints in [-pi, pi] q_preproc = [] def preprocess ( _ , __ , link_type , q ): to_q = ring . algorithms . jcalc . get_joint_model ( link_type ) . coordinate_vector_to_q # function in custom_joints has priority over JointModel if link_type in custom_joints : to_q = custom_joints [ link_type ] if to_q is None : raise NotImplementedError ( f \"Please specify the custom joint ` { link_type } `\" \" either using the `custom_joints` arguments or using the\" \" JointModel.coordinate_vector_to_q field.\" ) new_q = to_q ( q ) q_preproc . append ( new_q ) self . scan ( preprocess , \"lq\" , self . link_types , q ) return jnp . concatenate ( q_preproc ) idx_map ( type ) \u00a4 type: is either l or q or d Source code in src/ring/base.py 449 450 451 452 453 454 455 456 457 458 def idx_map ( self , type : str ) -> dict : \"type: is either `l` or `q` or `d`\" dict_int_slices = {} def f ( _ , idx_map , name : str , link_idx : int ): dict_int_slices [ name ] = idx_map [ type ]( link_idx ) self . scan ( f , \"ll\" , self . link_names , list ( range ( self . num_links ()))) return dict_int_slices change_joint_type ( name , new_joint_type , new_arma = None , new_damp = None , new_stif = None , new_zero = None , seed = 1 , warn = True ) \u00a4 By default damping, stiffness are set to zero. Source code in src/ring/base.py 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 def change_joint_type ( self , name : str , new_joint_type : str , new_arma : Optional [ jax . Array ] = None , new_damp : Optional [ jax . Array ] = None , new_stif : Optional [ jax . Array ] = None , new_zero : Optional [ jax . Array ] = None , seed : int = 1 , warn : bool = True , ): \"By default damping, stiffness are set to zero.\" from ring.algorithms import get_joint_model q_size , qd_size = Q_WIDTHS [ new_joint_type ], QD_WIDTHS [ new_joint_type ] def logic_unfreeze_to_spherical ( link_name , olt , ola , old , ols , olz ): nlt , nla , nld , nls , nlz = olt , ola , old , ols , olz if link_name == name : nlt = new_joint_type q_zeros = jnp . zeros (( q_size )) qd_zeros = jnp . zeros (( qd_size ,)) nla = qd_zeros if new_arma is None else new_arma nld = qd_zeros if new_damp is None else new_damp nls = qd_zeros if new_stif is None else new_stif nlz = q_zeros if new_zero is None else new_zero # unit quaternion if new_joint_type in [ \"spherical\" , \"free\" , \"cor\" ] and new_zero is None : nlz = nlz . at [ 0 ] . set ( 1.0 ) return nlt , nla , nld , nls , nlz sys = _update_sys_if_replace_joint_type ( self , logic_unfreeze_to_spherical ) jm = get_joint_model ( new_joint_type ) if jm . init_joint_params is not None : sys = sys . from_str ( sys . to_str ( warn = warn ), seed = seed ) return sys children ( name , names = False ) \u00a4 List all direct children of body, does not include body itself Source code in src/ring/base.py 650 651 652 653 654 def children ( self , name : str , names : bool = False ) -> list [ int ] | list [ str ]: \"List all direct children of body, does not include body itself\" p = self . name_to_idx ( name ) bodies = [ i for i in range ( self . num_links ()) if self . link_parents [ i ] == p ] return bodies if ( not names ) else [ self . idx_to_name ( i ) for i in bodies ] findall_bodies_subsystem ( name , names = False ) \u00a4 List all children and children's children; does not include body itself Source code in src/ring/base.py 656 657 658 659 660 661 662 663 def findall_bodies_subsystem ( self , name : str , names : bool = False ) -> list [ int ] | list [ str ]: \"List all children and children's children; does not include body itself\" children = self . children ( name , names = True ) grandchildren = [ self . findall_bodies_subsystem ( n , names = True ) for n in children ] bodies = tree . flatten ([ children , grandchildren ]) return bodies if names else [ self . name_to_idx ( n ) for n in bodies ] scan ( f , in_types , * args , reverse = False ) \u00a4 Scan f along each link in system whilst carrying along state. Parameters: f ( Callable [..., Y ] ) \u2013 f(y: Y, *args) -> y in_types ( str ) \u2013 string specifying the type of each input arg: 'l' is an input to be split according to link ranges 'q' is an input to be split according to q ranges 'd' is an input to be split according to qd ranges args \u2013 Arguments passed to f , and split to match the link. reverse ( bool , default: False ) \u2013 If true from leaves to root. Defaults to False. Returns: ys \u2013 Stacked output y of f. Source code in src/ring/base.py 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def scan ( self , f : Callable , in_types : str , * args , reverse : bool = False ): \"\"\"Scan `f` along each link in system whilst carrying along state. Args: f (Callable[..., Y]): f(y: Y, *args) -> y in_types: string specifying the type of each input arg: 'l' is an input to be split according to link ranges 'q' is an input to be split according to q ranges 'd' is an input to be split according to qd ranges args: Arguments passed to `f`, and split to match the link. reverse (bool, optional): If `true` from leaves to root. Defaults to False. Returns: ys: Stacked output y of f. \"\"\" return _scan_sys ( self , f , in_types , * args , reverse = reverse ) parse () \u00a4 Initial setup of system. System object does not work unless it is parsed. Currently it does: - some consistency checks - populate the spatial inertia tensors - check that all names are unique - check that names are strings - check that all pos_min <= pos_max (unless traced) - order geoms in ascending order based on their parent link idx - check that all links have the correct size of - damping - armature - stiffness - zeropoint - check that n_links == len(sys.omc) Source code in src/ring/base.py 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 def parse ( self ) -> \"System\" : \"\"\"Initial setup of system. System object does not work unless it is parsed. Currently it does: - some consistency checks - populate the spatial inertia tensors - check that all names are unique - check that names are strings - check that all pos_min <= pos_max (unless traced) - order geoms in ascending order based on their parent link idx - check that all links have the correct size of - damping - armature - stiffness - zeropoint - check that n_links == len(sys.omc) \"\"\" return _parse_system ( self ) render ( xs = None , camera = None , show_pbar = True , backend = 'mujoco' , render_every_nth = 1 , ** scene_kwargs ) \u00a4 Render frames from system and trajectory of maximal coordinates xs . Parameters: sys ( System ) \u2013 System to render. xs ( Transform | list [ Transform ] , default: None ) \u2013 Single or time-series show_pbar ( bool , default: True ) \u2013 Whether or not to show a progress bar. Returns: list [ ndarray ] \u2013 list[np.ndarray]: Stacked rendered frames. Length == len(xs). Source code in src/ring/base.py 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 def render ( self , xs : Optional [ Transform | list [ Transform ]] = None , camera : Optional [ str ] = None , show_pbar : bool = True , backend : str = \"mujoco\" , render_every_nth : int = 1 , ** scene_kwargs , ) -> list [ np . ndarray ]: \"\"\"Render frames from system and trajectory of maximal coordinates `xs`. Args: sys (base.System): System to render. xs (base.Transform | list[base.Transform]): Single or time-series of maximal coordinates `xs`. show_pbar (bool, optional): Whether or not to show a progress bar. Defaults to True. Returns: list[np.ndarray]: Stacked rendered frames. Length == len(xs). \"\"\" return ring . rendering . render ( self , xs , camera , show_pbar , backend , render_every_nth , ** scene_kwargs ) render_prediction ( xs , yhat , transparent_segment_to_root = True , ** kwargs ) \u00a4 xs matches sys . yhat matches sys_noimu . yhat are child-to-parent. Note that the body in yhat that connects to -1, is parent-to-child! Source code in src/ring/base.py 725 726 727 728 729 730 731 732 733 734 735 736 737 738 def render_prediction ( self , xs : Transform | list [ Transform ], yhat : dict | jax . Array | np . ndarray , # by default we don't predict the global rotation transparent_segment_to_root : bool = True , ** kwargs , ): \"\"\"`xs` matches `sys`. `yhat` matches `sys_noimu`. `yhat` are child-to-parent. Note that the body in yhat that connects to -1, is parent-to-child! \"\"\" return ring . rendering . render_prediction ( self , xs , yhat , transparent_segment_to_root , ** kwargs ) delete_system ( link_name , strict = True ) \u00a4 Cut subsystem starting at link_name (inclusive) from tree. Source code in src/ring/base.py 740 741 742 def delete_system ( self , link_name : str | list [ str ], strict : bool = True ): \"Cut subsystem starting at `link_name` (inclusive) from tree.\" return ring . sys_composer . delete_subsystem ( self , link_name , strict ) make_sys_noimu ( imu_link_names = None ) \u00a4 Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'} Source code in src/ring/base.py 744 745 746 def make_sys_noimu ( self , imu_link_names : Optional [ list [ str ]] = None ): \"Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'}\" return ring . sys_composer . make_sys_noimu ( self , imu_link_names ) inject_system ( other_system , at_body = None ) \u00a4 Combine two systems into one. Parameters: sys ( System ) \u2013 Large system. sub_sys ( System ) \u2013 Small system that will be included into the large system sys . at_body ( Optional [ str ] , default: None ) \u2013 Into which body of the large system small system will be included. Defaults to worldbody . Returns: \u2013 base.System: description Source code in src/ring/base.py 748 749 750 751 752 753 754 755 756 757 758 759 760 761 def inject_system ( self , other_system : \"System\" , at_body : Optional [ str ] = None ): \"\"\"Combine two systems into one. Args: sys (base.System): Large system. sub_sys (base.System): Small system that will be included into the large system `sys`. at_body (Optional[str], optional): Into which body of the large system small system will be included. Defaults to `worldbody`. Returns: base.System: _description_ \"\"\" return ring . sys_composer . inject_system ( self , other_system , at_body ) morph_system ( new_parents = None , new_anchor = None ) \u00a4 Re-orders the graph underlying the system. Returns a new system. Parameters: sys ( System ) \u2013 System to be modified. new_parents ( list [ int ] , default: None ) \u2013 Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system. Returns: \u2013 base.System: Modified system. Source code in src/ring/base.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 def morph_system ( self , new_parents : Optional [ list [ int | str ]] = None , new_anchor : Optional [ int | str ] = None , ): \"\"\"Re-orders the graph underlying the system. Returns a new system. Args: sys (base.System): System to be modified. new_parents (list[int]): Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system. Returns: base.System: Modified system. \"\"\" return ring . sys_composer . morph_system ( self , new_parents , new_anchor ) coordinate_vector_to_q ( q , custom_joints = {}) \u00a4 Map a coordinate vector q to the minimal coordinates vector of the sys Source code in src/ring/base.py 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 def coordinate_vector_to_q ( self , q : jax . Array , custom_joints : dict [ str , Callable ] = {}, ) -> jax . Array : \"\"\"Map a coordinate vector `q` to the minimal coordinates vector of the sys\"\"\" # Does, e.g. # - normalize quaternions # - hinge joints in [-pi, pi] q_preproc = [] def preprocess ( _ , __ , link_type , q ): to_q = ring . algorithms . jcalc . get_joint_model ( link_type ) . coordinate_vector_to_q # function in custom_joints has priority over JointModel if link_type in custom_joints : to_q = custom_joints [ link_type ] if to_q is None : raise NotImplementedError ( f \"Please specify the custom joint ` { link_type } `\" \" either using the `custom_joints` arguments or using the\" \" JointModel.coordinate_vector_to_q field.\" ) new_q = to_q ( q ) q_preproc . append ( new_q ) self . scan ( preprocess , \"lq\" , self . link_types , q ) return jnp . concatenate ( q_preproc ) MotionConfig \u00a4 MotionConfig dataclass \u00a4 Configuration for joint motion generation in kinematic and dynamic simulations. This class defines the constraints and parameters for generating random joint motions, including angular and positional velocity limits, interpolation methods, and range restrictions for various joint types. Attributes: T ( float ) \u2013 Total duration of the motion sequence (in seconds). t_min ( float ) \u2013 Minimum time interval between two generated joint states. t_max ( float | TimeDependentFloat ) \u2013 Maximum time interval between two generated joint states. dang_min ( float | TimeDependentFloat ) \u2013 Minimum angular velocity (rad/s). dang_max ( float | TimeDependentFloat ) \u2013 Maximum angular velocity (rad/s). dang_min_free_spherical ( float | TimeDependentFloat ) \u2013 Minimum angular velocity for free and spherical joints. dang_max_free_spherical ( float | TimeDependentFloat ) \u2013 Maximum angular velocity for free and spherical joints. delta_ang_min ( float | TimeDependentFloat ) \u2013 Minimum allowed change in joint angle (radians). delta_ang_max ( float | TimeDependentFloat ) \u2013 Maximum allowed change in joint angle (radians). delta_ang_min_free_spherical ( float | TimeDependentFloat ) \u2013 Minimum allowed change in angle for free/spherical joints. delta_ang_max_free_spherical ( float | TimeDependentFloat ) \u2013 Maximum allowed change in angle for free/spherical joints. dpos_min ( float | TimeDependentFloat ) \u2013 Minimum translational velocity. dpos_max ( float | TimeDependentFloat ) \u2013 Maximum translational velocity. pos_min ( float | TimeDependentFloat ) \u2013 Minimum position constraint. pos_max ( float | TimeDependentFloat ) \u2013 Maximum position constraint. pos_min_p3d_x ( float | TimeDependentFloat ) \u2013 Minimum position in x-direction for P3D joints. pos_max_p3d_x ( float | TimeDependentFloat ) \u2013 Maximum position in x-direction for P3D joints. pos_min_p3d_y ( float | TimeDependentFloat ) \u2013 Minimum position in y-direction for P3D joints. pos_max_p3d_y ( float | TimeDependentFloat ) \u2013 Maximum position in y-direction for P3D joints. pos_min_p3d_z ( float | TimeDependentFloat ) \u2013 Minimum position in z-direction for P3D joints. pos_max_p3d_z ( float | TimeDependentFloat ) \u2013 Maximum position in z-direction for P3D joints. cdf_bins_min ( int ) \u2013 Minimum number of bins for cumulative distribution function (CDF)-based random sampling. cdf_bins_max ( Optional [ int ] ) \u2013 Maximum number of bins for CDF-based sampling. randomized_interpolation_angle ( bool ) \u2013 Whether to use randomized interpolation for angular motion. randomized_interpolation_position ( bool ) \u2013 Whether to use randomized interpolation for positional motion. interpolation_method ( str ) \u2013 Interpolation method to be used (default: \"cosine\"). range_of_motion_hinge ( bool ) \u2013 Whether to enforce range-of-motion constraints on hinge joints. range_of_motion_hinge_method ( str ) \u2013 Method used for range-of-motion enforcement (e.g., \"uniform\", \"sigmoid\"). rom_halfsize ( float | TimeDependentFloat ) \u2013 Half-size of the range of motion restriction. ang0_min ( float ) \u2013 Minimum initial joint angle. ang0_max ( float ) \u2013 Maximum initial joint angle. pos0_min ( float ) \u2013 Minimum initial joint position. pos0_max ( float ) \u2013 Maximum initial joint position. cor_t_min ( float ) \u2013 Minimum time step for center-of-rotation (COR) joints. cor_t_max ( float | TimeDependentFloat ) \u2013 Maximum time step for COR joints. cor_dpos_min ( float | TimeDependentFloat ) \u2013 Minimum velocity for COR translation. cor_dpos_max ( float | TimeDependentFloat ) \u2013 Maximum velocity for COR translation. cor_pos_min ( float | TimeDependentFloat ) \u2013 Minimum position for COR translation. cor_pos_max ( float | TimeDependentFloat ) \u2013 Maximum position for COR translation. cor_pos0_min ( float ) \u2013 Initial minimum position for COR translation. cor_pos0_max ( float ) \u2013 Initial maximum position for COR translation. joint_type_specific_overwrites ( dict [ str , dict [ str , Any ]] ) \u2013 A dictionary mapping joint types to specific motion configuration overrides. Methods: Name Description is_feasible Checks if the motion configuration satisfies all constraints. to_nomotion_config Returns a new MotionConfig where all velocities and angle changes are set to zero. overwrite_for_joint_type str, **changes) -> None: Applies specific configuration changes for a given joint type. Note: These changes affect all instances of MotionConfig for this joint type. overwrite_for_subsystem base.System, link_name: str, **changes) -> base.System: Modifies the motion configuration for all joints in a subsystem rooted at link_name . from_register str) -> \"MotionConfig\": Retrieves a predefined MotionConfig from the global registry. Source code in src/ring/algorithms/jcalc.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 @dataclass class MotionConfig : \"\"\" Configuration for joint motion generation in kinematic and dynamic simulations. This class defines the constraints and parameters for generating random joint motions, including angular and positional velocity limits, interpolation methods, and range restrictions for various joint types. Attributes: T (float): Total duration of the motion sequence (in seconds). t_min (float): Minimum time interval between two generated joint states. t_max (float | TimeDependentFloat): Maximum time interval between two generated joint states. dang_min (float | TimeDependentFloat): Minimum angular velocity (rad/s). dang_max (float | TimeDependentFloat): Maximum angular velocity (rad/s). dang_min_free_spherical (float | TimeDependentFloat): Minimum angular velocity for free and spherical joints. dang_max_free_spherical (float | TimeDependentFloat): Maximum angular velocity for free and spherical joints. delta_ang_min (float | TimeDependentFloat): Minimum allowed change in joint angle (radians). delta_ang_max (float | TimeDependentFloat): Maximum allowed change in joint angle (radians). delta_ang_min_free_spherical (float | TimeDependentFloat): Minimum allowed change in angle for free/spherical joints. delta_ang_max_free_spherical (float | TimeDependentFloat): Maximum allowed change in angle for free/spherical joints. dpos_min (float | TimeDependentFloat): Minimum translational velocity. dpos_max (float | TimeDependentFloat): Maximum translational velocity. pos_min (float | TimeDependentFloat): Minimum position constraint. pos_max (float | TimeDependentFloat): Maximum position constraint. pos_min_p3d_x (float | TimeDependentFloat): Minimum position in x-direction for P3D joints. pos_max_p3d_x (float | TimeDependentFloat): Maximum position in x-direction for P3D joints. pos_min_p3d_y (float | TimeDependentFloat): Minimum position in y-direction for P3D joints. pos_max_p3d_y (float | TimeDependentFloat): Maximum position in y-direction for P3D joints. pos_min_p3d_z (float | TimeDependentFloat): Minimum position in z-direction for P3D joints. pos_max_p3d_z (float | TimeDependentFloat): Maximum position in z-direction for P3D joints. cdf_bins_min (int): Minimum number of bins for cumulative distribution function (CDF)-based random sampling. cdf_bins_max (Optional[int]): Maximum number of bins for CDF-based sampling. randomized_interpolation_angle (bool): Whether to use randomized interpolation for angular motion. randomized_interpolation_position (bool): Whether to use randomized interpolation for positional motion. interpolation_method (str): Interpolation method to be used (default: \"cosine\"). range_of_motion_hinge (bool): Whether to enforce range-of-motion constraints on hinge joints. range_of_motion_hinge_method (str): Method used for range-of-motion enforcement (e.g., \"uniform\", \"sigmoid\"). rom_halfsize (float | TimeDependentFloat): Half-size of the range of motion restriction. ang0_min (float): Minimum initial joint angle. ang0_max (float): Maximum initial joint angle. pos0_min (float): Minimum initial joint position. pos0_max (float): Maximum initial joint position. cor_t_min (float): Minimum time step for center-of-rotation (COR) joints. cor_t_max (float | TimeDependentFloat): Maximum time step for COR joints. cor_dpos_min (float | TimeDependentFloat): Minimum velocity for COR translation. cor_dpos_max (float | TimeDependentFloat): Maximum velocity for COR translation. cor_pos_min (float | TimeDependentFloat): Minimum position for COR translation. cor_pos_max (float | TimeDependentFloat): Maximum position for COR translation. cor_pos0_min (float): Initial minimum position for COR translation. cor_pos0_max (float): Initial maximum position for COR translation. joint_type_specific_overwrites (dict[str, dict[str, Any]]): A dictionary mapping joint types to specific motion configuration overrides. Methods: is_feasible() -> bool: Checks if the motion configuration satisfies all constraints. to_nomotion_config() -> MotionConfig: Returns a new `MotionConfig` where all velocities and angle changes are set to zero. overwrite_for_joint_type(joint_type: str, **changes) -> None: Applies specific configuration changes for a given joint type. Note: These changes affect all instances of `MotionConfig` for this joint type. overwrite_for_subsystem(sys: base.System, link_name: str, **changes) -> base.System: Modifies the motion configuration for all joints in a subsystem rooted at `link_name`. from_register(name: str) -> \"MotionConfig\": Retrieves a predefined `MotionConfig` from the global registry. \"\"\" # noqa: E501 T : float = 60.0 # length of random motion t_min : float = 0.05 # min time between two generated angles t_max : float | TimeDependentFloat = 0.30 # max time .. dang_min : float | TimeDependentFloat = 0.1 # minimum angular velocity in rad/s dang_max : float | TimeDependentFloat = 3.0 # maximum angular velocity in rad/s # minimum angular velocity of euler angles used for `free and spherical joints` dang_min_free_spherical : float | TimeDependentFloat = 0.1 dang_max_free_spherical : float | TimeDependentFloat = 3.0 # max min allowed actual delta values in radians delta_ang_min : float | TimeDependentFloat = 0.0 delta_ang_max : float | TimeDependentFloat = 2 * jnp . pi delta_ang_min_free_spherical : float | TimeDependentFloat = 0.0 delta_ang_max_free_spherical : float | TimeDependentFloat = 2 * jnp . pi dpos_min : float | TimeDependentFloat = 0.001 # speed of translation dpos_max : float | TimeDependentFloat = 0.7 pos_min : float | TimeDependentFloat = - 2.5 pos_max : float | TimeDependentFloat = + 2.5 pos_min_p3d_x : float | TimeDependentFloat = - 2.5 pos_max_p3d_x : float | TimeDependentFloat = + 2.5 pos_min_p3d_y : float | TimeDependentFloat = - 2.5 pos_max_p3d_y : float | TimeDependentFloat = + 2.5 pos_min_p3d_z : float | TimeDependentFloat = - 2.5 pos_max_p3d_z : float | TimeDependentFloat = + 2.5 # used by both `random_angle_*` and `random_pos_*` # only used if `randomized_interpolation` is set cdf_bins_min : int = 5 # by default equal to `cdf_bins_min` cdf_bins_max : Optional [ int ] = None # flags randomized_interpolation_angle : bool = False randomized_interpolation_position : bool = False interpolation_method : str = \"cosine\" range_of_motion_hinge : bool = True range_of_motion_hinge_method : str = \"uniform\" # this value has nothing to do with `range_of_motion` flag # this forces the value to stay within [ANG_0 - rom_halfsize, ANG_0 + rom_halfsize] # used only by the `_draw_rxyz` function rom_halfsize : float | TimeDependentFloat = 2 * jnp . pi # initial value of joints ang0_min : float = - jnp . pi ang0_max : float = jnp . pi pos0_min : float = 0.0 pos0_max : float = 0.0 pos0_min_p3d_x : float = 0.0 pos0_max_p3d_x : float = 0.0 pos0_min_p3d_y : float = 0.0 pos0_max_p3d_y : float = 0.0 pos0_min_p3d_z : float = 0.0 pos0_max_p3d_z : float = 0.0 # cor (center of rotation) custom fields cor_t_min : float = 0.2 cor_t_max : float | TimeDependentFloat = 2.0 cor_dpos_min : float | TimeDependentFloat = 0.00001 cor_dpos_max : float | TimeDependentFloat = 0.5 cor_pos_min : float | TimeDependentFloat = - 0.4 cor_pos_max : float | TimeDependentFloat = 0.4 cor_pos0_min : float = 0.0 cor_pos0_max : float = 0.0 # specify changes for this motionconfig and for specific joint types # map of `link_types` -> dictionary of changes joint_type_specific_overwrites : dict [ str , dict [ str , Any ]] = field ( default_factory = lambda : dict () ) def is_feasible ( self ) -> bool : return _is_feasible_config1 ( self ) def to_nomotion_config ( self ) -> \"MotionConfig\" : kwargs = asdict ( self ) for key in [ \"dang_min\" , \"dang_max\" , \"delta_ang_min\" , \"dang_min_free_spherical\" , \"dang_max_free_spherical\" , \"delta_ang_min_free_spherical\" , \"dpos_min\" , \"dpos_max\" , ]: kwargs [ key ] = 0.0 nomotion_config = MotionConfig ( ** kwargs ) assert nomotion_config . is_feasible () return nomotion_config @staticmethod def overwrite_for_joint_type ( joint_type : str , ** changes ) -> None : \"\"\"Changes values of the `MotionConfig` used by the draw_fn for only a specific joint. !!! Note This applies these changes to *all* MotionConfigs for this joint type! This takes precedence *over* `Motionconfig.joint_type_specific_overwrites`! \"\"\" previous_changes = _overwrite_for_joint_type_changes [ joint_type ] for change in changes : assert change not in previous_changes , f \"For jointtype= { joint_type } you \" f \"previously changed the value= { change } . You can't change it again, this \" \"is not supported.\" previous_changes . update ( changes ) jm = get_joint_model ( joint_type ) def draw_fn ( config , * args ): return jm . rcmg_draw_fn ( replace ( config , ** changes ), * args ) register_new_joint_type ( joint_type , replace ( jm , rcmg_draw_fn = draw_fn ), base . Q_WIDTHS [ joint_type ], base . QD_WIDTHS [ joint_type ], overwrite = True , ) @staticmethod def overwrite_for_subsystem ( sys : base . System , link_name : str , ** changes ) -> base . System : \"\"\"Modifies motionconfig of all joints in subsystem with root `link_name`. Note that if the subsystem contains a free joint then the jointtype will will be re-named to `free_<link_name>`, then the RCMG flag `cor` will potentially not work as expected because it searches for all joints of type `free` to replace with `cor`. The workaround here is to change the type already from `free` to `cor in the xml file. This takes precedence *over* `Motionconfig.joint_type_specific_overwrites`! Args: sys (base.System): System object that gets updated link_name (str): Root node of subsystem changes: Changes to apply to the motionconfig Return: base.System: Updated system with new jointtypes \"\"\" from ring.algorithms.generator.finalize_fns import _P_gains # all bodies in the subsystem bodies = sys . findall_bodies_subsystem ( link_name ) + [ sys . name_to_idx ( link_name )] jts_subsys = set ([ sys . link_types [ i ] for i in bodies ]) - set ([ \"frozen\" ]) postfix = \"_\" + link_name # create new joint types with updated motionconfig for typ in jts_subsys : register_new_joint_type ( typ + postfix , get_joint_model ( typ ), base . Q_WIDTHS [ typ ], base . QD_WIDTHS [ typ ], ) MotionConfig . overwrite_for_joint_type ( typ + postfix , ** changes ) _P_gains [ typ + postfix ] = _P_gains [ typ ] # rename all jointtypes new_link_types = [ ( sys . link_types [ i ] + postfix if ( i in bodies and sys . link_types [ i ] != \"frozen\" ) else sys . link_types [ i ] ) for i in range ( sys . num_links ()) ] sys = sys . replace ( link_types = new_link_types ) return sys @staticmethod def from_register ( name : str ) -> \"MotionConfig\" : return _registered_motion_configs [ name ] overwrite_for_joint_type ( joint_type , ** changes ) staticmethod \u00a4 Changes values of the MotionConfig used by the draw_fn for only a specific joint. Note This applies these changes to all MotionConfigs for this joint type! This takes precedence over Motionconfig.joint_type_specific_overwrites ! Source code in src/ring/algorithms/jcalc.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 @staticmethod def overwrite_for_joint_type ( joint_type : str , ** changes ) -> None : \"\"\"Changes values of the `MotionConfig` used by the draw_fn for only a specific joint. !!! Note This applies these changes to *all* MotionConfigs for this joint type! This takes precedence *over* `Motionconfig.joint_type_specific_overwrites`! \"\"\" previous_changes = _overwrite_for_joint_type_changes [ joint_type ] for change in changes : assert change not in previous_changes , f \"For jointtype= { joint_type } you \" f \"previously changed the value= { change } . You can't change it again, this \" \"is not supported.\" previous_changes . update ( changes ) jm = get_joint_model ( joint_type ) def draw_fn ( config , * args ): return jm . rcmg_draw_fn ( replace ( config , ** changes ), * args ) register_new_joint_type ( joint_type , replace ( jm , rcmg_draw_fn = draw_fn ), base . Q_WIDTHS [ joint_type ], base . QD_WIDTHS [ joint_type ], overwrite = True , ) overwrite_for_subsystem ( sys , link_name , ** changes ) staticmethod \u00a4 Modifies motionconfig of all joints in subsystem with root link_name . Note that if the subsystem contains a free joint then the jointtype will will be re-named to free_<link_name> , then the RCMG flag cor will potentially not work as expected because it searches for all joints of type free to replace with cor . The workaround here is to change the type already from free to cor in the xml file. This takes precedence *over* Motionconfig.joint_type_specific_overwrites`! Parameters: sys ( System ) \u2013 System object that gets updated link_name ( str ) \u2013 Root node of subsystem changes \u2013 Changes to apply to the motionconfig Return base.System: Updated system with new jointtypes Source code in src/ring/algorithms/jcalc.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 @staticmethod def overwrite_for_subsystem ( sys : base . System , link_name : str , ** changes ) -> base . System : \"\"\"Modifies motionconfig of all joints in subsystem with root `link_name`. Note that if the subsystem contains a free joint then the jointtype will will be re-named to `free_<link_name>`, then the RCMG flag `cor` will potentially not work as expected because it searches for all joints of type `free` to replace with `cor`. The workaround here is to change the type already from `free` to `cor in the xml file. This takes precedence *over* `Motionconfig.joint_type_specific_overwrites`! Args: sys (base.System): System object that gets updated link_name (str): Root node of subsystem changes: Changes to apply to the motionconfig Return: base.System: Updated system with new jointtypes \"\"\" from ring.algorithms.generator.finalize_fns import _P_gains # all bodies in the subsystem bodies = sys . findall_bodies_subsystem ( link_name ) + [ sys . name_to_idx ( link_name )] jts_subsys = set ([ sys . link_types [ i ] for i in bodies ]) - set ([ \"frozen\" ]) postfix = \"_\" + link_name # create new joint types with updated motionconfig for typ in jts_subsys : register_new_joint_type ( typ + postfix , get_joint_model ( typ ), base . Q_WIDTHS [ typ ], base . QD_WIDTHS [ typ ], ) MotionConfig . overwrite_for_joint_type ( typ + postfix , ** changes ) _P_gains [ typ + postfix ] = _P_gains [ typ ] # rename all jointtypes new_link_types = [ ( sys . link_types [ i ] + postfix if ( i in bodies and sys . link_types [ i ] != \"frozen\" ) else sys . link_types [ i ] ) for i in range ( sys . num_links ()) ] sys = sys . replace ( link_types = new_link_types ) return sys join_motionconfigs ( configs , boundaries ) \u00a4 Joins multiple MotionConfig objects in time, transitioning between them at specified boundaries. This function takes a list of MotionConfig instances and a corresponding list of boundary times, and constructs a new MotionConfig that varies in time according to the provided segments. Parameters: configs ( list [ MotionConfig ] ) \u2013 A list of MotionConfig objects to be joined. boundaries ( list [ float ] ) \u2013 A list of time values where transitions between configs occur. Must have one element less than configs , as each boundary defines the transition point between two consecutive configurations. Returns: MotionConfig ( MotionConfig ) \u2013 A new MotionConfig object where time-dependent fields transition based on the MotionConfig \u2013 specified boundaries. Raises: AssertionError \u2013 If the number of boundaries does not match len(configs) - 1 . AssertionError \u2013 If time-independent fields have differing values across configs . Notes Only fields that are time-dependent ( float | TimeDependentFloat ) will change over time. Time-independent fields must be the same in all configs , or an error is raised. Source code in src/ring/algorithms/jcalc.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 def join_motionconfigs ( configs : list [ MotionConfig ], boundaries : list [ float ] ) -> MotionConfig : \"\"\" Joins multiple `MotionConfig` objects in time, transitioning between them at specified boundaries. This function takes a list of `MotionConfig` instances and a corresponding list of boundary times, and constructs a new `MotionConfig` that varies in time according to the provided segments. Args: configs (list[MotionConfig]): A list of `MotionConfig` objects to be joined. boundaries (list[float]): A list of time values where transitions between `configs` occur. Must have one element less than `configs`, as each boundary defines the transition point between two consecutive configurations. Returns: MotionConfig: A new `MotionConfig` object where time-dependent fields transition based on the specified boundaries. Raises: AssertionError: If the number of boundaries does not match `len(configs) - 1`. AssertionError: If time-independent fields have differing values across `configs`. Notes: - Only fields that are time-dependent (`float | TimeDependentFloat`) will change over time. - Time-independent fields must be the same in all `configs`, or an error is raised. \"\"\" # noqa: E501 # to avoid a circular import due to `ring.utils.randomize_sys` importing `jcalc` from ring.utils import tree_equal assert len ( configs ) == ( len ( boundaries ) + 1 ), \"length of `boundaries` should be one less than length of `configs`\" boundaries = jnp . array ( boundaries , dtype = float ) def new_value ( field : str ): scalar_options = jnp . array ([ getattr ( c , field ) for c in configs ]) def scalar ( t ): return jax . lax . dynamic_index_in_dim ( scalar_options , _find_interval ( t , boundaries ), keepdims = False ) return scalar hints = get_type_hints ( MotionConfig ()) attrs = MotionConfig () . __dict__ is_time_dependent_field = lambda key : hints [ key ] == ( float | TimeDependentFloat ) time_dependent_fields = [ key for key in attrs if is_time_dependent_field ( key )] time_independent_fields = [ key for key in attrs if not is_time_dependent_field ( key )] for time_dep_field in time_independent_fields : try : field_values = set ([ getattr ( config , time_dep_field ) for config in configs ]) assert ( len ( field_values ) == 1 ), f \"MotionConfig. { time_dep_field } = { field_values } . \" \"Should be one unique value..\" except ( TypeError ): # dict is not hashable so test equality of all elements differently comparison_ele = getattr ( configs [ 0 ], time_dep_field ) for other_config in configs [ 1 :]: other_ele = getattr ( other_config , time_dep_field ) assert tree_equal ( comparison_ele , other_ele ), f \"MotionConfig. { time_dep_field } with { comparison_ele } != { other_ele } \" \" Should be one unique value..\" changes = { field : new_value ( field ) for field in time_dependent_fields } return replace ( configs [ 0 ], ** changes ) Extending the RCMG \u00a4 JointModel dataclass \u00a4 Represents the kinematic and dynamic properties of a joint type. A JointModel defines the mathematical functions required to compute joint transformations, motion, control terms, and inverse kinematics. It is used to describe the behavior of various joint types, including revolute, prismatic, spherical, and free joints. Attributes: transform ( Callable [[ Array , Array ], Transform ] ) \u2013 Computes the transformation (position and orientation) of the joint given the joint state q and joint parameters. motion ( list [ Motion | Callable [[ Array ], Motion ]] ) \u2013 Defines the joint motion model. It can be a list of Motion objects or callables that return Motion based on joint parameters. rcmg_draw_fn ( Optional [ DRAW_FN ] ) \u2013 Function used to generate a reference motion trajectory for the joint using Randomized Control Motion Generation (RCMG). p_control_term ( Optional [ P_CONTROL_TERM ] ) \u2013 Function that computes the proportional control term for the joint. qd_from_q ( Optional [ QD_FROM_Q ] ) \u2013 Function to compute joint velocity ( qd ) from joint positions ( q ). coordinate_vector_to_q ( Optional [ COORDINATE_VECTOR_TO_Q ] ) \u2013 Function that maps a coordinate vector to a valid joint state q , ensuring constraints (e.g., wrapping angles or normalizing quaternions). inv_kin ( Optional [ INV_KIN ] ) \u2013 Function that computes the inverse kinematics for the joint, mapping a desired transform to joint coordinates q . init_joint_params ( Optional [ INIT_JOINT_PARAMS ] ) \u2013 Function that initializes joint-specific parameters. utilities ( Optional [ dict [ str , Any ]] ) \u2013 Additional utility functions or metadata related to the joint model. Notes The transform function is essential for computing the joint's spatial transformation based on its generalized coordinates. The motion attribute describes how forces and torques affect the joint. The rcmg_draw_fn is used for RCMG motion generation. The coordinate_vector_to_q is critical for maintaining valid joint states. Source code in src/ring/algorithms/jcalc.py 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 @dataclass class JointModel : \"\"\" Represents the kinematic and dynamic properties of a joint type. A `JointModel` defines the mathematical functions required to compute joint transformations, motion, control terms, and inverse kinematics. It is used to describe the behavior of various joint types, including revolute, prismatic, spherical, and free joints. Attributes: transform (Callable[[jax.Array, jax.Array], base.Transform]): Computes the transformation (position and orientation) of the joint given the joint state `q` and joint parameters. motion (list[base.Motion | Callable[[jax.Array], base.Motion]]): Defines the joint motion model. It can be a list of `Motion` objects or callables that return `Motion` based on joint parameters. rcmg_draw_fn (Optional[DRAW_FN]): Function used to generate a reference motion trajectory for the joint using Randomized Control Motion Generation (RCMG). p_control_term (Optional[P_CONTROL_TERM]): Function that computes the proportional control term for the joint. qd_from_q (Optional[QD_FROM_Q]): Function to compute joint velocity (`qd`) from joint positions (`q`). coordinate_vector_to_q (Optional[COORDINATE_VECTOR_TO_Q]): Function that maps a coordinate vector to a valid joint state `q`, ensuring constraints (e.g., wrapping angles or normalizing quaternions). inv_kin (Optional[INV_KIN]): Function that computes the inverse kinematics for the joint, mapping a desired transform to joint coordinates `q`. init_joint_params (Optional[INIT_JOINT_PARAMS]): Function that initializes joint-specific parameters. utilities (Optional[dict[str, Any]]): Additional utility functions or metadata related to the joint model. Notes: - The `transform` function is essential for computing the joint's spatial transformation based on its generalized coordinates. - The `motion` attribute describes how forces and torques affect the joint. - The `rcmg_draw_fn` is used for RCMG motion generation. - The `coordinate_vector_to_q` is critical for maintaining valid joint states. \"\"\" # noqa: E501 # (q, params) -> Transform transform : Callable [[ jax . Array , jax . Array ], base . Transform ] # len(motion) == len(qd) # if callable: joint_params -> base.Motion motion : list [ base . Motion | Callable [[ jax . Array ], base . Motion ]] = field ( default_factory = lambda : [] ) # (config, key_t, key_value, params) -> jax.Array rcmg_draw_fn : Optional [ DRAW_FN ] = None # only used by `pd_control` p_control_term : Optional [ P_CONTROL_TERM ] = None qd_from_q : Optional [ QD_FROM_Q ] = None # used by # -`inverse_kinematics_endeffector` # - System.coordinate_vector_to_q coordinate_vector_to_q : Optional [ COORDINATE_VECTOR_TO_Q ] = None # only used by `inverse_kinematics` inv_kin : Optional [ INV_KIN ] = None init_joint_params : Optional [ INIT_JOINT_PARAMS ] = None utilities : Optional [ dict [ str , Any ]] = field ( default_factory = lambda : dict ()) register_new_joint_type ( joint_type , joint_model , q_width , qd_width = None , overwrite = False ) \u00a4 Source code in src/ring/algorithms/jcalc.py 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 def register_new_joint_type ( joint_type : str , joint_model : JointModel , q_width : int , qd_width : Optional [ int ] = None , overwrite : bool = False , ): # this name is used assert joint_type != \"default\" , \"Please use another name.\" exists = joint_type in _joint_types if exists and overwrite : for dic in [ base . Q_WIDTHS , base . QD_WIDTHS , _joint_types , ]: dic . pop ( joint_type ) else : assert ( not exists ), f \"joint type ` { joint_type } `already exists, use `overwrite=True`\" if qd_width is None : qd_width = q_width assert len ( joint_model . motion ) == qd_width _joint_types . update ({ joint_type : joint_model }) base . Q_WIDTHS . update ({ joint_type : q_width }) base . QD_WIDTHS . update ({ joint_type : qd_width }) Simulation \u00a4 State \u00a4 The static and dynamic state of a system in minimal and maximal coordinates. Use .create() to create this object. Parameters: q ( Array ) \u2013 System state in minimal coordinates (equals sys.q_size() ) qd ( Array ) \u2013 System velocity in minimal coordinates (equals sys.qd_size() ) x \u2013 (Transform): Maximal coordinates of all links. From epsilon-to-link. Source code in src/ring/base.py 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 @struct . dataclass class State ( _Base ): \"\"\"The static and dynamic state of a system in minimal and maximal coordinates. Use `.create()` to create this object. Args: q (jax.Array): System state in minimal coordinates (equals `sys.q_size()`) qd (jax.Array): System velocity in minimal coordinates (equals `sys.qd_size()`) x: (Transform): Maximal coordinates of all links. From epsilon-to-link. \"\"\" q : jax . Array qd : jax . Array x : Transform @classmethod def create ( cls , sys : System , q : Optional [ jax . Array ] = None , qd : Optional [ jax . Array ] = None , x : Optional [ Transform ] = None , key : Optional [ jax . Array ] = None , custom_joints : dict [ str , Callable ] = {}, ): \"\"\"Create state of system. Args: sys (System): The system for which to create a state. q (jax.Array, optional): The joint values of the system. Defaults to None. Which then defaults to zeros. qd (jax.Array, optional): The joint velocities of the system. Defaults to None. Which then defaults to zeros. Returns: (State): Create State object. \"\"\" if key is not None : assert q is None q = jax . random . normal ( key , shape = ( sys . q_size (),)) q = sys . coordinate_vector_to_q ( q , custom_joints ) elif q is None : q = jnp . zeros (( sys . q_size (),)) # free, cor, spherical joints are not zeros but have unit quaternions def replace_by_unit_quat ( _ , idx_map , link_typ , link_idx ): nonlocal q if sys . joint_type_is_free_or_cor_or_spherical ( link_typ ): q_idxs_link = idx_map [ \"q\" ]( link_idx ) q = q . at [ q_idxs_link . start ] . set ( 1.0 ) sys . scan ( replace_by_unit_quat , \"ll\" , sys . link_types , list ( range ( sys . num_links ())), ) else : pass if qd is None : qd = jnp . zeros (( sys . qd_size (),)) if x is None : x = Transform . zero (( sys . num_links (),)) return cls ( q , qd , x ) create ( sys , q = None , qd = None , x = None , key = None , custom_joints = {}) classmethod \u00a4 Create state of system. Parameters: sys ( System ) \u2013 The system for which to create a state. q ( Array , default: None ) \u2013 The joint values of the system. Defaults to None. qd ( Array , default: None ) \u2013 The joint velocities of the system. Returns: State \u2013 Create State object. Source code in src/ring/base.py 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 @classmethod def create ( cls , sys : System , q : Optional [ jax . Array ] = None , qd : Optional [ jax . Array ] = None , x : Optional [ Transform ] = None , key : Optional [ jax . Array ] = None , custom_joints : dict [ str , Callable ] = {}, ): \"\"\"Create state of system. Args: sys (System): The system for which to create a state. q (jax.Array, optional): The joint values of the system. Defaults to None. Which then defaults to zeros. qd (jax.Array, optional): The joint velocities of the system. Defaults to None. Which then defaults to zeros. Returns: (State): Create State object. \"\"\" if key is not None : assert q is None q = jax . random . normal ( key , shape = ( sys . q_size (),)) q = sys . coordinate_vector_to_q ( q , custom_joints ) elif q is None : q = jnp . zeros (( sys . q_size (),)) # free, cor, spherical joints are not zeros but have unit quaternions def replace_by_unit_quat ( _ , idx_map , link_typ , link_idx ): nonlocal q if sys . joint_type_is_free_or_cor_or_spherical ( link_typ ): q_idxs_link = idx_map [ \"q\" ]( link_idx ) q = q . at [ q_idxs_link . start ] . set ( 1.0 ) sys . scan ( replace_by_unit_quat , \"ll\" , sys . link_types , list ( range ( sys . num_links ())), ) else : pass if qd is None : qd = jnp . zeros (( sys . qd_size (),)) if x is None : x = Transform . zero (( sys . num_links (),)) return cls ( q , qd , x ) step ( sys , state , taus = None , n_substeps = 1 ) \u00a4 Steps the dynamics. Returns the state of next timestep. Source code in src/ring/algorithms/dynamics.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 def step ( sys : base . System , state : base . State , taus : Optional [ jax . Array ] = None , n_substeps : int = 1 , ) -> base . State : \"Steps the dynamics. Returns the state of next timestep.\" assert sys . q_size () == state . q . size if taus is None : taus = jnp . zeros_like ( state . qd ) assert sys . qd_size () == state . qd . size == taus . size assert ( sys . integration_method . lower () == \"semi_implicit_euler\" ), \"Currently, nothing else then `semi_implicit_euler` implemented.\" sys = sys . replace ( dt = sys . dt / n_substeps ) for _ in range ( n_substeps ): # update kinematics before stepping; this means that the `x` in `state` # will lag one step behind but otherwise we would have to return # the system object which would be awkward sys , state = kinematics . forward_kinematics ( sys , state ) state = _integration_methods [ sys . integration_method . lower ()]( sys , state , taus ) return state Transform \u00a4 Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B, where B is located relative to A at pos in frame A and rot is the relative quaternion from A to B. Create using `Transform.create(pos=..., rot=...) Source code in src/ring/base.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @struct . dataclass class Transform ( _Base ): \"\"\"Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B, where B is located relative to A at `pos` in frame A and `rot` is the relative quaternion from A to B. Create using `Transform.create(pos=..., rot=...) \"\"\" pos : Vector rot : Quaternion @classmethod def create ( cls , pos = None , rot = None ): assert not ( pos is None and rot is None ), \"One must be given.\" shape_rot = rot . shape [: - 1 ] if rot is not None else () shape_pos = pos . shape [: - 1 ] if pos is not None else () if pos is None : pos = jnp . zeros ( shape_rot + ( 3 ,)) if rot is None : rot = jnp . array ([ 1.0 , 0 , 0 , 0 ]) rot = jnp . tile ( jnp . array ([ 1.0 , 0.0 , 0.0 , 0.0 ]), shape_pos + ( 1 ,)) assert pos . shape [: - 1 ] == rot . shape [: - 1 ] return Transform ( pos , rot ) @classmethod def zero ( cls , shape = ()) -> \"Transform\" : \"\"\"Returns a zero transform with a batch shape.\"\"\" pos = jnp . zeros ( shape + ( 3 ,)) rot = jnp . tile ( jnp . array ([ 1.0 , 0.0 , 0.0 , 0.0 ]), shape + ( 1 ,)) return Transform ( pos , rot ) def as_matrix ( self ) -> jax . Array : E = maths . quat_to_3x3 ( self . rot ) return spatial . quadrants ( aa = E , bb = E ) @ spatial . xlt ( self . pos ) zero ( shape = ()) classmethod \u00a4 Returns a zero transform with a batch shape. Source code in src/ring/base.py 140 141 142 143 144 145 @classmethod def zero ( cls , shape = ()) -> \"Transform\" : \"\"\"Returns a zero transform with a batch shape.\"\"\" pos = jnp . zeros ( shape + ( 3 ,)) rot = jnp . tile ( jnp . array ([ 1.0 , 0.0 , 0.0 , 0.0 ]), shape + ( 1 ,)) return Transform ( pos , rot )","title":"ring"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#ring","text":"","title":"RING"},{"location":"api/#src.ring.RING","text":"Creates the RING network. Parameters: lam ( list [ int ] | None ) \u2013 parent array, if None must be given via ringnet.apply(..., lam=lam) Ts \u2013 sampling interval of IMU data; time delta in seconds Returns: AbstractFilter \u2013 ring.ml.AbstractFilter: An instantiation of ring.ml.ringnet.RING with trained parameters. Examples: >>> import ring >>> import numpy as np >>> >>> T : int = 30 # sequence length [s] >>> Ts : float = 0.01 # sampling interval [s] >>> B : int = 1 # batch size >>> lam : list [ int ] = [ 0 , 1 , 2 ] # parent array >>> N : int = len ( lam ) # number of bodies >>> T_i : int = int ( T / Ts ) # number of timesteps >>> >>> X = np . zeros (( B , T_i , N , 9 )) >>> # where X is structured as follows: >>> # X[..., :3] = acc >>> # X[..., 3:6] = gyr >>> # X[..., 6:9] = jointaxis >>> >>> # let's assume we have an IMU on each outer segment of the >>> # three-segment kinematic chain >>> X [:, :, 0 , : 3 ] = acc_segment1 >>> X [:, :, 2 , : 3 ] = acc_segment3 >>> X [:, :, 0 , 3 : 6 ] = gyr_segment1 >>> X [:, :, 2 , 3 : 6 ] = gyr_segment3 >>> >>> ringnet = ring . RING ( lam , Ts ) >>> >>> yhat , _ = ringnet . apply ( X ) >>> # yhat : unit quaternions, shape = (B, T_i, N, 4) >>> # yhat[b, :, i] is the orientation from body `i` to parent body `lam[i]` >>> >>> # use `jax.jit` to compile the forward pass >>> jit_apply = jax . jit ( ringnet . apply ) >>> yhat , _ = jit_apply ( X ) >>> >>> # manually pass in and out the hidden state like so >>> initial_state = None >>> yhat , state = ringnet . apply ( X , state = initial_state ) >>> # state: final hidden state, shape = (B, N, 2*H) Source code in src/ring/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def RING ( lam : list [ int ] | None , Ts : float | None , ** kwargs ) -> ml . AbstractFilter : \"\"\"Creates the RING network. Params: lam: parent array, if `None` must be given via `ringnet.apply(..., lam=lam)` Ts : sampling interval of IMU data; time delta in seconds Returns: ring.ml.AbstractFilter: An instantiation of `ring.ml.ringnet.RING` with trained parameters. Examples: >>> import ring >>> import numpy as np >>> >>> T : int = 30 # sequence length [s] >>> Ts : float = 0.01 # sampling interval [s] >>> B : int = 1 # batch size >>> lam: list[int] = [0, 1, 2] # parent array >>> N : int = len(lam) # number of bodies >>> T_i: int = int(T/Ts) # number of timesteps >>> >>> X = np.zeros((B, T_i, N, 9)) >>> # where X is structured as follows: >>> # X[..., :3] = acc >>> # X[..., 3:6] = gyr >>> # X[..., 6:9] = jointaxis >>> >>> # let's assume we have an IMU on each outer segment of the >>> # three-segment kinematic chain >>> X[:, :, 0, :3] = acc_segment1 >>> X[:, :, 2, :3] = acc_segment3 >>> X[:, :, 0, 3:6] = gyr_segment1 >>> X[:, :, 2, 3:6] = gyr_segment3 >>> >>> ringnet = ring.RING(lam, Ts) >>> >>> yhat, _ = ringnet.apply(X) >>> # yhat : unit quaternions, shape = (B, T_i, N, 4) >>> # yhat[b, :, i] is the orientation from body `i` to parent body `lam[i]` >>> >>> # use `jax.jit` to compile the forward pass >>> jit_apply = jax.jit(ringnet.apply) >>> yhat, _ = jit_apply(X) >>> >>> # manually pass in and out the hidden state like so >>> initial_state = None >>> yhat, state = ringnet.apply(X, state=initial_state) >>> # state: final hidden state, shape = (B, N, 2*H) \"\"\" from pathlib import Path import warnings config = dict ( use_100Hz_RING = True , use_lpf = True , lpf_cutoff_freq = ml . _LPF_CUTOFF_FREQ , ) config . update ( kwargs ) if Ts is not None and ( Ts > ( 1 / 40 ) or Ts < ( 1 / 200 )): warnings . warn ( \"RING was only trained on sampling rates between 40 to 200 Hz \" f \"but found { 1 / Ts } Hz\" ) if Ts is not None and Ts == 0.01 and config [ \"use_100Hz_RING\" ]: # this set of parameters was trained exclusively on 100Hz data; it also # expects F=9 features per node and not F=10 where the last features is # the sampling interval Ts params = Path ( __file__ ) . parent . joinpath ( \"ml/params/0x1d76628065a71e0f.pickle\" ) add_Ts = False else : # this set of parameters was trained on sampling rates from 40 to 200 Hz params = Path ( __file__ ) . parent . joinpath ( \"ml/params/0x13e3518065c21cd8.pickle\" ) add_Ts = True ringnet = ml . RING ( params = params , lam = None if lam is None else tuple ( lam ), jit = config . pop ( \"jit\" , False ), name = \"RING\" , ) ringnet = ml . base . ScaleX_FilterWrapper ( ringnet ) if config [ \"use_lpf\" ]: ringnet = ml . base . LPF_FilterWrapper ( ringnet , config [ \"lpf_cutoff_freq\" ], samp_freq = None if Ts is None else 1 / Ts , quiet = True , ) ringnet = ml . base . GroundTruthHeading_FilterWrapper ( ringnet ) if add_Ts : ringnet = ml . base . AddTs_FilterWrapper ( ringnet , Ts ) return ringnet","title":"RING"},{"location":"api/#src.ring.ml.ringnet.RING","text":"Source code in src/ring/ml/ringnet.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class RING ( ml_base . AbstractFilter ): def __init__ ( self , params = None , lam = None , jit : bool = True , name = None , forward_factory = make_ring , ** kwargs , ): \"Untrained RING network\" self . forward_lam_factory = partial ( forward_factory , ** kwargs ) self . params = self . _load_params ( params ) self . lam = lam self . _name = name if jit : self . apply = jax . jit ( self . apply , static_argnames = \"lam\" ) def apply ( self , X , params = None , state = None , y = None , lam = None ): if lam is None : assert self . lam is not None lam = self . lam return super () . apply ( X , params , state , y , tuple ( lam )) def init ( self , bs : Optional [ int ] = None , X = None , lam = None , seed : int = 1 ): assert X is not None , \"Providing `X` via in `ringnet.init(X=X)` is required\" if bs is not None : assert X . ndim == 4 if X . ndim == 4 : if bs is not None : assert bs == X . shape [ 0 ] else : bs = X . shape [ 0 ] X = X [ 0 ] # (T, N, F) -> (1, N, F) for faster .init call X = X [ 0 : 1 ] if lam is None : assert self . lam is not None lam = self . lam key = jax . random . PRNGKey ( seed ) params , state = self . forward_lam_factory ( lam = lam ) . init ( key , X ) if bs is not None : state = jax . tree . map ( lambda arr : jnp . repeat ( arr [ None ], bs , axis = 0 ), state ) return params , state def _apply_batched ( self , X , params , state , y , lam ): if ( params is None and self . params is None ) or state is None : _params , _state = self . init ( bs = X . shape [ 0 ], X = X , lam = lam ) if params is None and self . params is None : params = _params elif params is None : params = self . params else : pass if state is None : state = _state yhat , next_state = jax . vmap ( self . forward_lam_factory ( lam = lam ) . apply , in_axes = ( None , 0 , 0 ) )( params , state , X ) return yhat , next_state @staticmethod def _load_params ( params : str | dict | None | Path ): assert isinstance ( params , ( str , dict , type ( None ), Path )) if isinstance ( params , ( Path , str )): return pickle_load ( params ) return params def nojit ( self ) -> \"RING\" : ringnet = RING ( params = self . params , lam = self . lam , jit = False ) ringnet . forward_lam_factory = self . forward_lam_factory return ringnet def _pre_save ( self , params = None , lam = None ) -> None : if params is not None : self . params = params if lam is not None : self . lam = lam @staticmethod def _post_load ( ringnet : \"RING\" , jit : bool = True ) -> \"RING\" : if jit : ringnet . apply = jax . jit ( ringnet . apply , static_argnames = \"lam\" ) return ringnet","title":"RING"},{"location":"api/#rcmg","text":"","title":"RCMG"},{"location":"api/#src.ring.algorithms.generator.base.RCMG","text":"Source code in src/ring/algorithms/generator/base.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 class RCMG : def __init__ ( self , sys : base . System | list [ base . System ], config : jcalc . MotionConfig | list [ jcalc . MotionConfig ] = jcalc . MotionConfig (), setup_fn : Optional [ types . SETUP_FN ] = None , finalize_fn : Optional [ types . FINALIZE_FN ] = None , add_X_imus : bool = False , add_X_imus_kwargs : dict = dict (), add_X_jointaxes : bool = False , add_X_jointaxes_kwargs : dict = dict (), add_y_relpose : bool = False , add_y_rootincl : bool = False , add_y_rootincl_kwargs : dict = dict (), add_y_rootfull : bool = False , add_y_rootfull_kwargs : dict = dict (), sys_ml : Optional [ base . System ] = None , randomize_positions : bool = False , randomize_motion_artifacts : bool = False , randomize_joint_params : bool = False , randomize_hz : bool = False , randomize_hz_kwargs : dict = dict (), imu_motion_artifacts : bool = False , imu_motion_artifacts_kwargs : dict = dict (), dynamic_simulation : bool = False , dynamic_simulation_kwargs : dict = dict (), output_transform : Optional [ Callable ] = None , keep_output_extras : bool = False , use_link_number_in_Xy : bool = False , cor : bool = False , disable_tqdm : bool = False , ) -> None : \"Random Chain Motion Generator\" # add some default values randomize_hz_kwargs_defaults = dict ( add_dt = True ) randomize_hz_kwargs_defaults . update ( randomize_hz_kwargs ) randomize_hz_kwargs = randomize_hz_kwargs_defaults sys , config = utils . to_list ( sys ), utils . to_list ( config ) sys_ml = sys [ 0 ] if sys_ml is None else sys_ml for c in config : assert c . is_feasible () self . gens = [] for _sys in sys : self . gens . append ( _build_mconfig_batched_generator ( sys = _sys , config = config , setup_fn = setup_fn , finalize_fn = finalize_fn , add_X_imus = add_X_imus , add_X_imus_kwargs = add_X_imus_kwargs , add_X_jointaxes = add_X_jointaxes , add_X_jointaxes_kwargs = add_X_jointaxes_kwargs , add_y_relpose = add_y_relpose , add_y_rootincl = add_y_rootincl , add_y_rootincl_kwargs = add_y_rootincl_kwargs , add_y_rootfull = add_y_rootfull , add_y_rootfull_kwargs = add_y_rootfull_kwargs , sys_ml = sys_ml , randomize_positions = randomize_positions , randomize_motion_artifacts = randomize_motion_artifacts , randomize_joint_params = randomize_joint_params , randomize_hz = randomize_hz , randomize_hz_kwargs = randomize_hz_kwargs , imu_motion_artifacts = imu_motion_artifacts , imu_motion_artifacts_kwargs = imu_motion_artifacts_kwargs , dynamic_simulation = dynamic_simulation , dynamic_simulation_kwargs = dynamic_simulation_kwargs , output_transform = output_transform , keep_output_extras = keep_output_extras , use_link_number_in_Xy = use_link_number_in_Xy , cor = cor , ) ) self . _n_mconfigs = len ( config ) self . _size_of_generators = [ self . _n_mconfigs ] * len ( self . gens ) self . _disable_tqdm = disable_tqdm def _compute_repeats ( self , sizes : int | list [ int ]) -> list [ int ]: \"how many times the generators are repeated to create a batch of `sizes`\" S , L = sum ( self . _size_of_generators ), len ( self . _size_of_generators ) def assert_size ( size : int ): assert self . _n_mconfigs in utils . primes ( size ), ( f \"`size`= { size } is not divisible by number of \" + f \"`mconfigs`= { self . _n_mconfigs } \" ) if isinstance ( sizes , int ): assert ( sizes // S ) > 0 , f \"Batchsize or size too small. { sizes } < { S } \" assert sizes % S == 0 , f \"`size`= { sizes } not divisible by { S } \" repeats = L * [ sizes // S ] else : for size in sizes : assert_size ( size ) assert len ( sizes ) == len ( self . gens ), f \"len(`sizes`)= { len ( sizes ) } != { len ( self . gens ) } \" repeats = [ size // size_of_gen for size , size_of_gen in zip ( sizes , self . _size_of_generators ) ] assert 0 not in repeats return repeats def to_lazy_gen ( self , sizes : int | list [ int ] = 1 , jit : bool = True ) -> types . BatchedGenerator : return batch . generators_lazy ( self . gens , self . _compute_repeats ( sizes ), jit ) @staticmethod def _number_of_executions_required ( size : int ) -> int : _ , vmap = utils . distribute_batchsize ( size ) eager_threshold = utils . batchsize_thresholds ()[ 1 ] primes = iter ( utils . primes ( vmap )) n_calls = 1 while vmap > eager_threshold : prime = next ( primes ) n_calls *= prime vmap /= prime return n_calls def _generators_ncalls ( self , sizes : int | list [ int ] = 1 ): \"Returns list of unbatched sequences as numpy arrays.\" repeats = self . _compute_repeats ( sizes ) sizes = list ( jnp . array ( repeats ) * jnp . array ( self . _size_of_generators )) reduced_repeats = [] n_calls = [] for size , repeat in zip ( sizes , repeats ): n_call = self . _number_of_executions_required ( size ) gcd = utils . gcd ( n_call , repeat ) n_calls . append ( gcd ) reduced_repeats . append ( repeat // gcd ) jits = [ N > 1 for N in n_calls ] gens = [] for i in range ( len ( repeats )): gens . append ( batch . generators_lazy ([ self . gens [ i ]], [ reduced_repeats [ i ]], jits [ i ]) ) return gens , n_calls def to_list ( self , sizes : int | list [ int ] = 1 , seed : int = 1 ) -> list [ tree_utils . PyTree [ np . ndarray ]]: \"Returns list of unbatched sequences as numpy arrays.\" gens , n_calls = self . _generators_ncalls ( sizes ) data = [] batch . generators_eager ( gens , n_calls , lambda d : data . extend ( d ), seed , self . _disable_tqdm ) return data def to_folder ( self , path : str , sizes : int | list [ int ] = 1 , seed : int = 1 , overwrite : bool = True , file_prefix : str = \"seq\" , save_fn : Callable [[ PyTree [ np . ndarray ], str ], None ] = partial ( utils . pickle_save , overwrite = True ), verbose : bool = True , ): i = 0 def callback ( data : list [ PyTree [ np . ndarray ]]) -> None : nonlocal i data = utils . replace_elements_w_nans ( data , verbose = verbose ) for d in data : file = utils . parse_path ( path , file_prefix + str ( i ), file_exists_ok = overwrite ) save_fn ( d , file ) i += 1 # cleanup del data gens , n_calls = self . _generators_ncalls ( sizes ) batch . generators_eager ( gens , n_calls , callback , seed , self . _disable_tqdm ) def to_pickle ( self , path : str , sizes : int | list [ int ] = 1 , seed : int = 1 , overwrite : bool = True , ) -> None : data = tree_utils . tree_batch ( self . to_list ( sizes , seed ), backend = \"numpy\" ) utils . pickle_save ( data , path , overwrite = overwrite ) def to_eager_gen ( self , batchsize : int = 1 , sizes : int | list [ int ] = 1 , seed : int = 1 , shuffle : bool = True , transform = None , ) -> types . BatchedGenerator : data = self . to_list ( sizes , seed ) assert len ( data ) >= batchsize return self . eager_gen_from_list ( data , batchsize , shuffle , transform ) @staticmethod def eager_gen_from_list ( data : list [ tree_utils . PyTree ], batchsize : int , shuffle : bool = True , transform = None , ) -> types . BatchedGenerator : data = data . copy () n_batches , i = len ( data ) // batchsize , 0 def generator ( key : jax . Array ): nonlocal i if shuffle and i == 0 : random . shuffle ( data ) start , stop = i * batchsize , ( i + 1 ) * batchsize batch = tree_utils . tree_batch ( data [ start : stop ], backend = \"numpy\" ) batch = utils . pytree_deepcopy ( batch ) if transform is not None : batch = transform ( batch ) i = ( i + 1 ) % n_batches return batch return generator","title":"RCMG"},{"location":"api/#system","text":"","title":"System"},{"location":"api/#src.ring.base.System","text":"System object. Create using System.create(path_xml) Source code in src/ring/base.py 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 @struct . dataclass class System ( _Base ): \"System object. Create using `System.create(path_xml)`\" link_parents : list [ int ] = struct . field ( False ) links : Link link_types : list [ str ] = struct . field ( False ) link_damping : jax . Array link_armature : jax . Array link_spring_stiffness : jax . Array link_spring_zeropoint : jax . Array # simulation timestep size dt : float = struct . field ( False ) # geometries in the system geoms : list [ Geometry ] # root / base acceleration offset gravity : jax . Array = struct . field ( default_factory = lambda : jnp . array ([ 0 , 0 , - 9.81 ])) integration_method : str = struct . field ( False , default_factory = lambda : \"semi_implicit_euler\" ) mass_mat_iters : int = struct . field ( False , default_factory = lambda : 0 ) link_names : list [ str ] = struct . field ( False , default_factory = lambda : []) model_name : Optional [ str ] = struct . field ( False , default_factory = lambda : None ) omc : list [ MaxCoordOMC | None ] = struct . field ( True , default_factory = lambda : []) def num_links ( self ) -> int : return len ( self . link_parents ) def q_size ( self ) -> int : return sum ([ Q_WIDTHS [ typ ] for typ in self . link_types ]) def qd_size ( self ) -> int : return sum ([ QD_WIDTHS [ typ ] for typ in self . link_types ]) def name_to_idx ( self , name : str ) -> int : return self . link_names . index ( name ) def idx_to_name ( self , idx : int , allow_world : bool = False ) -> str : if allow_world and idx == - 1 : return \"world\" assert idx >= 0 , \"Worldbody index has no name.\" return self . link_names [ idx ] def idx_map ( self , type : str ) -> dict : \"type: is either `l` or `q` or `d`\" dict_int_slices = {} def f ( _ , idx_map , name : str , link_idx : int ): dict_int_slices [ name ] = idx_map [ type ]( link_idx ) self . scan ( f , \"ll\" , self . link_names , list ( range ( self . num_links ()))) return dict_int_slices def parent_name ( self , name : str ) -> str : return self . idx_to_name ( self . link_parents [ self . name_to_idx ( name )]) def add_prefix ( self , prefix : str = \"\" ) -> \"System\" : return self . replace ( link_names = [ prefix + name for name in self . link_names ]) def change_model_name ( self , new_name : Optional [ str ] = None , prefix : Optional [ str ] = None , suffix : Optional [ str ] = None , ) -> \"System\" : if prefix is None : prefix = \"\" if suffix is None : suffix = \"\" if new_name is None : new_name = self . model_name name = prefix + new_name + suffix return self . replace ( model_name = name ) def change_link_name ( self , old_name : str , new_name : str ) -> \"System\" : old_idx = self . name_to_idx ( old_name ) new_link_names = self . link_names . copy () new_link_names [ old_idx ] = new_name return self . replace ( link_names = new_link_names ) def add_prefix_suffix ( self , prefix : Optional [ str ] = None , suffix : Optional [ str ] = None ) -> \"System\" : if prefix is None : prefix = \"\" if suffix is None : suffix = \"\" new_link_names = [ prefix + name + suffix for name in self . link_names ] return self . replace ( link_names = new_link_names ) def _replace_free_with_cor ( self ) -> \"System\" : # check that # - all free joints connect to -1 # - all joints connecting to -1 are free joints for i , p in enumerate ( self . link_parents ): link_type = self . link_types [ i ] if ( p == - 1 and link_type != \"free\" ) or ( link_type == \"free\" and p != - 1 ): raise InvalidSystemError ( f \"link= { self . idx_to_name ( i ) } , parent=\" f \" { self . idx_to_name ( p , allow_world = True ) } ,\" f \" joint= { link_type } . Hint: Try setting `config.cor` to false.\" ) def logic_replace_free_with_cor ( name , olt , ola , old , ols , olz ): # by default new is equal to old nlt , nla , nld , nls , nlz = olt , ola , old , ols , olz # old link type == free if olt == \"free\" : # cor joint is (free, p3d) stacked nlt = \"cor\" # entries of old armature are 3*ang (spherical), 3*pos (p3d) nla = jnp . concatenate (( ola , ola [ 3 :])) nld = jnp . concatenate (( old , old [ 3 :])) nls = jnp . concatenate (( ols , ols [ 3 :])) nlz = jnp . concatenate (( olz , olz [ 4 :])) return nlt , nla , nld , nls , nlz return _update_sys_if_replace_joint_type ( self , logic_replace_free_with_cor ) def freeze ( self , name : str | list [ str ]): if isinstance ( name , list ): sys = self for n in name : sys = sys . freeze ( n ) return sys def logic_freeze ( link_name , olt , ola , old , ols , olz ): nlt , nla , nld , nls , nlz = olt , ola , old , ols , olz if link_name == name : nlt = \"frozen\" nla = nld = nls = nlz = jnp . array ([]) return nlt , nla , nld , nls , nlz return _update_sys_if_replace_joint_type ( self , logic_freeze ) def unfreeze ( self , name : str , new_joint_type : str ): assert self . link_types [ self . name_to_idx ( name )] == \"frozen\" assert new_joint_type != \"frozen\" return self . change_joint_type ( name , new_joint_type ) def change_joint_type ( self , name : str , new_joint_type : str , new_arma : Optional [ jax . Array ] = None , new_damp : Optional [ jax . Array ] = None , new_stif : Optional [ jax . Array ] = None , new_zero : Optional [ jax . Array ] = None , seed : int = 1 , warn : bool = True , ): \"By default damping, stiffness are set to zero.\" from ring.algorithms import get_joint_model q_size , qd_size = Q_WIDTHS [ new_joint_type ], QD_WIDTHS [ new_joint_type ] def logic_unfreeze_to_spherical ( link_name , olt , ola , old , ols , olz ): nlt , nla , nld , nls , nlz = olt , ola , old , ols , olz if link_name == name : nlt = new_joint_type q_zeros = jnp . zeros (( q_size )) qd_zeros = jnp . zeros (( qd_size ,)) nla = qd_zeros if new_arma is None else new_arma nld = qd_zeros if new_damp is None else new_damp nls = qd_zeros if new_stif is None else new_stif nlz = q_zeros if new_zero is None else new_zero # unit quaternion if new_joint_type in [ \"spherical\" , \"free\" , \"cor\" ] and new_zero is None : nlz = nlz . at [ 0 ] . set ( 1.0 ) return nlt , nla , nld , nls , nlz sys = _update_sys_if_replace_joint_type ( self , logic_unfreeze_to_spherical ) jm = get_joint_model ( new_joint_type ) if jm . init_joint_params is not None : sys = sys . from_str ( sys . to_str ( warn = warn ), seed = seed ) return sys @staticmethod def joint_type_simplification ( typ : str ) -> str : if typ [: 4 ] == \"free\" : if typ == \"free_2d\" : return \"free_2d\" else : return \"free\" elif typ [: 3 ] == \"cor\" : return \"cor\" elif typ [: 9 ] == \"spherical\" : return \"spherical\" else : return typ @staticmethod def joint_type_is_free_or_cor ( typ : str ) -> bool : return System . joint_type_simplification ( typ ) in [ \"free\" , \"cor\" ] @staticmethod def joint_type_is_spherical ( typ : str ) -> bool : return System . joint_type_simplification ( typ ) == \"spherical\" @staticmethod def joint_type_is_free_or_cor_or_spherical ( typ : str ) -> bool : return System . joint_type_is_free_or_cor ( typ ) or System . joint_type_is_spherical ( typ ) def findall_imus ( self , names : bool = True ) -> list [ str ] | list [ int ]: bodies = [ name for name in self . link_names if name [: 3 ] == \"imu\" ] return bodies if names else [ self . name_to_idx ( n ) for n in bodies ] def findall_segments ( self , names : bool = True ) -> list [ str ] | list [ int ]: imus = self . findall_imus ( names = True ) bodies = [ name for name in self . link_names if name not in imus ] return bodies if names else [ self . name_to_idx ( n ) for n in bodies ] def _bodies_indices_to_bodies_name ( self , bodies : list [ int ]) -> list [ str ]: return [ self . idx_to_name ( i ) for i in bodies ] def findall_bodies_to_world ( self , names : bool = False ) -> list [ int ] | list [ str ]: bodies = [ i for i , p in enumerate ( self . link_parents ) if p == - 1 ] return self . _bodies_indices_to_bodies_name ( bodies ) if names else bodies def find_body_to_world ( self , name : bool = False ) -> int | str : bodies = self . findall_bodies_to_world ( names = name ) assert len ( bodies ) == 1 return bodies [ 0 ] def findall_bodies_with_jointtype ( self , typ : str , names : bool = False ) -> list [ int ] | list [ str ]: bodies = [ i for i , _typ in enumerate ( self . link_types ) if _typ == typ ] return self . _bodies_indices_to_bodies_name ( bodies ) if names else bodies def children ( self , name : str , names : bool = False ) -> list [ int ] | list [ str ]: \"List all direct children of body, does not include body itself\" p = self . name_to_idx ( name ) bodies = [ i for i in range ( self . num_links ()) if self . link_parents [ i ] == p ] return bodies if ( not names ) else [ self . idx_to_name ( i ) for i in bodies ] def findall_bodies_subsystem ( self , name : str , names : bool = False ) -> list [ int ] | list [ str ]: \"List all children and children's children; does not include body itself\" children = self . children ( name , names = True ) grandchildren = [ self . findall_bodies_subsystem ( n , names = True ) for n in children ] bodies = tree . flatten ([ children , grandchildren ]) return bodies if names else [ self . name_to_idx ( n ) for n in bodies ] def scan ( self , f : Callable , in_types : str , * args , reverse : bool = False ): \"\"\"Scan `f` along each link in system whilst carrying along state. Args: f (Callable[..., Y]): f(y: Y, *args) -> y in_types: string specifying the type of each input arg: 'l' is an input to be split according to link ranges 'q' is an input to be split according to q ranges 'd' is an input to be split according to qd ranges args: Arguments passed to `f`, and split to match the link. reverse (bool, optional): If `true` from leaves to root. Defaults to False. Returns: ys: Stacked output y of f. \"\"\" return _scan_sys ( self , f , in_types , * args , reverse = reverse ) def parse ( self ) -> \"System\" : \"\"\"Initial setup of system. System object does not work unless it is parsed. Currently it does: - some consistency checks - populate the spatial inertia tensors - check that all names are unique - check that names are strings - check that all pos_min <= pos_max (unless traced) - order geoms in ascending order based on their parent link idx - check that all links have the correct size of - damping - armature - stiffness - zeropoint - check that n_links == len(sys.omc) \"\"\" return _parse_system ( self ) def render ( self , xs : Optional [ Transform | list [ Transform ]] = None , camera : Optional [ str ] = None , show_pbar : bool = True , backend : str = \"mujoco\" , render_every_nth : int = 1 , ** scene_kwargs , ) -> list [ np . ndarray ]: \"\"\"Render frames from system and trajectory of maximal coordinates `xs`. Args: sys (base.System): System to render. xs (base.Transform | list[base.Transform]): Single or time-series of maximal coordinates `xs`. show_pbar (bool, optional): Whether or not to show a progress bar. Defaults to True. Returns: list[np.ndarray]: Stacked rendered frames. Length == len(xs). \"\"\" return ring . rendering . render ( self , xs , camera , show_pbar , backend , render_every_nth , ** scene_kwargs ) def render_prediction ( self , xs : Transform | list [ Transform ], yhat : dict | jax . Array | np . ndarray , # by default we don't predict the global rotation transparent_segment_to_root : bool = True , ** kwargs , ): \"\"\"`xs` matches `sys`. `yhat` matches `sys_noimu`. `yhat` are child-to-parent. Note that the body in yhat that connects to -1, is parent-to-child! \"\"\" return ring . rendering . render_prediction ( self , xs , yhat , transparent_segment_to_root , ** kwargs ) def delete_system ( self , link_name : str | list [ str ], strict : bool = True ): \"Cut subsystem starting at `link_name` (inclusive) from tree.\" return ring . sys_composer . delete_subsystem ( self , link_name , strict ) def make_sys_noimu ( self , imu_link_names : Optional [ list [ str ]] = None ): \"Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'}\" return ring . sys_composer . make_sys_noimu ( self , imu_link_names ) def inject_system ( self , other_system : \"System\" , at_body : Optional [ str ] = None ): \"\"\"Combine two systems into one. Args: sys (base.System): Large system. sub_sys (base.System): Small system that will be included into the large system `sys`. at_body (Optional[str], optional): Into which body of the large system small system will be included. Defaults to `worldbody`. Returns: base.System: _description_ \"\"\" return ring . sys_composer . inject_system ( self , other_system , at_body ) def morph_system ( self , new_parents : Optional [ list [ int | str ]] = None , new_anchor : Optional [ int | str ] = None , ): \"\"\"Re-orders the graph underlying the system. Returns a new system. Args: sys (base.System): System to be modified. new_parents (list[int]): Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system. Returns: base.System: Modified system. \"\"\" return ring . sys_composer . morph_system ( self , new_parents , new_anchor ) @staticmethod def from_xml ( path : str , seed : int = 1 ): return ring . io . load_sys_from_xml ( path , seed ) @staticmethod def from_str ( xml : str , seed : int = 1 ): return ring . io . load_sys_from_str ( xml , seed ) def to_str ( self , warn : bool = True ) -> str : return ring . io . save_sys_to_str ( self , warn = warn ) def to_xml ( self , path : str ) -> None : ring . io . save_sys_to_xml ( self , path ) @classmethod def create ( cls , path_or_str : str , seed : int = 1 ) -> \"System\" : path = Path ( path_or_str ) . with_suffix ( \".xml\" ) exists = False try : exists = path . exists () except OSError : # file length too length pass if exists : return cls . from_xml ( path , seed = seed ) else : return cls . from_str ( path_or_str , seed = seed ) def coordinate_vector_to_q ( self , q : jax . Array , custom_joints : dict [ str , Callable ] = {}, ) -> jax . Array : \"\"\"Map a coordinate vector `q` to the minimal coordinates vector of the sys\"\"\" # Does, e.g. # - normalize quaternions # - hinge joints in [-pi, pi] q_preproc = [] def preprocess ( _ , __ , link_type , q ): to_q = ring . algorithms . jcalc . get_joint_model ( link_type ) . coordinate_vector_to_q # function in custom_joints has priority over JointModel if link_type in custom_joints : to_q = custom_joints [ link_type ] if to_q is None : raise NotImplementedError ( f \"Please specify the custom joint ` { link_type } `\" \" either using the `custom_joints` arguments or using the\" \" JointModel.coordinate_vector_to_q field.\" ) new_q = to_q ( q ) q_preproc . append ( new_q ) self . scan ( preprocess , \"lq\" , self . link_types , q ) return jnp . concatenate ( q_preproc )","title":"System"},{"location":"api/#motionconfig","text":"","title":"MotionConfig"},{"location":"api/#src.ring.algorithms.jcalc.MotionConfig","text":"Configuration for joint motion generation in kinematic and dynamic simulations. This class defines the constraints and parameters for generating random joint motions, including angular and positional velocity limits, interpolation methods, and range restrictions for various joint types. Attributes: T ( float ) \u2013 Total duration of the motion sequence (in seconds). t_min ( float ) \u2013 Minimum time interval between two generated joint states. t_max ( float | TimeDependentFloat ) \u2013 Maximum time interval between two generated joint states. dang_min ( float | TimeDependentFloat ) \u2013 Minimum angular velocity (rad/s). dang_max ( float | TimeDependentFloat ) \u2013 Maximum angular velocity (rad/s). dang_min_free_spherical ( float | TimeDependentFloat ) \u2013 Minimum angular velocity for free and spherical joints. dang_max_free_spherical ( float | TimeDependentFloat ) \u2013 Maximum angular velocity for free and spherical joints. delta_ang_min ( float | TimeDependentFloat ) \u2013 Minimum allowed change in joint angle (radians). delta_ang_max ( float | TimeDependentFloat ) \u2013 Maximum allowed change in joint angle (radians). delta_ang_min_free_spherical ( float | TimeDependentFloat ) \u2013 Minimum allowed change in angle for free/spherical joints. delta_ang_max_free_spherical ( float | TimeDependentFloat ) \u2013 Maximum allowed change in angle for free/spherical joints. dpos_min ( float | TimeDependentFloat ) \u2013 Minimum translational velocity. dpos_max ( float | TimeDependentFloat ) \u2013 Maximum translational velocity. pos_min ( float | TimeDependentFloat ) \u2013 Minimum position constraint. pos_max ( float | TimeDependentFloat ) \u2013 Maximum position constraint. pos_min_p3d_x ( float | TimeDependentFloat ) \u2013 Minimum position in x-direction for P3D joints. pos_max_p3d_x ( float | TimeDependentFloat ) \u2013 Maximum position in x-direction for P3D joints. pos_min_p3d_y ( float | TimeDependentFloat ) \u2013 Minimum position in y-direction for P3D joints. pos_max_p3d_y ( float | TimeDependentFloat ) \u2013 Maximum position in y-direction for P3D joints. pos_min_p3d_z ( float | TimeDependentFloat ) \u2013 Minimum position in z-direction for P3D joints. pos_max_p3d_z ( float | TimeDependentFloat ) \u2013 Maximum position in z-direction for P3D joints. cdf_bins_min ( int ) \u2013 Minimum number of bins for cumulative distribution function (CDF)-based random sampling. cdf_bins_max ( Optional [ int ] ) \u2013 Maximum number of bins for CDF-based sampling. randomized_interpolation_angle ( bool ) \u2013 Whether to use randomized interpolation for angular motion. randomized_interpolation_position ( bool ) \u2013 Whether to use randomized interpolation for positional motion. interpolation_method ( str ) \u2013 Interpolation method to be used (default: \"cosine\"). range_of_motion_hinge ( bool ) \u2013 Whether to enforce range-of-motion constraints on hinge joints. range_of_motion_hinge_method ( str ) \u2013 Method used for range-of-motion enforcement (e.g., \"uniform\", \"sigmoid\"). rom_halfsize ( float | TimeDependentFloat ) \u2013 Half-size of the range of motion restriction. ang0_min ( float ) \u2013 Minimum initial joint angle. ang0_max ( float ) \u2013 Maximum initial joint angle. pos0_min ( float ) \u2013 Minimum initial joint position. pos0_max ( float ) \u2013 Maximum initial joint position. cor_t_min ( float ) \u2013 Minimum time step for center-of-rotation (COR) joints. cor_t_max ( float | TimeDependentFloat ) \u2013 Maximum time step for COR joints. cor_dpos_min ( float | TimeDependentFloat ) \u2013 Minimum velocity for COR translation. cor_dpos_max ( float | TimeDependentFloat ) \u2013 Maximum velocity for COR translation. cor_pos_min ( float | TimeDependentFloat ) \u2013 Minimum position for COR translation. cor_pos_max ( float | TimeDependentFloat ) \u2013 Maximum position for COR translation. cor_pos0_min ( float ) \u2013 Initial minimum position for COR translation. cor_pos0_max ( float ) \u2013 Initial maximum position for COR translation. joint_type_specific_overwrites ( dict [ str , dict [ str , Any ]] ) \u2013 A dictionary mapping joint types to specific motion configuration overrides. Methods: Name Description is_feasible Checks if the motion configuration satisfies all constraints. to_nomotion_config Returns a new MotionConfig where all velocities and angle changes are set to zero. overwrite_for_joint_type str, **changes) -> None: Applies specific configuration changes for a given joint type. Note: These changes affect all instances of MotionConfig for this joint type. overwrite_for_subsystem base.System, link_name: str, **changes) -> base.System: Modifies the motion configuration for all joints in a subsystem rooted at link_name . from_register str) -> \"MotionConfig\": Retrieves a predefined MotionConfig from the global registry. Source code in src/ring/algorithms/jcalc.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 @dataclass class MotionConfig : \"\"\" Configuration for joint motion generation in kinematic and dynamic simulations. This class defines the constraints and parameters for generating random joint motions, including angular and positional velocity limits, interpolation methods, and range restrictions for various joint types. Attributes: T (float): Total duration of the motion sequence (in seconds). t_min (float): Minimum time interval between two generated joint states. t_max (float | TimeDependentFloat): Maximum time interval between two generated joint states. dang_min (float | TimeDependentFloat): Minimum angular velocity (rad/s). dang_max (float | TimeDependentFloat): Maximum angular velocity (rad/s). dang_min_free_spherical (float | TimeDependentFloat): Minimum angular velocity for free and spherical joints. dang_max_free_spherical (float | TimeDependentFloat): Maximum angular velocity for free and spherical joints. delta_ang_min (float | TimeDependentFloat): Minimum allowed change in joint angle (radians). delta_ang_max (float | TimeDependentFloat): Maximum allowed change in joint angle (radians). delta_ang_min_free_spherical (float | TimeDependentFloat): Minimum allowed change in angle for free/spherical joints. delta_ang_max_free_spherical (float | TimeDependentFloat): Maximum allowed change in angle for free/spherical joints. dpos_min (float | TimeDependentFloat): Minimum translational velocity. dpos_max (float | TimeDependentFloat): Maximum translational velocity. pos_min (float | TimeDependentFloat): Minimum position constraint. pos_max (float | TimeDependentFloat): Maximum position constraint. pos_min_p3d_x (float | TimeDependentFloat): Minimum position in x-direction for P3D joints. pos_max_p3d_x (float | TimeDependentFloat): Maximum position in x-direction for P3D joints. pos_min_p3d_y (float | TimeDependentFloat): Minimum position in y-direction for P3D joints. pos_max_p3d_y (float | TimeDependentFloat): Maximum position in y-direction for P3D joints. pos_min_p3d_z (float | TimeDependentFloat): Minimum position in z-direction for P3D joints. pos_max_p3d_z (float | TimeDependentFloat): Maximum position in z-direction for P3D joints. cdf_bins_min (int): Minimum number of bins for cumulative distribution function (CDF)-based random sampling. cdf_bins_max (Optional[int]): Maximum number of bins for CDF-based sampling. randomized_interpolation_angle (bool): Whether to use randomized interpolation for angular motion. randomized_interpolation_position (bool): Whether to use randomized interpolation for positional motion. interpolation_method (str): Interpolation method to be used (default: \"cosine\"). range_of_motion_hinge (bool): Whether to enforce range-of-motion constraints on hinge joints. range_of_motion_hinge_method (str): Method used for range-of-motion enforcement (e.g., \"uniform\", \"sigmoid\"). rom_halfsize (float | TimeDependentFloat): Half-size of the range of motion restriction. ang0_min (float): Minimum initial joint angle. ang0_max (float): Maximum initial joint angle. pos0_min (float): Minimum initial joint position. pos0_max (float): Maximum initial joint position. cor_t_min (float): Minimum time step for center-of-rotation (COR) joints. cor_t_max (float | TimeDependentFloat): Maximum time step for COR joints. cor_dpos_min (float | TimeDependentFloat): Minimum velocity for COR translation. cor_dpos_max (float | TimeDependentFloat): Maximum velocity for COR translation. cor_pos_min (float | TimeDependentFloat): Minimum position for COR translation. cor_pos_max (float | TimeDependentFloat): Maximum position for COR translation. cor_pos0_min (float): Initial minimum position for COR translation. cor_pos0_max (float): Initial maximum position for COR translation. joint_type_specific_overwrites (dict[str, dict[str, Any]]): A dictionary mapping joint types to specific motion configuration overrides. Methods: is_feasible() -> bool: Checks if the motion configuration satisfies all constraints. to_nomotion_config() -> MotionConfig: Returns a new `MotionConfig` where all velocities and angle changes are set to zero. overwrite_for_joint_type(joint_type: str, **changes) -> None: Applies specific configuration changes for a given joint type. Note: These changes affect all instances of `MotionConfig` for this joint type. overwrite_for_subsystem(sys: base.System, link_name: str, **changes) -> base.System: Modifies the motion configuration for all joints in a subsystem rooted at `link_name`. from_register(name: str) -> \"MotionConfig\": Retrieves a predefined `MotionConfig` from the global registry. \"\"\" # noqa: E501 T : float = 60.0 # length of random motion t_min : float = 0.05 # min time between two generated angles t_max : float | TimeDependentFloat = 0.30 # max time .. dang_min : float | TimeDependentFloat = 0.1 # minimum angular velocity in rad/s dang_max : float | TimeDependentFloat = 3.0 # maximum angular velocity in rad/s # minimum angular velocity of euler angles used for `free and spherical joints` dang_min_free_spherical : float | TimeDependentFloat = 0.1 dang_max_free_spherical : float | TimeDependentFloat = 3.0 # max min allowed actual delta values in radians delta_ang_min : float | TimeDependentFloat = 0.0 delta_ang_max : float | TimeDependentFloat = 2 * jnp . pi delta_ang_min_free_spherical : float | TimeDependentFloat = 0.0 delta_ang_max_free_spherical : float | TimeDependentFloat = 2 * jnp . pi dpos_min : float | TimeDependentFloat = 0.001 # speed of translation dpos_max : float | TimeDependentFloat = 0.7 pos_min : float | TimeDependentFloat = - 2.5 pos_max : float | TimeDependentFloat = + 2.5 pos_min_p3d_x : float | TimeDependentFloat = - 2.5 pos_max_p3d_x : float | TimeDependentFloat = + 2.5 pos_min_p3d_y : float | TimeDependentFloat = - 2.5 pos_max_p3d_y : float | TimeDependentFloat = + 2.5 pos_min_p3d_z : float | TimeDependentFloat = - 2.5 pos_max_p3d_z : float | TimeDependentFloat = + 2.5 # used by both `random_angle_*` and `random_pos_*` # only used if `randomized_interpolation` is set cdf_bins_min : int = 5 # by default equal to `cdf_bins_min` cdf_bins_max : Optional [ int ] = None # flags randomized_interpolation_angle : bool = False randomized_interpolation_position : bool = False interpolation_method : str = \"cosine\" range_of_motion_hinge : bool = True range_of_motion_hinge_method : str = \"uniform\" # this value has nothing to do with `range_of_motion` flag # this forces the value to stay within [ANG_0 - rom_halfsize, ANG_0 + rom_halfsize] # used only by the `_draw_rxyz` function rom_halfsize : float | TimeDependentFloat = 2 * jnp . pi # initial value of joints ang0_min : float = - jnp . pi ang0_max : float = jnp . pi pos0_min : float = 0.0 pos0_max : float = 0.0 pos0_min_p3d_x : float = 0.0 pos0_max_p3d_x : float = 0.0 pos0_min_p3d_y : float = 0.0 pos0_max_p3d_y : float = 0.0 pos0_min_p3d_z : float = 0.0 pos0_max_p3d_z : float = 0.0 # cor (center of rotation) custom fields cor_t_min : float = 0.2 cor_t_max : float | TimeDependentFloat = 2.0 cor_dpos_min : float | TimeDependentFloat = 0.00001 cor_dpos_max : float | TimeDependentFloat = 0.5 cor_pos_min : float | TimeDependentFloat = - 0.4 cor_pos_max : float | TimeDependentFloat = 0.4 cor_pos0_min : float = 0.0 cor_pos0_max : float = 0.0 # specify changes for this motionconfig and for specific joint types # map of `link_types` -> dictionary of changes joint_type_specific_overwrites : dict [ str , dict [ str , Any ]] = field ( default_factory = lambda : dict () ) def is_feasible ( self ) -> bool : return _is_feasible_config1 ( self ) def to_nomotion_config ( self ) -> \"MotionConfig\" : kwargs = asdict ( self ) for key in [ \"dang_min\" , \"dang_max\" , \"delta_ang_min\" , \"dang_min_free_spherical\" , \"dang_max_free_spherical\" , \"delta_ang_min_free_spherical\" , \"dpos_min\" , \"dpos_max\" , ]: kwargs [ key ] = 0.0 nomotion_config = MotionConfig ( ** kwargs ) assert nomotion_config . is_feasible () return nomotion_config @staticmethod def overwrite_for_joint_type ( joint_type : str , ** changes ) -> None : \"\"\"Changes values of the `MotionConfig` used by the draw_fn for only a specific joint. !!! Note This applies these changes to *all* MotionConfigs for this joint type! This takes precedence *over* `Motionconfig.joint_type_specific_overwrites`! \"\"\" previous_changes = _overwrite_for_joint_type_changes [ joint_type ] for change in changes : assert change not in previous_changes , f \"For jointtype= { joint_type } you \" f \"previously changed the value= { change } . You can't change it again, this \" \"is not supported.\" previous_changes . update ( changes ) jm = get_joint_model ( joint_type ) def draw_fn ( config , * args ): return jm . rcmg_draw_fn ( replace ( config , ** changes ), * args ) register_new_joint_type ( joint_type , replace ( jm , rcmg_draw_fn = draw_fn ), base . Q_WIDTHS [ joint_type ], base . QD_WIDTHS [ joint_type ], overwrite = True , ) @staticmethod def overwrite_for_subsystem ( sys : base . System , link_name : str , ** changes ) -> base . System : \"\"\"Modifies motionconfig of all joints in subsystem with root `link_name`. Note that if the subsystem contains a free joint then the jointtype will will be re-named to `free_<link_name>`, then the RCMG flag `cor` will potentially not work as expected because it searches for all joints of type `free` to replace with `cor`. The workaround here is to change the type already from `free` to `cor in the xml file. This takes precedence *over* `Motionconfig.joint_type_specific_overwrites`! Args: sys (base.System): System object that gets updated link_name (str): Root node of subsystem changes: Changes to apply to the motionconfig Return: base.System: Updated system with new jointtypes \"\"\" from ring.algorithms.generator.finalize_fns import _P_gains # all bodies in the subsystem bodies = sys . findall_bodies_subsystem ( link_name ) + [ sys . name_to_idx ( link_name )] jts_subsys = set ([ sys . link_types [ i ] for i in bodies ]) - set ([ \"frozen\" ]) postfix = \"_\" + link_name # create new joint types with updated motionconfig for typ in jts_subsys : register_new_joint_type ( typ + postfix , get_joint_model ( typ ), base . Q_WIDTHS [ typ ], base . QD_WIDTHS [ typ ], ) MotionConfig . overwrite_for_joint_type ( typ + postfix , ** changes ) _P_gains [ typ + postfix ] = _P_gains [ typ ] # rename all jointtypes new_link_types = [ ( sys . link_types [ i ] + postfix if ( i in bodies and sys . link_types [ i ] != \"frozen\" ) else sys . link_types [ i ] ) for i in range ( sys . num_links ()) ] sys = sys . replace ( link_types = new_link_types ) return sys @staticmethod def from_register ( name : str ) -> \"MotionConfig\" : return _registered_motion_configs [ name ]","title":"MotionConfig"},{"location":"api/#src.ring.algorithms.jcalc.join_motionconfigs","text":"Joins multiple MotionConfig objects in time, transitioning between them at specified boundaries. This function takes a list of MotionConfig instances and a corresponding list of boundary times, and constructs a new MotionConfig that varies in time according to the provided segments. Parameters: configs ( list [ MotionConfig ] ) \u2013 A list of MotionConfig objects to be joined. boundaries ( list [ float ] ) \u2013 A list of time values where transitions between configs occur. Must have one element less than configs , as each boundary defines the transition point between two consecutive configurations. Returns: MotionConfig ( MotionConfig ) \u2013 A new MotionConfig object where time-dependent fields transition based on the MotionConfig \u2013 specified boundaries. Raises: AssertionError \u2013 If the number of boundaries does not match len(configs) - 1 . AssertionError \u2013 If time-independent fields have differing values across configs . Notes Only fields that are time-dependent ( float | TimeDependentFloat ) will change over time. Time-independent fields must be the same in all configs , or an error is raised. Source code in src/ring/algorithms/jcalc.py 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 def join_motionconfigs ( configs : list [ MotionConfig ], boundaries : list [ float ] ) -> MotionConfig : \"\"\" Joins multiple `MotionConfig` objects in time, transitioning between them at specified boundaries. This function takes a list of `MotionConfig` instances and a corresponding list of boundary times, and constructs a new `MotionConfig` that varies in time according to the provided segments. Args: configs (list[MotionConfig]): A list of `MotionConfig` objects to be joined. boundaries (list[float]): A list of time values where transitions between `configs` occur. Must have one element less than `configs`, as each boundary defines the transition point between two consecutive configurations. Returns: MotionConfig: A new `MotionConfig` object where time-dependent fields transition based on the specified boundaries. Raises: AssertionError: If the number of boundaries does not match `len(configs) - 1`. AssertionError: If time-independent fields have differing values across `configs`. Notes: - Only fields that are time-dependent (`float | TimeDependentFloat`) will change over time. - Time-independent fields must be the same in all `configs`, or an error is raised. \"\"\" # noqa: E501 # to avoid a circular import due to `ring.utils.randomize_sys` importing `jcalc` from ring.utils import tree_equal assert len ( configs ) == ( len ( boundaries ) + 1 ), \"length of `boundaries` should be one less than length of `configs`\" boundaries = jnp . array ( boundaries , dtype = float ) def new_value ( field : str ): scalar_options = jnp . array ([ getattr ( c , field ) for c in configs ]) def scalar ( t ): return jax . lax . dynamic_index_in_dim ( scalar_options , _find_interval ( t , boundaries ), keepdims = False ) return scalar hints = get_type_hints ( MotionConfig ()) attrs = MotionConfig () . __dict__ is_time_dependent_field = lambda key : hints [ key ] == ( float | TimeDependentFloat ) time_dependent_fields = [ key for key in attrs if is_time_dependent_field ( key )] time_independent_fields = [ key for key in attrs if not is_time_dependent_field ( key )] for time_dep_field in time_independent_fields : try : field_values = set ([ getattr ( config , time_dep_field ) for config in configs ]) assert ( len ( field_values ) == 1 ), f \"MotionConfig. { time_dep_field } = { field_values } . \" \"Should be one unique value..\" except ( TypeError ): # dict is not hashable so test equality of all elements differently comparison_ele = getattr ( configs [ 0 ], time_dep_field ) for other_config in configs [ 1 :]: other_ele = getattr ( other_config , time_dep_field ) assert tree_equal ( comparison_ele , other_ele ), f \"MotionConfig. { time_dep_field } with { comparison_ele } != { other_ele } \" \" Should be one unique value..\" changes = { field : new_value ( field ) for field in time_dependent_fields } return replace ( configs [ 0 ], ** changes )","title":"join_motionconfigs"},{"location":"api/#extending-the-rcmg","text":"","title":"Extending the RCMG"},{"location":"api/#src.ring.algorithms.jcalc.JointModel","text":"Represents the kinematic and dynamic properties of a joint type. A JointModel defines the mathematical functions required to compute joint transformations, motion, control terms, and inverse kinematics. It is used to describe the behavior of various joint types, including revolute, prismatic, spherical, and free joints. Attributes: transform ( Callable [[ Array , Array ], Transform ] ) \u2013 Computes the transformation (position and orientation) of the joint given the joint state q and joint parameters. motion ( list [ Motion | Callable [[ Array ], Motion ]] ) \u2013 Defines the joint motion model. It can be a list of Motion objects or callables that return Motion based on joint parameters. rcmg_draw_fn ( Optional [ DRAW_FN ] ) \u2013 Function used to generate a reference motion trajectory for the joint using Randomized Control Motion Generation (RCMG). p_control_term ( Optional [ P_CONTROL_TERM ] ) \u2013 Function that computes the proportional control term for the joint. qd_from_q ( Optional [ QD_FROM_Q ] ) \u2013 Function to compute joint velocity ( qd ) from joint positions ( q ). coordinate_vector_to_q ( Optional [ COORDINATE_VECTOR_TO_Q ] ) \u2013 Function that maps a coordinate vector to a valid joint state q , ensuring constraints (e.g., wrapping angles or normalizing quaternions). inv_kin ( Optional [ INV_KIN ] ) \u2013 Function that computes the inverse kinematics for the joint, mapping a desired transform to joint coordinates q . init_joint_params ( Optional [ INIT_JOINT_PARAMS ] ) \u2013 Function that initializes joint-specific parameters. utilities ( Optional [ dict [ str , Any ]] ) \u2013 Additional utility functions or metadata related to the joint model. Notes The transform function is essential for computing the joint's spatial transformation based on its generalized coordinates. The motion attribute describes how forces and torques affect the joint. The rcmg_draw_fn is used for RCMG motion generation. The coordinate_vector_to_q is critical for maintaining valid joint states. Source code in src/ring/algorithms/jcalc.py 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 @dataclass class JointModel : \"\"\" Represents the kinematic and dynamic properties of a joint type. A `JointModel` defines the mathematical functions required to compute joint transformations, motion, control terms, and inverse kinematics. It is used to describe the behavior of various joint types, including revolute, prismatic, spherical, and free joints. Attributes: transform (Callable[[jax.Array, jax.Array], base.Transform]): Computes the transformation (position and orientation) of the joint given the joint state `q` and joint parameters. motion (list[base.Motion | Callable[[jax.Array], base.Motion]]): Defines the joint motion model. It can be a list of `Motion` objects or callables that return `Motion` based on joint parameters. rcmg_draw_fn (Optional[DRAW_FN]): Function used to generate a reference motion trajectory for the joint using Randomized Control Motion Generation (RCMG). p_control_term (Optional[P_CONTROL_TERM]): Function that computes the proportional control term for the joint. qd_from_q (Optional[QD_FROM_Q]): Function to compute joint velocity (`qd`) from joint positions (`q`). coordinate_vector_to_q (Optional[COORDINATE_VECTOR_TO_Q]): Function that maps a coordinate vector to a valid joint state `q`, ensuring constraints (e.g., wrapping angles or normalizing quaternions). inv_kin (Optional[INV_KIN]): Function that computes the inverse kinematics for the joint, mapping a desired transform to joint coordinates `q`. init_joint_params (Optional[INIT_JOINT_PARAMS]): Function that initializes joint-specific parameters. utilities (Optional[dict[str, Any]]): Additional utility functions or metadata related to the joint model. Notes: - The `transform` function is essential for computing the joint's spatial transformation based on its generalized coordinates. - The `motion` attribute describes how forces and torques affect the joint. - The `rcmg_draw_fn` is used for RCMG motion generation. - The `coordinate_vector_to_q` is critical for maintaining valid joint states. \"\"\" # noqa: E501 # (q, params) -> Transform transform : Callable [[ jax . Array , jax . Array ], base . Transform ] # len(motion) == len(qd) # if callable: joint_params -> base.Motion motion : list [ base . Motion | Callable [[ jax . Array ], base . Motion ]] = field ( default_factory = lambda : [] ) # (config, key_t, key_value, params) -> jax.Array rcmg_draw_fn : Optional [ DRAW_FN ] = None # only used by `pd_control` p_control_term : Optional [ P_CONTROL_TERM ] = None qd_from_q : Optional [ QD_FROM_Q ] = None # used by # -`inverse_kinematics_endeffector` # - System.coordinate_vector_to_q coordinate_vector_to_q : Optional [ COORDINATE_VECTOR_TO_Q ] = None # only used by `inverse_kinematics` inv_kin : Optional [ INV_KIN ] = None init_joint_params : Optional [ INIT_JOINT_PARAMS ] = None utilities : Optional [ dict [ str , Any ]] = field ( default_factory = lambda : dict ())","title":"JointModel"},{"location":"api/#src.ring.algorithms.jcalc.register_new_joint_type","text":"Source code in src/ring/algorithms/jcalc.py 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 def register_new_joint_type ( joint_type : str , joint_model : JointModel , q_width : int , qd_width : Optional [ int ] = None , overwrite : bool = False , ): # this name is used assert joint_type != \"default\" , \"Please use another name.\" exists = joint_type in _joint_types if exists and overwrite : for dic in [ base . Q_WIDTHS , base . QD_WIDTHS , _joint_types , ]: dic . pop ( joint_type ) else : assert ( not exists ), f \"joint type ` { joint_type } `already exists, use `overwrite=True`\" if qd_width is None : qd_width = q_width assert len ( joint_model . motion ) == qd_width _joint_types . update ({ joint_type : joint_model }) base . Q_WIDTHS . update ({ joint_type : q_width }) base . QD_WIDTHS . update ({ joint_type : qd_width })","title":"register_new_joint_type"},{"location":"api/#simulation","text":"","title":"Simulation"},{"location":"api/#src.ring.base.State","text":"The static and dynamic state of a system in minimal and maximal coordinates. Use .create() to create this object. Parameters: q ( Array ) \u2013 System state in minimal coordinates (equals sys.q_size() ) qd ( Array ) \u2013 System velocity in minimal coordinates (equals sys.qd_size() ) x \u2013 (Transform): Maximal coordinates of all links. From epsilon-to-link. Source code in src/ring/base.py 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 @struct . dataclass class State ( _Base ): \"\"\"The static and dynamic state of a system in minimal and maximal coordinates. Use `.create()` to create this object. Args: q (jax.Array): System state in minimal coordinates (equals `sys.q_size()`) qd (jax.Array): System velocity in minimal coordinates (equals `sys.qd_size()`) x: (Transform): Maximal coordinates of all links. From epsilon-to-link. \"\"\" q : jax . Array qd : jax . Array x : Transform @classmethod def create ( cls , sys : System , q : Optional [ jax . Array ] = None , qd : Optional [ jax . Array ] = None , x : Optional [ Transform ] = None , key : Optional [ jax . Array ] = None , custom_joints : dict [ str , Callable ] = {}, ): \"\"\"Create state of system. Args: sys (System): The system for which to create a state. q (jax.Array, optional): The joint values of the system. Defaults to None. Which then defaults to zeros. qd (jax.Array, optional): The joint velocities of the system. Defaults to None. Which then defaults to zeros. Returns: (State): Create State object. \"\"\" if key is not None : assert q is None q = jax . random . normal ( key , shape = ( sys . q_size (),)) q = sys . coordinate_vector_to_q ( q , custom_joints ) elif q is None : q = jnp . zeros (( sys . q_size (),)) # free, cor, spherical joints are not zeros but have unit quaternions def replace_by_unit_quat ( _ , idx_map , link_typ , link_idx ): nonlocal q if sys . joint_type_is_free_or_cor_or_spherical ( link_typ ): q_idxs_link = idx_map [ \"q\" ]( link_idx ) q = q . at [ q_idxs_link . start ] . set ( 1.0 ) sys . scan ( replace_by_unit_quat , \"ll\" , sys . link_types , list ( range ( sys . num_links ())), ) else : pass if qd is None : qd = jnp . zeros (( sys . qd_size (),)) if x is None : x = Transform . zero (( sys . num_links (),)) return cls ( q , qd , x )","title":"State"},{"location":"api/#src.ring.algorithms.dynamics.step","text":"Steps the dynamics. Returns the state of next timestep. Source code in src/ring/algorithms/dynamics.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 def step ( sys : base . System , state : base . State , taus : Optional [ jax . Array ] = None , n_substeps : int = 1 , ) -> base . State : \"Steps the dynamics. Returns the state of next timestep.\" assert sys . q_size () == state . q . size if taus is None : taus = jnp . zeros_like ( state . qd ) assert sys . qd_size () == state . qd . size == taus . size assert ( sys . integration_method . lower () == \"semi_implicit_euler\" ), \"Currently, nothing else then `semi_implicit_euler` implemented.\" sys = sys . replace ( dt = sys . dt / n_substeps ) for _ in range ( n_substeps ): # update kinematics before stepping; this means that the `x` in `state` # will lag one step behind but otherwise we would have to return # the system object which would be awkward sys , state = kinematics . forward_kinematics ( sys , state ) state = _integration_methods [ sys . integration_method . lower ()]( sys , state , taus ) return state","title":"step"},{"location":"api/#src.ring.base.Transform","text":"Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B, where B is located relative to A at pos in frame A and rot is the relative quaternion from A to B. Create using `Transform.create(pos=..., rot=...) Source code in src/ring/base.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @struct . dataclass class Transform ( _Base ): \"\"\"Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B, where B is located relative to A at `pos` in frame A and `rot` is the relative quaternion from A to B. Create using `Transform.create(pos=..., rot=...) \"\"\" pos : Vector rot : Quaternion @classmethod def create ( cls , pos = None , rot = None ): assert not ( pos is None and rot is None ), \"One must be given.\" shape_rot = rot . shape [: - 1 ] if rot is not None else () shape_pos = pos . shape [: - 1 ] if pos is not None else () if pos is None : pos = jnp . zeros ( shape_rot + ( 3 ,)) if rot is None : rot = jnp . array ([ 1.0 , 0 , 0 , 0 ]) rot = jnp . tile ( jnp . array ([ 1.0 , 0.0 , 0.0 , 0.0 ]), shape_pos + ( 1 ,)) assert pos . shape [: - 1 ] == rot . shape [: - 1 ] return Transform ( pos , rot ) @classmethod def zero ( cls , shape = ()) -> \"Transform\" : \"\"\"Returns a zero transform with a batch shape.\"\"\" pos = jnp . zeros ( shape + ( 3 ,)) rot = jnp . tile ( jnp . array ([ 1.0 , 0.0 , 0.0 , 0.0 ]), shape + ( 1 ,)) return Transform ( pos , rot ) def as_matrix ( self ) -> jax . Array : E = maths . quat_to_3x3 ( self . rot ) return spatial . quadrants ( aa = E , bb = E ) @ spatial . xlt ( self . pos )","title":"Transform"},{"location":"xml_syntax/","text":"XML Syntax Documentation \u00a4 Overview \u00a4 This document describes the XML syntax used to define a physical system. The structure includes elements for defining bodies, joints, geometries, simulation parameters, and rendering properties. Root Element \u00a4 <x_xy name= \"example_model\" > ... </x_xy> name (string, required): The name of the model. Simulation Parameters \u00a4 <options gravity= \"0 0 -9.81\" dt= \"0.01\" /> gravity (x y z, optional): Global gravity vector. dt (float, optional): Simulation time step. Default Parameters for geom and body \u00a4 Changes the default values. For example: <defaults> <geom mass= \"1.0\" /> </defaults> mass (float, optional): Default mass of geometries. World Definition \u00a4 <worldbody> <body name= \"base\" joint= \"free\" pos= \"0 0 0\" > ... </body> </worldbody> <worldbody> : The root container for all bodies. <body> : Defines a physical body. name (string, required): Unique identifier for the body. joint (string, required): Type of joint connecting to worldbody. pos (x y z, optional): Position in world coordinates. for more see section Bodies below Geometry Definition and Rendering Properties \u00a4 <geom type= \"box\" mass= \"1\" size= \"0.5 0.5 0.5\" color= \"0.8 0.2 0.2\" /> mass (float, required): Mass of geometry. type (string, required): Shape type ( box , sphere , cylinder , xyz , capsule ). dim (Vector of floats, required): Dimensions of the geometry. Its dimensionality depends on the type of the geometry. box : length_x, length_y, length_z sphere : radius cylinder : radius, height xyz : unit_vector_length capsule : radius, length color (rgb or string, optional): RGB color (normalised from 0 to 1) of the object or string identifier of a color such as green, blue, red, orange, ... pos (x y z, optional): Position of geometry in coordinate system of surrouning body. Points to the center of mass of the geometry. Defaults to zeros. euler (x y z, optional): Euler angles in degree. Orientation of geometry in coordinate system of surrouning body. Mutually exclusive with field quat . Defaults to zeros. quat (u x y z, optional): Orientation of geometry in coordinate system of surrouning body. Mutually exclusive with field euler . Defaults to 1 0 0 0. Bodies \u00a4 <body name= \"hinge\" joint= \"rx\" pos= \"0 0 1\" euler= \"90 0 0\" /> name (string, required): Identifier for the body. joint (string, required): Type of joint. Possible values: free : 6D free joint cor : 9D free joint, center of rotation also moves free_2d : 3D free joint (1D rotation + 2D translations) frozen : 0D joint spherical : 3D rotational joint px , py , pz (prismatic joints): 1D translational joints around x/y/z rx , ry , rz (revolute joints): 1D rotational joints around x/y/z saddle : 2D rotational joint p3d : 3D translational joint rr (custom joint): 1D rotational joint with randomised joint axis direction rr_imp (custom joint): 1D rotational joint with randomised joint axis direction that is not a perfect 1D joint; there is a small secondary rotation possible rsaddle (custom joint): 2D rotational joint with randomised joint axes directions pos (x y z, optional): Position relative to parent body. Defaults to zeros. euler (x y z, optional): Euler angles in degree. Orientation relative to parent body. Mutually exclusive with field quat . Defaults to zeros. quat (u x y z, optional): Orientation relative to parent body. Mutually exclusive with field euler . Defaults to 1 0 0 0. pos_min (x y z, optional): Lower bound for randomization of the pos value. Defaults to zeros. pos_max (x y z, optional): Upper bound for randomization of the pos value. Defaults to zeros. damping (Vector of floats, optional): Damping of the joint. It's dimensionality depends on the qd size of the joint type. So for a 1D joint, this is a single float, for a 3D joint it is three floats. Defaults to zeros. armature (Vector of floats, optional): Armature of the joint. It's dimensionality depends on the qd size of the joint type. So for a 1D joint, this is a single float, for a 3D joint it is three floats. Defaults to zeros. spring_stiff (Vector of floats, optional): Spring stiffness of the joint. It's dimensionality depends on the qd size. Defaults to zeros. spring_zero (Vector of floats, optional): Zero point for the spring force of the joint. It's dimensionality depends on the q size of the joint type. Defaults to 1 0 0 0 for spherical , cor , and free , and to zeros else. Example Model \u00a4 <x_xy model= \"inv_pendulum\" > <options gravity= \"0 0 9.81\" dt= \"0.01\" /> <defaults> <geom color= \"white\" /> </defaults> <worldbody> <body name= \"cart\" joint= \"px\" damping= \"0.01\" > <geom type= \"box\" mass= \"1\" dim= \"0.4 0.1 0.1\" /> <body name= \"pendulum\" joint= \"ry\" euler= \"0 -90 0\" damping= \"0.01\" > <geom type= \"box\" mass= \"0.5\" pos= \"0.5 0 0\" dim= \"1 0.1 0.1\" /> </body> </body> </worldbody> </x_xy>","title":"XML Syntax Documentation"},{"location":"xml_syntax/#xml-syntax-documentation","text":"","title":"XML Syntax Documentation"},{"location":"xml_syntax/#overview","text":"This document describes the XML syntax used to define a physical system. The structure includes elements for defining bodies, joints, geometries, simulation parameters, and rendering properties.","title":"Overview"},{"location":"xml_syntax/#root-element","text":"<x_xy name= \"example_model\" > ... </x_xy> name (string, required): The name of the model.","title":"Root Element"},{"location":"xml_syntax/#simulation-parameters","text":"<options gravity= \"0 0 -9.81\" dt= \"0.01\" /> gravity (x y z, optional): Global gravity vector. dt (float, optional): Simulation time step.","title":"Simulation Parameters"},{"location":"xml_syntax/#default-parameters-for-geom-and-body","text":"Changes the default values. For example: <defaults> <geom mass= \"1.0\" /> </defaults> mass (float, optional): Default mass of geometries.","title":"Default Parameters for geom and body"},{"location":"xml_syntax/#world-definition","text":"<worldbody> <body name= \"base\" joint= \"free\" pos= \"0 0 0\" > ... </body> </worldbody> <worldbody> : The root container for all bodies. <body> : Defines a physical body. name (string, required): Unique identifier for the body. joint (string, required): Type of joint connecting to worldbody. pos (x y z, optional): Position in world coordinates. for more see section Bodies below","title":"World Definition"},{"location":"xml_syntax/#geometry-definition-and-rendering-properties","text":"<geom type= \"box\" mass= \"1\" size= \"0.5 0.5 0.5\" color= \"0.8 0.2 0.2\" /> mass (float, required): Mass of geometry. type (string, required): Shape type ( box , sphere , cylinder , xyz , capsule ). dim (Vector of floats, required): Dimensions of the geometry. Its dimensionality depends on the type of the geometry. box : length_x, length_y, length_z sphere : radius cylinder : radius, height xyz : unit_vector_length capsule : radius, length color (rgb or string, optional): RGB color (normalised from 0 to 1) of the object or string identifier of a color such as green, blue, red, orange, ... pos (x y z, optional): Position of geometry in coordinate system of surrouning body. Points to the center of mass of the geometry. Defaults to zeros. euler (x y z, optional): Euler angles in degree. Orientation of geometry in coordinate system of surrouning body. Mutually exclusive with field quat . Defaults to zeros. quat (u x y z, optional): Orientation of geometry in coordinate system of surrouning body. Mutually exclusive with field euler . Defaults to 1 0 0 0.","title":"Geometry Definition and Rendering Properties"},{"location":"xml_syntax/#bodies","text":"<body name= \"hinge\" joint= \"rx\" pos= \"0 0 1\" euler= \"90 0 0\" /> name (string, required): Identifier for the body. joint (string, required): Type of joint. Possible values: free : 6D free joint cor : 9D free joint, center of rotation also moves free_2d : 3D free joint (1D rotation + 2D translations) frozen : 0D joint spherical : 3D rotational joint px , py , pz (prismatic joints): 1D translational joints around x/y/z rx , ry , rz (revolute joints): 1D rotational joints around x/y/z saddle : 2D rotational joint p3d : 3D translational joint rr (custom joint): 1D rotational joint with randomised joint axis direction rr_imp (custom joint): 1D rotational joint with randomised joint axis direction that is not a perfect 1D joint; there is a small secondary rotation possible rsaddle (custom joint): 2D rotational joint with randomised joint axes directions pos (x y z, optional): Position relative to parent body. Defaults to zeros. euler (x y z, optional): Euler angles in degree. Orientation relative to parent body. Mutually exclusive with field quat . Defaults to zeros. quat (u x y z, optional): Orientation relative to parent body. Mutually exclusive with field euler . Defaults to 1 0 0 0. pos_min (x y z, optional): Lower bound for randomization of the pos value. Defaults to zeros. pos_max (x y z, optional): Upper bound for randomization of the pos value. Defaults to zeros. damping (Vector of floats, optional): Damping of the joint. It's dimensionality depends on the qd size of the joint type. So for a 1D joint, this is a single float, for a 3D joint it is three floats. Defaults to zeros. armature (Vector of floats, optional): Armature of the joint. It's dimensionality depends on the qd size of the joint type. So for a 1D joint, this is a single float, for a 3D joint it is three floats. Defaults to zeros. spring_stiff (Vector of floats, optional): Spring stiffness of the joint. It's dimensionality depends on the qd size. Defaults to zeros. spring_zero (Vector of floats, optional): Zero point for the spring force of the joint. It's dimensionality depends on the q size of the joint type. Defaults to 1 0 0 0 for spherical , cor , and free , and to zeros else.","title":"Bodies"},{"location":"xml_syntax/#example-model","text":"<x_xy model= \"inv_pendulum\" > <options gravity= \"0 0 9.81\" dt= \"0.01\" /> <defaults> <geom color= \"white\" /> </defaults> <worldbody> <body name= \"cart\" joint= \"px\" damping= \"0.01\" > <geom type= \"box\" mass= \"1\" dim= \"0.4 0.1 0.1\" /> <body name= \"pendulum\" joint= \"ry\" euler= \"0 -90 0\" damping= \"0.01\" > <geom type= \"box\" mass= \"0.5\" pos= \"0.5 0 0\" dim= \"1 0.1 0.1\" /> </body> </body> </worldbody> </x_xy>","title":"Example Model"},{"location":"notebooks/batched_simulation/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . Batched Dynamical Simulation \u00a4 System object is a registered Jax-PyTree. This means it's a nested array. This enables us to stack multiple systems (or states) to enable vectorized operations. Batched System \u00a4 I.e. simulating two different system with the same initial state. import ring import jax import jax.numpy as jnp xml_str = \"\"\" <x_xy model=\"double_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"2\" euler=\"0 90 0\" joint=\"ry\" name=\"upper\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body damping=\"2\" joint=\"ry\" name=\"lower\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) state = ring . State . create ( sys ) # second system with gravity disabled sys_nograv = sys . replace ( gravity = sys . gravity * 0.0 ) sys_batched = sys . batch ( sys_nograv ) next_state_batched = jax . vmap ( ring . step , in_axes = ( 0 , None ))( sys_batched , state ) # note how the state of the system without gravity has not changed at all next_state_batched . q Array([[0., 0.], [0., 0.]], dtype=float32) Batched State \u00a4 second_state = ring . State . create ( sys , qd = jnp . ones (( 2 ,))) state_batched = state . batch ( second_state ) next_state_batched = jax . vmap ( ring . step , in_axes = ( None , 0 ))( sys , state_batched ) next_state_batched . q Array([[0. , 0. ], [0.01004834, 0.00982152]], dtype=float32) Batched Kinematic Simulation \u00a4 Batched kinematic simulation is done by providing the sizes argument to build_generator batchsize = 8 seed = 1 gen = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), keep_output_extras = True ) . to_lazy_gen ( batchsize ) ( X , y ), ( _ , q , x , _ ) = gen ( jax . random . PRNGKey ( seed )) q . shape (8, 1000, 2)","title":"Batched simulation"},{"location":"notebooks/batched_simulation/#batched-dynamical-simulation","text":"System object is a registered Jax-PyTree. This means it's a nested array. This enables us to stack multiple systems (or states) to enable vectorized operations.","title":"Batched Dynamical Simulation"},{"location":"notebooks/batched_simulation/#batched-system","text":"I.e. simulating two different system with the same initial state. import ring import jax import jax.numpy as jnp xml_str = \"\"\" <x_xy model=\"double_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"2\" euler=\"0 90 0\" joint=\"ry\" name=\"upper\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body damping=\"2\" joint=\"ry\" name=\"lower\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) state = ring . State . create ( sys ) # second system with gravity disabled sys_nograv = sys . replace ( gravity = sys . gravity * 0.0 ) sys_batched = sys . batch ( sys_nograv ) next_state_batched = jax . vmap ( ring . step , in_axes = ( 0 , None ))( sys_batched , state ) # note how the state of the system without gravity has not changed at all next_state_batched . q Array([[0., 0.], [0., 0.]], dtype=float32)","title":"Batched System"},{"location":"notebooks/batched_simulation/#batched-state","text":"second_state = ring . State . create ( sys , qd = jnp . ones (( 2 ,))) state_batched = state . batch ( second_state ) next_state_batched = jax . vmap ( ring . step , in_axes = ( None , 0 ))( sys , state_batched ) next_state_batched . q Array([[0. , 0. ], [0.01004834, 0.00982152]], dtype=float32)","title":"Batched State"},{"location":"notebooks/batched_simulation/#batched-kinematic-simulation","text":"Batched kinematic simulation is done by providing the sizes argument to build_generator batchsize = 8 seed = 1 gen = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), keep_output_extras = True ) . to_lazy_gen ( batchsize ) ( X , y ), ( _ , q , x , _ ) = gen ( jax . random . PRNGKey ( seed )) q . shape (8, 1000, 2)","title":"Batched Kinematic Simulation"},{"location":"notebooks/control/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . Balance an inverted Pendulum on a cart \u00a4 import ring from ring.algorithms.generator.pd_control import _pd_control import jax import jax.numpy as jnp import numpy as np import mediapy as media The step function also takes generalized forces tau applied to the degrees of freedom its third input step(sys, state, taus) . Let's consider an inverted pendulum on a cart, and apply a left-right force onto the cart such that the pole stays in the upright position. xml_str = \"\"\" <x_xy model=\"inv_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"white\" edge_color=\"black\"></geom> </defaults> <worldbody> <body damping=\"0.01\" joint=\"px\" name=\"cart\"> <geom dim=\"0.4 0.1 0.1\" mass=\"1\" type=\"box\"></geom> <body damping=\"0.01\" euler=\"0 -90 0\" joint=\"ry\" name=\"pendulum\"> <geom dim=\"1 0.1 0.1\" mass=\"0.5\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) state = ring . State . create ( sys , q = jnp . array ([ 0.0 , 0.2 ])) xs = [] T = 10.0 for t in range ( int ( T / sys . dt )): measurement_noise = np . random . normal () * 5 phi = jnp . rad2deg ( state . q [ 1 ]) + measurement_noise cart_motor_input = 0.1 * phi * abs ( phi ) taus = jnp . clip ( jnp . array ([ cart_motor_input , 0.0 ]), - 10 , 10 ) state = jax . jit ( ring . step )( sys , state , taus ) xs . append ( state . x ) def show_video ( sys , xs : list [ ring . Transform ]): assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = sys . render ( xs , render_every_nth = 4 , camera = \"c\" , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\"0 -2 2\" target=\"0\"></camera>' }) media . show_video ( frames , fps = 25 ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:02<00:00, 102.28it/s] This browser does not support the video tag. PD Control \u00a4 xml_str = \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"0.01\" euler=\"0 90 0\" joint=\"ry\" name=\"pendulum\" pos=\"0 0 1\"> <geom dim=\"1 0.1 0.1\" mass=\"0.5\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) P , D = jnp . array ([ 10.0 ]), jnp . array ([ 1.0 ]) def simulate_pd_control ( sys , P , D ): controller = _pd_control ( P , D ) # reference signal q_ref = jnp . ones (( 1000 , 1 )) * jnp . pi / 2 controller_state = controller . init ( sys , q_ref ) state = ring . State . create ( sys ) xs = [] T = 5.0 for t in range ( int ( T / sys . dt )): controller_state , taus = jax . jit ( controller . apply )( controller_state , sys , state ) state = jax . jit ( ring . step )( sys , state , taus ) xs . append ( state . x ) return xs xs = simulate_pd_control ( sys , P , D ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:01<00:00, 108.19it/s] This browser does not support the video tag. Note the steady state error. This is because we have gravity and no Integral part (so no PID control). If we remove gravity the steady state error also vanishes (as is expected.) sys_nograv = sys . replace ( gravity = sys . gravity * 0.0 ) xs = simulate_pd_control ( sys_nograv , P , D ) show_video ( sys_nograv , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00<00:00, 166.82it/s] This browser does not support the video tag.","title":"Control"},{"location":"notebooks/control/#balance-an-inverted-pendulum-on-a-cart","text":"import ring from ring.algorithms.generator.pd_control import _pd_control import jax import jax.numpy as jnp import numpy as np import mediapy as media The step function also takes generalized forces tau applied to the degrees of freedom its third input step(sys, state, taus) . Let's consider an inverted pendulum on a cart, and apply a left-right force onto the cart such that the pole stays in the upright position. xml_str = \"\"\" <x_xy model=\"inv_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"white\" edge_color=\"black\"></geom> </defaults> <worldbody> <body damping=\"0.01\" joint=\"px\" name=\"cart\"> <geom dim=\"0.4 0.1 0.1\" mass=\"1\" type=\"box\"></geom> <body damping=\"0.01\" euler=\"0 -90 0\" joint=\"ry\" name=\"pendulum\"> <geom dim=\"1 0.1 0.1\" mass=\"0.5\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) state = ring . State . create ( sys , q = jnp . array ([ 0.0 , 0.2 ])) xs = [] T = 10.0 for t in range ( int ( T / sys . dt )): measurement_noise = np . random . normal () * 5 phi = jnp . rad2deg ( state . q [ 1 ]) + measurement_noise cart_motor_input = 0.1 * phi * abs ( phi ) taus = jnp . clip ( jnp . array ([ cart_motor_input , 0.0 ]), - 10 , 10 ) state = jax . jit ( ring . step )( sys , state , taus ) xs . append ( state . x ) def show_video ( sys , xs : list [ ring . Transform ]): assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = sys . render ( xs , render_every_nth = 4 , camera = \"c\" , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\"0 -2 2\" target=\"0\"></camera>' }) media . show_video ( frames , fps = 25 ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:02<00:00, 102.28it/s] This browser does not support the video tag.","title":"Balance an inverted Pendulum on a cart"},{"location":"notebooks/control/#pd-control","text":"xml_str = \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"0.01\" euler=\"0 90 0\" joint=\"ry\" name=\"pendulum\" pos=\"0 0 1\"> <geom dim=\"1 0.1 0.1\" mass=\"0.5\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) P , D = jnp . array ([ 10.0 ]), jnp . array ([ 1.0 ]) def simulate_pd_control ( sys , P , D ): controller = _pd_control ( P , D ) # reference signal q_ref = jnp . ones (( 1000 , 1 )) * jnp . pi / 2 controller_state = controller . init ( sys , q_ref ) state = ring . State . create ( sys ) xs = [] T = 5.0 for t in range ( int ( T / sys . dt )): controller_state , taus = jax . jit ( controller . apply )( controller_state , sys , state ) state = jax . jit ( ring . step )( sys , state , taus ) xs . append ( state . x ) return xs xs = simulate_pd_control ( sys , P , D ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:01<00:00, 108.19it/s] This browser does not support the video tag. Note the steady state error. This is because we have gravity and no Integral part (so no PID control). If we remove gravity the steady state error also vanishes (as is expected.) sys_nograv = sys . replace ( gravity = sys . gravity * 0.0 ) xs = simulate_pd_control ( sys_nograv , P , D ) show_video ( sys_nograv , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00<00:00, 166.82it/s] This browser does not support the video tag.","title":"PD Control"},{"location":"notebooks/custom_joint_type/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . Defining a custom Joint Type that supports dynamical simulation \u00a4 In this notebook we will define a new joint type that is a hinge joint with a random joint axes direction. It will also support dynamical simulation . import ring from ring import maths , base import jax import jax.numpy as jnp import mediapy as media from ring.algorithms.jcalc import _draw_rxyz We will give this new joint type the identifier rr (random revolute). Although it actually already exists in the library, but we can overwrite it. # we use such a `params` input to specify the joint-axes, if we later then randomize the attribute of the system object # we will have the effect of a hinge joint with a randomized joint axes direction # here we tell the library how it should initialize this `params` PyTree def _draw_random_joint_axis ( key ): return maths . rotate ( jnp . array ([ 1.0 , 0 , 0 ]), maths . quat_random ( key )) def _rr_init_joint_params ( key ): return dict ( joint_axes = _draw_random_joint_axis ( key )) # next, we tell the library how it can randomly draw a trajectory for its generalized coordinate; the hinge joint angle def _rr_transform ( q , params ): # here we use this `params` object axis = params [ \"joint_axes\" ] q = jnp . squeeze ( q ) rot = maths . quat_rot_axis ( axis , q ) return ring . Transform . create ( rot = rot ) # this tells the library how to dynamically simulate the type of joint def _motion_fn ( params ): return base . Motion . create ( ang = params [ \"joint_axes\" ]) # now, we can put it all together into a new `x_xy.JointModel` rr_joint = ring . JointModel ( _rr_transform , motion = [ _motion_fn ], rcmg_draw_fn = _draw_rxyz , init_joint_params = _rr_init_joint_params ) # and then we register the joint; Note that `overwrite`=True, because it already exists; that way you can e.g. overwrite the # default joint types such as the free joint ring . register_new_joint_type ( \"rr\" , rr_joint , q_width = 1 , qd_width = 1 , overwrite = True ) xml_str = \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <geom dim=\"0.1\" type=\"xyz\"></geom> <body damping=\".01\" joint=\"rr\" name=\"pendulum\" pos=\"0 0 0.5\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.5 0.1 0.1\" mass=\"0.5\" pos=\"0.25 0 0\" type=\"box\"></geom> </body> </worldbody> </x_xy> \"\"\" # this seed determines (among other things) the randomness of the joint-axes direction # via the above specified `_rr_init_joint_params` seed : int = 2 sys = ring . System . create ( xml_str , seed = seed ) state = ring . State . create ( sys ) xs = [] for t in range ( 500 ): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) sys . links . joint_params {'rr': {'joint_axes': Array([[ 0.41278404, -0.6329913 , 0.65492845]], dtype=float32)}, 'default': Array([], shape=(1, 0), dtype=float32)} def show_video ( sys , xs : list [ ring . Transform ]): frames = sys . render ( xs , render_every_nth = 4 ) media . show_video ( frames , fps = 25 ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:01<00:00, 94.24it/s] This browser does not support the video tag. the class x_xy.RCMG already has the built-in flag randomize_joint_params which can be toggled in order to use the user-provided logic _rr_init_joint_params for randomizing the joint parameters ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , randomize_joint_params = True , keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:02<00:00, 2.70s/it] show_video ( sys , x ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1500/1500 [00:14<00:00, 103.09it/s] This browser does not support the video tag. but for dynamic_simulation flag to work we additional need to specify the function ring.JointModel.p_control_term print ( rr_joint . p_control_term ) None try : ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , randomize_joint_params = True , keep_output_extras = True , dynamic_simulation = True ) . to_list ()[ 0 ] except NotImplementedError : print ( \"NotImplementedError: Please specify `JointModel.p_control_term` for joint type `rr`\" ) executing generators: 0%| | 0/1 [00:00<?, ?it/s] NotImplementedError: Please specify `JointModel.p_control_term` for joint type `rr`","title":"Custom joint type"},{"location":"notebooks/custom_joint_type/#defining-a-custom-joint-type-that-supports-dynamical-simulation","text":"In this notebook we will define a new joint type that is a hinge joint with a random joint axes direction. It will also support dynamical simulation . import ring from ring import maths , base import jax import jax.numpy as jnp import mediapy as media from ring.algorithms.jcalc import _draw_rxyz We will give this new joint type the identifier rr (random revolute). Although it actually already exists in the library, but we can overwrite it. # we use such a `params` input to specify the joint-axes, if we later then randomize the attribute of the system object # we will have the effect of a hinge joint with a randomized joint axes direction # here we tell the library how it should initialize this `params` PyTree def _draw_random_joint_axis ( key ): return maths . rotate ( jnp . array ([ 1.0 , 0 , 0 ]), maths . quat_random ( key )) def _rr_init_joint_params ( key ): return dict ( joint_axes = _draw_random_joint_axis ( key )) # next, we tell the library how it can randomly draw a trajectory for its generalized coordinate; the hinge joint angle def _rr_transform ( q , params ): # here we use this `params` object axis = params [ \"joint_axes\" ] q = jnp . squeeze ( q ) rot = maths . quat_rot_axis ( axis , q ) return ring . Transform . create ( rot = rot ) # this tells the library how to dynamically simulate the type of joint def _motion_fn ( params ): return base . Motion . create ( ang = params [ \"joint_axes\" ]) # now, we can put it all together into a new `x_xy.JointModel` rr_joint = ring . JointModel ( _rr_transform , motion = [ _motion_fn ], rcmg_draw_fn = _draw_rxyz , init_joint_params = _rr_init_joint_params ) # and then we register the joint; Note that `overwrite`=True, because it already exists; that way you can e.g. overwrite the # default joint types such as the free joint ring . register_new_joint_type ( \"rr\" , rr_joint , q_width = 1 , qd_width = 1 , overwrite = True ) xml_str = \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <geom dim=\"0.1\" type=\"xyz\"></geom> <body damping=\".01\" joint=\"rr\" name=\"pendulum\" pos=\"0 0 0.5\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.5 0.1 0.1\" mass=\"0.5\" pos=\"0.25 0 0\" type=\"box\"></geom> </body> </worldbody> </x_xy> \"\"\" # this seed determines (among other things) the randomness of the joint-axes direction # via the above specified `_rr_init_joint_params` seed : int = 2 sys = ring . System . create ( xml_str , seed = seed ) state = ring . State . create ( sys ) xs = [] for t in range ( 500 ): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) sys . links . joint_params {'rr': {'joint_axes': Array([[ 0.41278404, -0.6329913 , 0.65492845]], dtype=float32)}, 'default': Array([], shape=(1, 0), dtype=float32)} def show_video ( sys , xs : list [ ring . Transform ]): frames = sys . render ( xs , render_every_nth = 4 ) media . show_video ( frames , fps = 25 ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:01<00:00, 94.24it/s] This browser does not support the video tag. the class x_xy.RCMG already has the built-in flag randomize_joint_params which can be toggled in order to use the user-provided logic _rr_init_joint_params for randomizing the joint parameters ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , randomize_joint_params = True , keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:02<00:00, 2.70s/it] show_video ( sys , x ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1500/1500 [00:14<00:00, 103.09it/s] This browser does not support the video tag. but for dynamic_simulation flag to work we additional need to specify the function ring.JointModel.p_control_term print ( rr_joint . p_control_term ) None try : ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , randomize_joint_params = True , keep_output_extras = True , dynamic_simulation = True ) . to_list ()[ 0 ] except NotImplementedError : print ( \"NotImplementedError: Please specify `JointModel.p_control_term` for joint type `rr`\" ) executing generators: 0%| | 0/1 [00:00<?, ?it/s] NotImplementedError: Please specify `JointModel.p_control_term` for joint type `rr`","title":"Defining a custom Joint Type that supports dynamical simulation"},{"location":"notebooks/error_quaternion/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . The error quaternion (required for ML purposes) \u00a4 In this notebook we will talk about what functions you need to do ML with quaternions. After all the purpose of this library is to create training data. Typically, this involves quaternions as target values (to be predicted), similar to an orientation estimation filter (like VQF). So, suppose you want to train some ML model that predicts a quaternion \\(\\hat{q} = f_\\theta(X)\\) . import ring import jax import jax.numpy as jnp import matplotlib.pyplot as plt How to get a quaternion as network output? \u00a4 That's easy enough. You normalize a four dimensional vector. # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X norm = jnp . linalg . norm ( q_unnormalized ) return q_unnormalized / norm def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 But this is dangerous as this might lead to NaNs. X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(nan, dtype=float32) We could try to fix is by adding a small number in the divison. # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X norm = jnp . linalg . norm ( q_unnormalized ) eps = 1e-8 return q_unnormalized / ( norm + eps ) def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(0., dtype=float32) But, still the gradient required for backpropagation gives NaNs. jax . grad ( loss_fn )( params , X , y ) Array([[nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan]], dtype=float32) The solution is a little involved. TLDR; Use x_xy.maths.safe_normalize # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X return ring . maths . safe_normalize ( q_unnormalized ) def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(0., dtype=float32) jax . grad ( loss_fn )( params , X , y ) Array([[0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.]], dtype=float32) A closer look at the function x_xy.maths.angle_error \u00a4 Let's take a closer look at the function x_xy.maths.angle_error which was used in the loss_fn in the above. What is the behaviour of the error function (sort of the metric) between two quaternions as one approaches the other? A first implementation might look like this: def quat_error ( q , qhat ): q_error = ring . maths . quat_mul ( ring . maths . quat_inv ( q ), qhat ) phi = 2 * jnp . arccos ( q_error [ 0 ]) return jnp . abs ( phi ) Let's reduce this function to the critical operation phi = ... and let's assume, without loss of generality, that the target quaternion is the identity quaternion. Then, this effectively becomes about extracting the angle from a quaternion safely. def quat_angle ( q ): return 2 * jnp . arccos ( q [ 0 ]) input_angles = jnp . linspace ( - 0.005 , 0.005 , num = 1000 ) def input_to_output_angles_incorrect ( angle ): q = ring . maths . quat_rot_axis ( jnp . array ([ 1.0 , 0 , 0 ]), angle ) return quat_angle ( q ) def input_to_output_angles_correct ( angle ): q = ring . maths . quat_rot_axis ( jnp . array ([ 1.0 , 0 , 0 ]), angle ) return ring . maths . quat_angle ( q ) plt . plot ( input_angles , jax . vmap ( input_to_output_angles_incorrect )( input_angles ), label = \"incorrect\" ) plt . plot ( input_angles , jax . vmap ( input_to_output_angles_correct )( input_angles ), label = \"correct\" ) plt . legend () plt . show () As one might expect, the gradients are also much more stable. plt . plot ( input_angles , jax . vmap ( jax . grad ( input_to_output_angles_incorrect ))( input_angles ), label = \"incorrect\" ) plt . plot ( input_angles , jax . vmap ( jax . grad ( input_to_output_angles_correct ))( input_angles ), label = \"correct\" ) plt . legend () plt . show () Pytorch library for quaternion operations \u00a4 These functions are for JAX, but the following should work for PyTorch -> https://naver.github.io/roma/","title":"Error quaternion"},{"location":"notebooks/error_quaternion/#the-error-quaternion-required-for-ml-purposes","text":"In this notebook we will talk about what functions you need to do ML with quaternions. After all the purpose of this library is to create training data. Typically, this involves quaternions as target values (to be predicted), similar to an orientation estimation filter (like VQF). So, suppose you want to train some ML model that predicts a quaternion \\(\\hat{q} = f_\\theta(X)\\) . import ring import jax import jax.numpy as jnp import matplotlib.pyplot as plt","title":"The error quaternion (required for ML purposes)"},{"location":"notebooks/error_quaternion/#how-to-get-a-quaternion-as-network-output","text":"That's easy enough. You normalize a four dimensional vector. # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X norm = jnp . linalg . norm ( q_unnormalized ) return q_unnormalized / norm def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 But this is dangerous as this might lead to NaNs. X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(nan, dtype=float32) We could try to fix is by adding a small number in the divison. # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X norm = jnp . linalg . norm ( q_unnormalized ) eps = 1e-8 return q_unnormalized / ( norm + eps ) def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(0., dtype=float32) But, still the gradient required for backpropagation gives NaNs. jax . grad ( loss_fn )( params , X , y ) Array([[nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan]], dtype=float32) The solution is a little involved. TLDR; Use x_xy.maths.safe_normalize # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X return ring . maths . safe_normalize ( q_unnormalized ) def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(0., dtype=float32) jax . grad ( loss_fn )( params , X , y ) Array([[0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.]], dtype=float32)","title":"How to get a quaternion as network output?"},{"location":"notebooks/error_quaternion/#a-closer-look-at-the-function-x_xymathsangle_error","text":"Let's take a closer look at the function x_xy.maths.angle_error which was used in the loss_fn in the above. What is the behaviour of the error function (sort of the metric) between two quaternions as one approaches the other? A first implementation might look like this: def quat_error ( q , qhat ): q_error = ring . maths . quat_mul ( ring . maths . quat_inv ( q ), qhat ) phi = 2 * jnp . arccos ( q_error [ 0 ]) return jnp . abs ( phi ) Let's reduce this function to the critical operation phi = ... and let's assume, without loss of generality, that the target quaternion is the identity quaternion. Then, this effectively becomes about extracting the angle from a quaternion safely. def quat_angle ( q ): return 2 * jnp . arccos ( q [ 0 ]) input_angles = jnp . linspace ( - 0.005 , 0.005 , num = 1000 ) def input_to_output_angles_incorrect ( angle ): q = ring . maths . quat_rot_axis ( jnp . array ([ 1.0 , 0 , 0 ]), angle ) return quat_angle ( q ) def input_to_output_angles_correct ( angle ): q = ring . maths . quat_rot_axis ( jnp . array ([ 1.0 , 0 , 0 ]), angle ) return ring . maths . quat_angle ( q ) plt . plot ( input_angles , jax . vmap ( input_to_output_angles_incorrect )( input_angles ), label = \"incorrect\" ) plt . plot ( input_angles , jax . vmap ( input_to_output_angles_correct )( input_angles ), label = \"correct\" ) plt . legend () plt . show () As one might expect, the gradients are also much more stable. plt . plot ( input_angles , jax . vmap ( jax . grad ( input_to_output_angles_incorrect ))( input_angles ), label = \"incorrect\" ) plt . plot ( input_angles , jax . vmap ( jax . grad ( input_to_output_angles_correct ))( input_angles ), label = \"correct\" ) plt . legend () plt . show ()","title":"A closer look at the function x_xy.maths.angle_error"},{"location":"notebooks/error_quaternion/#pytorch-library-for-quaternion-operations","text":"These functions are for JAX, but the following should work for PyTorch -> https://naver.github.io/roma/","title":"Pytorch library for quaternion operations"},{"location":"notebooks/experimental_data/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . Loading and working with experimental data \u00a4 import ring import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media def show_video ( sys : ring . System , xs : ring . Transform ) -& gt ; None : assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = sys . render ( xs , camera = \"c\" , height = 480 , width = 640 , render_every_nth = 4 , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\".5 -.5 1.25\" target=\"3\"></camera>' }) media . show_video ( frames , fps = 25 ) Experimental data and system definitions of the experimental setup are located in.. from diodem import load_data , benchmark Multiple experimental trials are available. They have exp_id s and motion_start s and motion_stop s # inertial motion tracking problem (IMTP) exp_id = 1 imtp = benchmark . IMTP ([ f \"seg { i } \" for i in range ( 1 , 6 )]) sys = imtp . sys ( exp_id ) Let's first take a look at the system that was used in the experiments. state = ring . State . create ( sys ) # update the maximal coordinates xs = ring . algorithms . forward_kinematics ( sys , state )[ 1 ] . x show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00, 6.64it/s] This browser does not support the video tag. As you can see a five segment kinematic chain was moved, and for each segment IMU measurements and OMC ground truth is available. Let's load this (no simulated) IMU and OMC data. # `canonical` is the identifier of the first motion pattern performed in this trial # `shaking` is the identifier of the last motion pattern performed in this trial motion_start = \"canonical\" data = load_data ( exp_id , motion_start = motion_start ) data . keys () dict_keys(['seg1', 'seg2', 'seg3', 'seg4', 'seg5']) data [ \"seg1\" ] . keys () dict_keys(['imu_nonrigid', 'imu_rigid', 'marker1', 'marker2', 'marker3', 'marker4', 'quat']) data [ \"seg1\" ][ \"imu_rigid\" ] . keys () dict_keys(['acc', 'gyr', 'mag']) The quaternion quat is to be interpreted as the rotation from segment to an arbitrary OMC inertial frame. The position marker1 is to be interpreted as the position vector from arbitrary OMC inertial frame to a specific marker (marker 1) on the respective segment (vector given in the OMC inertial frame). Then, for each segment actually two IMUs are attached to it. One is rigidly attached, one is non-rigidly attached (via foam). Also, how long is the trial? data [ \"seg1\" ][ \"marker1\" ] . shape (14200, 3) It's 325 seconds of data. Let's take a look at the motion of the whole trial. To render it, we need maximal coordinates xs of all links in the system. X , y , xs , xs_noimu = benchmark . benchmark ( imtp , exp_id , motion_start ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3550/3550 [00:33<00:00, 104.73it/s] This browser does not support the video tag. Perfect. This is a rendered animation of the real experimental motion that was performed. You can see that the spacing between segments is not perfect. This is because in our idealistic system model joints have no spatial dimension but in reality they have. The entire setup is 3D printed, and the joints are also several centimeters long. The segments are 20cm long. We can use this experimental data to validate our simulated approaches or validate ML models that are learned on simulated training data.","title":"Experimental data"},{"location":"notebooks/experimental_data/#loading-and-working-with-experimental-data","text":"import ring import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media def show_video ( sys : ring . System , xs : ring . Transform ) -& gt ; None : assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = sys . render ( xs , camera = \"c\" , height = 480 , width = 640 , render_every_nth = 4 , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\".5 -.5 1.25\" target=\"3\"></camera>' }) media . show_video ( frames , fps = 25 ) Experimental data and system definitions of the experimental setup are located in.. from diodem import load_data , benchmark Multiple experimental trials are available. They have exp_id s and motion_start s and motion_stop s # inertial motion tracking problem (IMTP) exp_id = 1 imtp = benchmark . IMTP ([ f \"seg { i } \" for i in range ( 1 , 6 )]) sys = imtp . sys ( exp_id ) Let's first take a look at the system that was used in the experiments. state = ring . State . create ( sys ) # update the maximal coordinates xs = ring . algorithms . forward_kinematics ( sys , state )[ 1 ] . x show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00, 6.64it/s] This browser does not support the video tag. As you can see a five segment kinematic chain was moved, and for each segment IMU measurements and OMC ground truth is available. Let's load this (no simulated) IMU and OMC data. # `canonical` is the identifier of the first motion pattern performed in this trial # `shaking` is the identifier of the last motion pattern performed in this trial motion_start = \"canonical\" data = load_data ( exp_id , motion_start = motion_start ) data . keys () dict_keys(['seg1', 'seg2', 'seg3', 'seg4', 'seg5']) data [ \"seg1\" ] . keys () dict_keys(['imu_nonrigid', 'imu_rigid', 'marker1', 'marker2', 'marker3', 'marker4', 'quat']) data [ \"seg1\" ][ \"imu_rigid\" ] . keys () dict_keys(['acc', 'gyr', 'mag']) The quaternion quat is to be interpreted as the rotation from segment to an arbitrary OMC inertial frame. The position marker1 is to be interpreted as the position vector from arbitrary OMC inertial frame to a specific marker (marker 1) on the respective segment (vector given in the OMC inertial frame). Then, for each segment actually two IMUs are attached to it. One is rigidly attached, one is non-rigidly attached (via foam). Also, how long is the trial? data [ \"seg1\" ][ \"marker1\" ] . shape (14200, 3) It's 325 seconds of data. Let's take a look at the motion of the whole trial. To render it, we need maximal coordinates xs of all links in the system. X , y , xs , xs_noimu = benchmark . benchmark ( imtp , exp_id , motion_start ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3550/3550 [00:33<00:00, 104.73it/s] This browser does not support the video tag. Perfect. This is a rendered animation of the real experimental motion that was performed. You can see that the spacing between segments is not perfect. This is because in our idealistic system model joints have no spatial dimension but in reality they have. The entire setup is 3D printed, and the joints are also several centimeters long. The segments are 20cm long. We can use this experimental data to validate our simulated approaches or validate ML models that are learned on simulated training data.","title":"Loading and working with experimental data"},{"location":"notebooks/getting_started/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install --quiet imt-ring\" ) os . system ( \"pip install --quiet matplotlib\" ) import ring # automatically detects colab or not ring . utils . setup_colab_env () import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media Systems are defined with the following xml syntax. xml_str = \"\"\" <x_xy model=\"double_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"2\" euler=\"0 90 0\" joint=\"ry\" name=\"upper\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body damping=\"2\" joint=\"ry\" name=\"lower\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" With this xml description of the system, we are ready to load the system using load_sys_from_str . We can also save this to a text-file double_pendulum.xml and load with load_sys_from_xml . sys = ring . System . create ( xml_str ) sys . model_name 'double_pendulum' System objects have many attributes. You may refer to the API documentation for more details. sys . link_names ['upper', 'lower'] Dynamical Simulation \u00a4 Let's start with the most obvious. A physical simulation. We refer to it as \"dynamical simulation\", in contrast to what we do a little later which is a purely kinematic simulation. First, we have to create the dynamical state of the system. It is defined by the all degrees of freedom in the system and their velocities. Here, we have two revolute joints (one degree of freedom). Thus, the minimal coordinates vector \\(q\\) and minimal velocity vector \\(q'\\) has two dimensions. state = ring . State . create ( sys ) state . q Array([0., 0.], dtype=float32) state . qd Array([0., 0.], dtype=float32) next_state = ring . step ( sys , state ) Massive speedups if we use jax.jit to jit-compile the function. % timeit ring . step ( sys , state ) 193 ms \u00b1 10.9 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) % timeit jax . jit ( ring . step )( sys , state ) 104 \u00b5s \u00b1 53.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) Let's unroll the dynamics for multiple timesteps. T = 10.0 xs = [] for _ in range ( int ( T / sys . dt )): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) Next, let's render the frames and create an animation. frames = sys . render ( xs , camera = \"targetfar\" ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.09it/s] def show_video ( frames : list [ np . ndarray ], dt : float ): assert dt == 0.01 # frames are at 100 Hz, but let's create an animation at 25Hz media . show_video ([ frames [ i ][ ... , : 3 ] for i in range ( 0 , len ( frames ), 4 )], fps = 25 ) show_video ( frames , sys . dt ) This browser does not support the video tag. Hmm, pretty boring. Let's get the pendulum into an configuration with some potential energy. All we have to change is the initial state state.q . state = ring . State . create ( sys , q = jnp . array ([ jnp . pi / 2 , 0 ])) T = 10.0 xs = [] for _ in range ( int ( T / sys . dt )): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) frames = sys . render ( xs , camera = \"targetfar\" ) show_video ( frames , sys . dt ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.34it/s] This browser does not support the video tag. That's more like it! Next, we will take a look at \"kinematic simulation\". Kinematic Simulation \u00a4 Let's start with why you would want this. Imagine we want to learn a filter that estimates some quantity of interest from some sensor input. Then, we could try to create many random motions, record the measured sensor input, and the ground truth quantity of interest target values. This is then used as training data for a Machine Learning model. The general interface to kinematic simulation is via x_xy.RCMG . This class can then create - a function (of type Generator ) that maps a PRNG seed to, e.g., X, y data. - a list of data - data on disk (saved via pickle or hdf5) ( X , y ), ( key , q , xs , _ ) = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:02<00:00, 2.57s/it] frames = sys . render ( xs , camera = \"targetfar\" ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.98it/s] This is now completely random, but unphysical motion. It's only kinematics, but that is okay for creating training data. show_video ( frames , sys . dt ) This browser does not support the video tag. X, y Training data / Attaching sensors \u00a4 We are interested in simulating IMU data as input X , and estimating quaternions as target y . We can easily simulate an IMU with only the trajectory of maximal coordinates xs . Suppose, we want to simulate an IMU right that is placed on the lower segment and right at the revolute joint. This is exactly where the coordinate system of the lower segment is placed. Right now the xs trajectory contains both coordinate sytems of upper and lower . # (n_timesteps, n_links, 3) xs . pos . shape (1000, 2, 3) # (n_timesteps, n_links, 4) xs . rot . shape (1000, 2, 4) From the axis with length two, the 0th entry is for upper and the 1st entry is for lower . sys . name_to_idx ( \"upper\" ) 0 sys . name_to_idx ( \"lower\" ) 1 xs_lower = xs . take ( 1 , axis = 1 ) imu_lower = ring . algorithms . imu ( xs_lower , sys . gravity , sys . dt ) imu_lower . keys () dict_keys(['acc', 'gyr']) plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), imu_lower [ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) plt . ylabel ( \"gyro [rad / s]\" ) plt . xlabel ( \"time [s]\" ) plt . legend () plt . show () As you can see it's a two-dimensional problem, which is why only one ( y ) is non-zero. Let's consider a larger kinematic chain in free 3D space. xml_str = \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) data = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), add_X_imus = True , add_y_relpose = True , keep_output_extras = True ) . to_list () # with `keep_output_extras` really everything one could possibly imagine is returned ( X , y ), ( key , qs , xs , sys_mod ) = data [ 0 ] frames = sys . render ( xs , camera = \"targetfar\" ) show_video ( frames , sys . dt ) executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:06<00:00, 6.97s/it] Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 102.55it/s] This browser does not support the video tag. The two orange boxes on segment 1 and segment 3 are modelling our two IMUs. This will be the network's input X data. As target we will try to estimate both relative orientations as y data. X . keys () dict_keys(['seg1', 'seg2', 'seg3']) X [ \"seg1\" ] . keys () dict_keys(['acc', 'gyr']) y . keys () dict_keys(['seg1', 'seg3']) plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), X [ \"seg1\" ][ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) plt . ylabel ( \"gyro [rad / s]\" ) plt . xlabel ( \"time [s]\" ) plt . title ( \"IMU 1 Gyroscope\" ) plt . legend () plt . show () Now, the IMU is non-zero in all three x/y/z components. plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), y [ \"seg1\" ], label = [ \"w\" , \"x\" , \"y\" , \"z\" ]) plt . xlabel ( \"time [s]\" ) plt . title ( \"Relative quaternion from seg2 to seg1\" ) plt . legend () plt . show () Note how the relative quaternion is only around the y-axis. Can you see why? (Hint: Check the defining xml_str .)","title":"Getting started"},{"location":"notebooks/getting_started/#dynamical-simulation","text":"Let's start with the most obvious. A physical simulation. We refer to it as \"dynamical simulation\", in contrast to what we do a little later which is a purely kinematic simulation. First, we have to create the dynamical state of the system. It is defined by the all degrees of freedom in the system and their velocities. Here, we have two revolute joints (one degree of freedom). Thus, the minimal coordinates vector \\(q\\) and minimal velocity vector \\(q'\\) has two dimensions. state = ring . State . create ( sys ) state . q Array([0., 0.], dtype=float32) state . qd Array([0., 0.], dtype=float32) next_state = ring . step ( sys , state ) Massive speedups if we use jax.jit to jit-compile the function. % timeit ring . step ( sys , state ) 193 ms \u00b1 10.9 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) % timeit jax . jit ( ring . step )( sys , state ) 104 \u00b5s \u00b1 53.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) Let's unroll the dynamics for multiple timesteps. T = 10.0 xs = [] for _ in range ( int ( T / sys . dt )): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) Next, let's render the frames and create an animation. frames = sys . render ( xs , camera = \"targetfar\" ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.09it/s] def show_video ( frames : list [ np . ndarray ], dt : float ): assert dt == 0.01 # frames are at 100 Hz, but let's create an animation at 25Hz media . show_video ([ frames [ i ][ ... , : 3 ] for i in range ( 0 , len ( frames ), 4 )], fps = 25 ) show_video ( frames , sys . dt ) This browser does not support the video tag. Hmm, pretty boring. Let's get the pendulum into an configuration with some potential energy. All we have to change is the initial state state.q . state = ring . State . create ( sys , q = jnp . array ([ jnp . pi / 2 , 0 ])) T = 10.0 xs = [] for _ in range ( int ( T / sys . dt )): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) frames = sys . render ( xs , camera = \"targetfar\" ) show_video ( frames , sys . dt ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.34it/s] This browser does not support the video tag. That's more like it! Next, we will take a look at \"kinematic simulation\".","title":"Dynamical Simulation"},{"location":"notebooks/getting_started/#kinematic-simulation","text":"Let's start with why you would want this. Imagine we want to learn a filter that estimates some quantity of interest from some sensor input. Then, we could try to create many random motions, record the measured sensor input, and the ground truth quantity of interest target values. This is then used as training data for a Machine Learning model. The general interface to kinematic simulation is via x_xy.RCMG . This class can then create - a function (of type Generator ) that maps a PRNG seed to, e.g., X, y data. - a list of data - data on disk (saved via pickle or hdf5) ( X , y ), ( key , q , xs , _ ) = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:02<00:00, 2.57s/it] frames = sys . render ( xs , camera = \"targetfar\" ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.98it/s] This is now completely random, but unphysical motion. It's only kinematics, but that is okay for creating training data. show_video ( frames , sys . dt ) This browser does not support the video tag.","title":"Kinematic Simulation"},{"location":"notebooks/getting_started/#x-y-training-data-attaching-sensors","text":"We are interested in simulating IMU data as input X , and estimating quaternions as target y . We can easily simulate an IMU with only the trajectory of maximal coordinates xs . Suppose, we want to simulate an IMU right that is placed on the lower segment and right at the revolute joint. This is exactly where the coordinate system of the lower segment is placed. Right now the xs trajectory contains both coordinate sytems of upper and lower . # (n_timesteps, n_links, 3) xs . pos . shape (1000, 2, 3) # (n_timesteps, n_links, 4) xs . rot . shape (1000, 2, 4) From the axis with length two, the 0th entry is for upper and the 1st entry is for lower . sys . name_to_idx ( \"upper\" ) 0 sys . name_to_idx ( \"lower\" ) 1 xs_lower = xs . take ( 1 , axis = 1 ) imu_lower = ring . algorithms . imu ( xs_lower , sys . gravity , sys . dt ) imu_lower . keys () dict_keys(['acc', 'gyr']) plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), imu_lower [ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) plt . ylabel ( \"gyro [rad / s]\" ) plt . xlabel ( \"time [s]\" ) plt . legend () plt . show () As you can see it's a two-dimensional problem, which is why only one ( y ) is non-zero. Let's consider a larger kinematic chain in free 3D space. xml_str = \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) data = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), add_X_imus = True , add_y_relpose = True , keep_output_extras = True ) . to_list () # with `keep_output_extras` really everything one could possibly imagine is returned ( X , y ), ( key , qs , xs , sys_mod ) = data [ 0 ] frames = sys . render ( xs , camera = \"targetfar\" ) show_video ( frames , sys . dt ) executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:06<00:00, 6.97s/it] Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 102.55it/s] This browser does not support the video tag. The two orange boxes on segment 1 and segment 3 are modelling our two IMUs. This will be the network's input X data. As target we will try to estimate both relative orientations as y data. X . keys () dict_keys(['seg1', 'seg2', 'seg3']) X [ \"seg1\" ] . keys () dict_keys(['acc', 'gyr']) y . keys () dict_keys(['seg1', 'seg3']) plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), X [ \"seg1\" ][ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) plt . ylabel ( \"gyro [rad / s]\" ) plt . xlabel ( \"time [s]\" ) plt . title ( \"IMU 1 Gyroscope\" ) plt . legend () plt . show () Now, the IMU is non-zero in all three x/y/z components. plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), y [ \"seg1\" ], label = [ \"w\" , \"x\" , \"y\" , \"z\" ]) plt . xlabel ( \"time [s]\" ) plt . title ( \"Relative quaternion from seg2 to seg1\" ) plt . legend () plt . show () Note how the relative quaternion is only around the y-axis. Can you see why? (Hint: Check the defining xml_str .)","title":"X, y Training data / Attaching sensors"},{"location":"notebooks/imu_modeling/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); On \"what IMUs measure\" \u00a4 from x_xy.subpkgs import exp import matplotlib.pyplot as plt import jax import x_xy import jax.numpy as jnp hz = 100 markerMap = { \"seg1\" : 2 , \"seg5\" : 2 , \"seg2\" : 1 , \"seg3\" : 2 , \"seg4\" : 4 } def load_data ( seg : str , t1 : float , t2 : float , motion : str = \"fast\" ): data = exp . load_data ( \"S_06\" , motion )[ seg ] # extract a small window from long time series for plotting pos , rot , imu_data = jax . tree_map ( lambda arr : arr [ int ( t1 * hz ): int ( t2 * hz )], ( data [ f \"marker { markerMap [ seg ] } \" ], data [ \"quat\" ], data [ \"imu_rigid\" ])) rot = x_xy . maths . quat_inv ( rot ) # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation xs = x_xy . Transform . create ( pos , rot ) return pos , rot , xs , imu_data t1 , t2 = 3.0 , 9.0 pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 ) Remove gravity from accelerometer to better compare. def linear_acceleration ( xs : x_xy . Transform , acc : jax . Array ) -& gt ; jax . Array : q_E2Imu = xs . rot q_Imu2E = x_xy . maths . quat_inv ( q_E2Imu ) gravity = jnp . array ([ 0 , 0 , 9.81 ]) acc_E_nograv = x_xy . maths . rotate ( acc , q_Imu2E ) - gravity return x_xy . maths . rotate ( acc_E_nograv , q_E2Imu ) imu_data [ \"acc\" ] = linear_acceleration ( xs , imu_data [ \"acc\" ]) Real-world IMU \u00a4 def plot_imu ( imu_data : dict ): imu_data = jax . tree_map ( lambda arr : arr [: - 100 ], imu_data . copy ()) fig , axes = plt . subplots ( 1 , 2 , figsize = ( 12 , 4 )) ts = jnp . arange ( t1 , t2 - 1.0 , step = 1 / hz ) axes [ 0 ] . plot ( ts , imu_data [ \"acc\" ], label = [ \"x\" , \"y\" , \"z\" ]) axes [ 1 ] . plot ( ts , imu_data [ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) for ax in axes : ax . grid () ax . set_xlabel ( \"time [s]\" ) ax . legend () axes [ 0 ] . set_title ( \"Acc\" ) axes [ 1 ] . set_title ( \"Gyr\" ) plot_imu ( imu_data ) Vanilla simulated IMU \u00a4 imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz ) plot_imu ( imu_data ) Accelerometer doesn't look too great! We need low-pass filtering. Two options: Quasi-physical simulation strategy \u00a4 imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz , quasi_physical = True ) plot_imu ( imu_data ) Butterworth filtering \u00a4 imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz , low_pass_filter_pos_f_cutoff = 15.0 , low_pass_filter_rot_alpha = 0.55 ) plot_imu ( imu_data ) Optimize low-pass-filter parameters \u00a4 from scipy.optimize import minimize def optimize_parameters ( seg : str , motion : str ): # include all `fast` data in the optimization t1 , t2 = 0.0 , 500.0 pos , rot , xs , imu_data = load_data ( seg , t1 , t2 , motion ) imu_data [ \"acc\" ] = linear_acceleration ( xs , imu_data [ \"acc\" ]) @jax . jit def objective ( params ): f_cutoff , alpha , offset = params # probably move about 5cm negative x-axis in local CS for e.g. segment 1 pos_offset = x_xy . maths . rotate ( x_xy . maths . rotate ( pos , rot ) + jnp . array ([ offset , 0 , 0 ]), x_xy . maths . quat_inv ( rot )) xs_offset = xs . replace ( pos = pos_offset ) imu = x_xy . imu ( xs_offset , jnp . zeros (( 3 ,)), 1 / hz , low_pass_filter_pos_f_cutoff = f_cutoff , low_pass_filter_rot_alpha = alpha ) return jnp . mean (( imu_data [ \"acc\" ] - imu [ \"acc\" ]) ** 2 ) + jnp . mean (( imu_data [ \"gyr\" ] - imu [ \"gyr\" ]) ** 2 ) return minimize ( objective , jnp . array ([ 5.0 , 1.0 , 0.0 ]), method = \"Nelder-Mead\" ) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"fast\" )) message: Optimization terminated successfully. success: True status: 0 fun: 0.7932413816452026 x: [ 1.135e+01 1.034e+01 1.147e-01] nit: 147 nfev: 287 final_simplex: (array([[ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01]]), array([ 7.932e-01, 7.932e-01, 7.933e-01, 7.933e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.40395233035087585 x: [ 1.123e+01 1.112e+01 1.159e-01] nit: 98 nfev: 198 final_simplex: (array([[ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01]]), array([ 4.040e-01, 4.040e-01, 4.040e-01, 4.040e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.37816864252090454 x: [ 1.190e+01 1.226e+01 1.195e-01] nit: 121 nfev: 238 final_simplex: (array([[ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01]]), array([ 3.782e-01, 3.782e-01, 3.782e-01, 3.782e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.541861355304718 x: [ 1.131e+01 1.372e+01 1.160e-01] nit: 173 nfev: 330 final_simplex: (array([[ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01]]), array([ 5.419e-01, 5.419e-01, 5.419e-01, 5.419e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.6123160123825073 x: [ 1.106e+01 9.883e+00 1.211e-01] nit: 102 nfev: 202 final_simplex: (array([[ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01]]), array([ 6.123e-01, 6.123e-01, 6.123e-01, 6.123e-01])) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"slow1\" )) message: Optimization terminated successfully. success: True status: 0 fun: 0.09304095804691315 x: [ 9.910e+00 3.885e-01 1.136e-01] nit: 111 nfev: 211 final_simplex: (array([[ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01]]), array([ 9.304e-02, 9.305e-02, 9.305e-02, 9.305e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.02368384227156639 x: [ 1.008e+01 3.732e-01 1.332e-01] nit: 97 nfev: 190 final_simplex: (array([[ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01]]), array([ 2.368e-02, 2.369e-02, 2.369e-02, 2.369e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.01580578088760376 x: [ 8.666e+00 3.510e-01 1.343e-01] nit: 111 nfev: 219 final_simplex: (array([[ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.667e+00, 3.510e-01, 1.343e-01]]), array([ 1.581e-02, 1.581e-02, 1.581e-02, 1.581e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.01700039766728878 x: [ 8.336e+00 3.602e-01 1.210e-01] nit: 108 nfev: 208 final_simplex: (array([[ 8.336e+00, 3.602e-01, 1.210e-01], [ 8.336e+00, 3.601e-01, 1.210e-01], [ 8.335e+00, 3.601e-01, 1.210e-01], [ 8.335e+00, 3.602e-01, 1.210e-01]]), array([ 1.700e-02, 1.700e-02, 1.700e-02, 1.700e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.10861615836620331 x: [ 6.784e+00 3.782e-01 5.929e-04] nit: 50 nfev: 107 final_simplex: (array([[ 6.784e+00, 3.782e-01, 5.929e-04], [ 6.784e+00, 3.782e-01, 5.930e-04], [ 6.784e+00, 3.782e-01, 5.930e-04], [ 6.784e+00, 3.782e-01, 5.930e-04]]), array([ 1.086e-01, 1.086e-01, 1.086e-01, 1.086e-01]))","title":"Imu modeling"},{"location":"notebooks/imu_modeling/#on-what-imus-measure","text":"from x_xy.subpkgs import exp import matplotlib.pyplot as plt import jax import x_xy import jax.numpy as jnp hz = 100 markerMap = { \"seg1\" : 2 , \"seg5\" : 2 , \"seg2\" : 1 , \"seg3\" : 2 , \"seg4\" : 4 } def load_data ( seg : str , t1 : float , t2 : float , motion : str = \"fast\" ): data = exp . load_data ( \"S_06\" , motion )[ seg ] # extract a small window from long time series for plotting pos , rot , imu_data = jax . tree_map ( lambda arr : arr [ int ( t1 * hz ): int ( t2 * hz )], ( data [ f \"marker { markerMap [ seg ] } \" ], data [ \"quat\" ], data [ \"imu_rigid\" ])) rot = x_xy . maths . quat_inv ( rot ) # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation xs = x_xy . Transform . create ( pos , rot ) return pos , rot , xs , imu_data t1 , t2 = 3.0 , 9.0 pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 ) Remove gravity from accelerometer to better compare. def linear_acceleration ( xs : x_xy . Transform , acc : jax . Array ) -& gt ; jax . Array : q_E2Imu = xs . rot q_Imu2E = x_xy . maths . quat_inv ( q_E2Imu ) gravity = jnp . array ([ 0 , 0 , 9.81 ]) acc_E_nograv = x_xy . maths . rotate ( acc , q_Imu2E ) - gravity return x_xy . maths . rotate ( acc_E_nograv , q_E2Imu ) imu_data [ \"acc\" ] = linear_acceleration ( xs , imu_data [ \"acc\" ])","title":"On \"what IMUs measure\""},{"location":"notebooks/imu_modeling/#real-world-imu","text":"def plot_imu ( imu_data : dict ): imu_data = jax . tree_map ( lambda arr : arr [: - 100 ], imu_data . copy ()) fig , axes = plt . subplots ( 1 , 2 , figsize = ( 12 , 4 )) ts = jnp . arange ( t1 , t2 - 1.0 , step = 1 / hz ) axes [ 0 ] . plot ( ts , imu_data [ \"acc\" ], label = [ \"x\" , \"y\" , \"z\" ]) axes [ 1 ] . plot ( ts , imu_data [ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) for ax in axes : ax . grid () ax . set_xlabel ( \"time [s]\" ) ax . legend () axes [ 0 ] . set_title ( \"Acc\" ) axes [ 1 ] . set_title ( \"Gyr\" ) plot_imu ( imu_data )","title":"Real-world IMU"},{"location":"notebooks/imu_modeling/#vanilla-simulated-imu","text":"imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz ) plot_imu ( imu_data ) Accelerometer doesn't look too great! We need low-pass filtering. Two options:","title":"Vanilla simulated IMU"},{"location":"notebooks/imu_modeling/#quasi-physical-simulation-strategy","text":"imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz , quasi_physical = True ) plot_imu ( imu_data )","title":"Quasi-physical simulation strategy"},{"location":"notebooks/imu_modeling/#butterworth-filtering","text":"imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz , low_pass_filter_pos_f_cutoff = 15.0 , low_pass_filter_rot_alpha = 0.55 ) plot_imu ( imu_data )","title":"Butterworth filtering"},{"location":"notebooks/imu_modeling/#optimize-low-pass-filter-parameters","text":"from scipy.optimize import minimize def optimize_parameters ( seg : str , motion : str ): # include all `fast` data in the optimization t1 , t2 = 0.0 , 500.0 pos , rot , xs , imu_data = load_data ( seg , t1 , t2 , motion ) imu_data [ \"acc\" ] = linear_acceleration ( xs , imu_data [ \"acc\" ]) @jax . jit def objective ( params ): f_cutoff , alpha , offset = params # probably move about 5cm negative x-axis in local CS for e.g. segment 1 pos_offset = x_xy . maths . rotate ( x_xy . maths . rotate ( pos , rot ) + jnp . array ([ offset , 0 , 0 ]), x_xy . maths . quat_inv ( rot )) xs_offset = xs . replace ( pos = pos_offset ) imu = x_xy . imu ( xs_offset , jnp . zeros (( 3 ,)), 1 / hz , low_pass_filter_pos_f_cutoff = f_cutoff , low_pass_filter_rot_alpha = alpha ) return jnp . mean (( imu_data [ \"acc\" ] - imu [ \"acc\" ]) ** 2 ) + jnp . mean (( imu_data [ \"gyr\" ] - imu [ \"gyr\" ]) ** 2 ) return minimize ( objective , jnp . array ([ 5.0 , 1.0 , 0.0 ]), method = \"Nelder-Mead\" ) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"fast\" )) message: Optimization terminated successfully. success: True status: 0 fun: 0.7932413816452026 x: [ 1.135e+01 1.034e+01 1.147e-01] nit: 147 nfev: 287 final_simplex: (array([[ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01]]), array([ 7.932e-01, 7.932e-01, 7.933e-01, 7.933e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.40395233035087585 x: [ 1.123e+01 1.112e+01 1.159e-01] nit: 98 nfev: 198 final_simplex: (array([[ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01]]), array([ 4.040e-01, 4.040e-01, 4.040e-01, 4.040e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.37816864252090454 x: [ 1.190e+01 1.226e+01 1.195e-01] nit: 121 nfev: 238 final_simplex: (array([[ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01]]), array([ 3.782e-01, 3.782e-01, 3.782e-01, 3.782e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.541861355304718 x: [ 1.131e+01 1.372e+01 1.160e-01] nit: 173 nfev: 330 final_simplex: (array([[ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01]]), array([ 5.419e-01, 5.419e-01, 5.419e-01, 5.419e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.6123160123825073 x: [ 1.106e+01 9.883e+00 1.211e-01] nit: 102 nfev: 202 final_simplex: (array([[ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01]]), array([ 6.123e-01, 6.123e-01, 6.123e-01, 6.123e-01])) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"slow1\" )) message: Optimization terminated successfully. success: True status: 0 fun: 0.09304095804691315 x: [ 9.910e+00 3.885e-01 1.136e-01] nit: 111 nfev: 211 final_simplex: (array([[ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01]]), array([ 9.304e-02, 9.305e-02, 9.305e-02, 9.305e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.02368384227156639 x: [ 1.008e+01 3.732e-01 1.332e-01] nit: 97 nfev: 190 final_simplex: (array([[ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01]]), array([ 2.368e-02, 2.369e-02, 2.369e-02, 2.369e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.01580578088760376 x: [ 8.666e+00 3.510e-01 1.343e-01] nit: 111 nfev: 219 final_simplex: (array([[ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.667e+00, 3.510e-01, 1.343e-01]]), array([ 1.581e-02, 1.581e-02, 1.581e-02, 1.581e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.01700039766728878 x: [ 8.336e+00 3.602e-01 1.210e-01] nit: 108 nfev: 208 final_simplex: (array([[ 8.336e+00, 3.602e-01, 1.210e-01], [ 8.336e+00, 3.601e-01, 1.210e-01], [ 8.335e+00, 3.601e-01, 1.210e-01], [ 8.335e+00, 3.602e-01, 1.210e-01]]), array([ 1.700e-02, 1.700e-02, 1.700e-02, 1.700e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.10861615836620331 x: [ 6.784e+00 3.782e-01 5.929e-04] nit: 50 nfev: 107 final_simplex: (array([[ 6.784e+00, 3.782e-01, 5.929e-04], [ 6.784e+00, 3.782e-01, 5.930e-04], [ 6.784e+00, 3.782e-01, 5.930e-04], [ 6.784e+00, 3.782e-01, 5.930e-04]]), array([ 1.086e-01, 1.086e-01, 1.086e-01, 1.086e-01]))","title":"Optimize low-pass-filter parameters"},{"location":"notebooks/knee_angle_tracking/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install -q imt-ring\" ) os . system ( \"pip install -q matplotlib\" ) import ring # automatically detects colab or not ring . utils . setup_colab_env () import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media sys_str = \"\"\" <x_xy model=\"knee\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body euler=\"0 0 140\" joint=\"frozen\" name=\"femur\" pos=\"0 0 0.5\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.05 0.4\" mass=\"1\" pos=\"0 0 -0.2\" type=\"capsule\"></geom> <body joint=\"frozen\" name=\"imu_femur\" pos=\"0 .06 -.2\" pos_max=\".05 .08 -.1\" pos_min=\"-.05 0 -.3\"> <geom dim=\"0.05\" type=\"xyz\"></geom> <geom color=\"orange\" dim=\"0.05 0.02 0.05\" mass=\"0.1\" type=\"box\"></geom> </body> <body damping=\"3\" joint=\"rx\" name=\"tibia\" pos=\"0 0 -0.4\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.04 0.4\" mass=\"1\" pos=\"0 0 -0.2\" type=\"capsule\"></geom> <geom dim=\"0.05 0.15 0.025\" mass=\"0.1\" pos=\"0 0.04 -0.45\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu_tibia\" pos=\"0 0.05 -0.2\" pos_max=\".05 .07 -.1\" pos_min=\"-.05 0 -.3\"> <geom dim=\"0.05\" type=\"xyz\"></geom> <geom color=\"orange\" dim=\"0.05 0.02 0.05\" mass=\"0.1\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" # noqa: E501 sys = ring . System . create ( sys_str ) media . show_image ( sys . render ( width = 640 , height = 480 , camera = \"custom\" , add_cameras = { - 1 : '<camera euler=\"80 0 0\" mode=\"fixed\" name=\"custom\" pos=\"0 -1.8 0.4\"></camera>' })[ 0 ]) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00, 3.86it/s] ( X , _ ), ( _ , qs , xs , _ ) = ring . RCMG ( sys , ring . MotionConfig ( T = 20.0 , t_min = 0.3 , t_max = 1.5 ), keep_output_extras = 1 , add_X_imus = 1 ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:05<00:00, 5.41s/it] media . show_video ( sys . render ( xs , width = 640 , height = 480 , camera = \"custom\" , add_cameras = { - 1 : '<camera euler=\"80 0 0\" mode=\"fixed\" name=\"custom\" pos=\"0 -1.8 0.4\"></camera>' }, render_every_nth = 4 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:04<00:00, 102.34it/s] This browser does not support the video tag. X . keys () dict_keys(['femur', 'tibia']) X [ \"femur\" ] . keys () dict_keys(['acc', 'gyr']) # number of timesteps T = 2000 # graph lam = ( - 1 , 0 ) # number of bodies (excluding IMUs); so tibia and femur N = len ( lam ) ringnet = ring . RING ( lam , None ) X_ring = np . zeros (( T , N , 10 )) X_ring [:, 0 , : 3 ] = X [ \"femur\" ][ \"acc\" ] X_ring [:, 0 , 3 : 6 ] = X [ \"femur\" ][ \"gyr\" ] X_ring [:, 1 , : 3 ] = X [ \"tibia\" ][ \"acc\" ] X_ring [:, 1 , 3 : 6 ] = X [ \"tibia\" ][ \"gyr\" ] # time-delta between timesteps or inverse of sampling rate X_ring [:, :, 9 ] = float ( sys . dt ) # We could assume that we don't know the hinge joint axis direction KNOWN_JOINT_AXIS = True if KNOWN_JOINT_AXIS : # the components 6:9 store the axis direction; here it is rx-joint; Revolute x-axis X_ring [:, 1 , 6 ] = 1.0 quaternions , _ = ringnet . apply ( X_ring , lam = lam ) quaternions . shape # quaternions[:, 0] # inclination: orientation from femur to earth # quaternioins[:, 1] # orientation from tibia to femur (2000, 2, 4) ts = np . arange ( 0 , 20.0 , step = sys . dt ) plt . plot ( ts , ring . maths . quat_angle_constantAxisOverTime ( quaternions [:, 1 ]), label = \"knee angle prediction\" ) plt . plot ( ts , - qs , label = \"knee angle truth\" ) plt . grid () plt . legend () plt . xlabel ( \"Time [s]\" ) plt . ylabel ( \"Knee Angle [rad]\" ) Text(0, 0.5, 'Knee Angle [rad]')","title":"Knee angle tracking"},{"location":"notebooks/knee_joint_translational_dof/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install --quiet 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'\" ) os . system ( \"pip install --quiet mediapy\" ) os . system ( \"pip install --quiet matplotlib\" ) os . system ( \"pip install --quiet dm-haiku\" ) import x_xy # automatically detects colab or not x_xy . utils . setup_colab_env () import jax import jax.numpy as jnp import haiku as hk import mediapy as media import tree_utils Registering a Knee Joint Type \u00a4 MAX_TRANSLATION = 0.1 ROM_MIN_RAD = 0.0 ROM_MAX_RAD = jnp . pi def build_mlp_knee ( key : jax . random . PRNGKey = jax . random . PRNGKey ( 1 )): @hk . without_apply_rng @hk . transform def mlp ( x ): net = hk . nets . MLP ([ 10 , 10 , 2 ], activation = jnp . tanh , w_init = hk . initializers . RandomNormal ()) # normalize the x input; [0, 1] x = ( x + ROM_MIN_RAD ) / ( ROM_MAX_RAD - ROM_MIN_RAD ) # center the x input; [-0.5, 0.5] x = ( x - 0.5 ) return net ( x ) example_q = jnp . zeros (( 1 ,)) params = mlp . init ( key , example_q ) def forward ( params , q : jax . Array ): return jax . nn . sigmoid ( mlp . apply ( params , q )) * MAX_TRANSLATION return params , forward def _knee_init_joint_params ( key ): return build_mlp_knee ( key )[ 0 ] def transform_fn_knee ( q : jax . Array , params : jax . Array ) -& gt ; x_xy . Transform : forward = build_mlp_knee ()[ 1 ] pos = jnp . concatenate (( forward ( params , q ), jnp . array ([ 0.0 ]))) axis = jnp . array ([ 0 , 0 , 1.0 ]) rot = x_xy . maths . quat_rot_axis ( axis , jnp . squeeze ( q )) return x_xy . Transform ( pos , rot ) def draw_fn_knee ( config : x_xy . MotionConfig , key_t , key_value , dt , params ): qs = x_xy . algorithms . jcalc . _draw_rxyz ( config , key_t , key_value , dt , params ) # rom constraints return ( qs / ( 2 * jnp . pi ) + 0.5 ) * ( ROM_MAX_RAD - ROM_MIN_RAD ) + ROM_MIN_RAD x_xy . register_new_joint_type ( \"knee\" , x_xy . JointModel ( transform_fn_knee , rcmg_draw_fn = draw_fn_knee , init_joint_params = _knee_init_joint_params ), 1 , 0 ) HIP_REVOLUTE_JOINT = True xml_str = f \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <geom dim=\"0.15\" type=\"xyz\"></geom> <body euler=\"90 90 0\" joint=\"py\" name=\"_femur\" pos=\"0.5 0.5 0.8\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <body \"frozen\" } \"=\"\" else=\"\" hip_revolute_joint=\"\" if=\"\" joint=\" { \" name=\" femur \" rz\" = \"\" > < geom dim = \"0.1\" type = \"xyz\" ></ geom > < geom dim = \"0.05 0.4\" euler = \"0 90 0\" mass = \"10\" pos = \"0.2 0 0\" type = \"capsule\" ></ geom > < body joint = \"frozen\" name = \"imu1\" pos = \"0.2 0 0.06\" > < geom dim = \"0.05\" type = \"xyz\" ></ geom > < geom color = \"orange\" dim = \"0.05 0.05 0.02\" mass = \"0\" type = \"box\" ></ geom > </ body > < body joint = \"knee\" name = \"tibia\" pos = \"0.4 0 0\" > < geom dim = \"0.1\" type = \"xyz\" ></ geom > < geom dim = \"0.04 0.4\" euler = \"0 90 0\" mass = \"10\" pos = \"0.2 0 0\" type = \"capsule\" ></ geom > < body joint = \"frozen\" name = \"imu2\" pos = \"0.2 0 0.06\" > < geom dim = \"0.05\" type = \"xyz\" ></ geom > < geom color = \"orange\" dim = \"0.05 0.05 0.02\" mass = \"0\" type = \"box\" ></ geom > </ body > < geom dim = \"0.025 0.2 0.05\" mass = \"5.0\" pos = \"0.45 -.1 0\" type = \"box\" ></ geom > </ body > </ body > </ body > </ worldbody > </ x_xy > \"\"\" sys = x_xy.load_sys_from_str(xml_str) def finalize_fn ( key , qs , xs : x_xy . Transform , sys : x_xy . System ): X = {} for imu in [ \"imu1\" , \"imu2\" ]: xs_imu = xs . take ( sys . name_to_idx ( imu ), axis = 1 ) X [ imu ] = {} X [ imu ][ \"pos\" ] = xs_imu . pos X [ imu ][ \"quat\" ] = xs_imu . rot X [ imu ][ \"imu\" ] = x_xy . imu ( xs_imu , sys . gravity , sys . dt ) params = tree_utils . tree_slice ( sys . links . joint_params [ \"knee\" ], sys . name_to_idx ( \"tibia\" )) return qs , xs , X , params data = x_xy . build_generator ( sys , x_xy . MotionConfig ( t_min = 0.1 , t_max = 0.75 , T = 30 ), finalize_fn = finalize_fn , randomize_joint_params = True , eager = True , aslist = True , seed = 1 , sizes = 32 ) eager data generation: 1it [00:07, 7.23s/it] idx = 5 qs , xs , X , params = data [ idx ] import matplotlib.pyplot as plt phi = jnp . linspace ( 0.0 , jnp . pi )[:, None ] # meter -&gt; centimeter trans_x , trans_y = jax . vmap ( lambda arr : build_mlp_knee ()[ 1 ]( params , arr ))( phi ) . T * 100 plt . scatter ( trans_x , trans_y , c = phi , cmap = \"coolwarm\" ) plt . colorbar () plt . grid () plt . xlabel ( \"x translation [cm]\" ) plt . ylabel ( \"y translation [cm]\" ) Text(0, 0.5, 'y translation [cm]') media . show_video ( x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"target\" , width = 1280 , height = 720 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [00:05<00:00, 133.26it/s] This browser does not support the video tag.","title":"Knee joint translational dof"},{"location":"notebooks/knee_joint_translational_dof/#registering-a-knee-joint-type","text":"MAX_TRANSLATION = 0.1 ROM_MIN_RAD = 0.0 ROM_MAX_RAD = jnp . pi def build_mlp_knee ( key : jax . random . PRNGKey = jax . random . PRNGKey ( 1 )): @hk . without_apply_rng @hk . transform def mlp ( x ): net = hk . nets . MLP ([ 10 , 10 , 2 ], activation = jnp . tanh , w_init = hk . initializers . RandomNormal ()) # normalize the x input; [0, 1] x = ( x + ROM_MIN_RAD ) / ( ROM_MAX_RAD - ROM_MIN_RAD ) # center the x input; [-0.5, 0.5] x = ( x - 0.5 ) return net ( x ) example_q = jnp . zeros (( 1 ,)) params = mlp . init ( key , example_q ) def forward ( params , q : jax . Array ): return jax . nn . sigmoid ( mlp . apply ( params , q )) * MAX_TRANSLATION return params , forward def _knee_init_joint_params ( key ): return build_mlp_knee ( key )[ 0 ] def transform_fn_knee ( q : jax . Array , params : jax . Array ) -& gt ; x_xy . Transform : forward = build_mlp_knee ()[ 1 ] pos = jnp . concatenate (( forward ( params , q ), jnp . array ([ 0.0 ]))) axis = jnp . array ([ 0 , 0 , 1.0 ]) rot = x_xy . maths . quat_rot_axis ( axis , jnp . squeeze ( q )) return x_xy . Transform ( pos , rot ) def draw_fn_knee ( config : x_xy . MotionConfig , key_t , key_value , dt , params ): qs = x_xy . algorithms . jcalc . _draw_rxyz ( config , key_t , key_value , dt , params ) # rom constraints return ( qs / ( 2 * jnp . pi ) + 0.5 ) * ( ROM_MAX_RAD - ROM_MIN_RAD ) + ROM_MIN_RAD x_xy . register_new_joint_type ( \"knee\" , x_xy . JointModel ( transform_fn_knee , rcmg_draw_fn = draw_fn_knee , init_joint_params = _knee_init_joint_params ), 1 , 0 ) HIP_REVOLUTE_JOINT = True xml_str = f \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <geom dim=\"0.15\" type=\"xyz\"></geom> <body euler=\"90 90 0\" joint=\"py\" name=\"_femur\" pos=\"0.5 0.5 0.8\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <body \"frozen\" } \"=\"\" else=\"\" hip_revolute_joint=\"\" if=\"\" joint=\" { \" name=\" femur \" rz\" = \"\" > < geom dim = \"0.1\" type = \"xyz\" ></ geom > < geom dim = \"0.05 0.4\" euler = \"0 90 0\" mass = \"10\" pos = \"0.2 0 0\" type = \"capsule\" ></ geom > < body joint = \"frozen\" name = \"imu1\" pos = \"0.2 0 0.06\" > < geom dim = \"0.05\" type = \"xyz\" ></ geom > < geom color = \"orange\" dim = \"0.05 0.05 0.02\" mass = \"0\" type = \"box\" ></ geom > </ body > < body joint = \"knee\" name = \"tibia\" pos = \"0.4 0 0\" > < geom dim = \"0.1\" type = \"xyz\" ></ geom > < geom dim = \"0.04 0.4\" euler = \"0 90 0\" mass = \"10\" pos = \"0.2 0 0\" type = \"capsule\" ></ geom > < body joint = \"frozen\" name = \"imu2\" pos = \"0.2 0 0.06\" > < geom dim = \"0.05\" type = \"xyz\" ></ geom > < geom color = \"orange\" dim = \"0.05 0.05 0.02\" mass = \"0\" type = \"box\" ></ geom > </ body > < geom dim = \"0.025 0.2 0.05\" mass = \"5.0\" pos = \"0.45 -.1 0\" type = \"box\" ></ geom > </ body > </ body > </ body > </ worldbody > </ x_xy > \"\"\" sys = x_xy.load_sys_from_str(xml_str) def finalize_fn ( key , qs , xs : x_xy . Transform , sys : x_xy . System ): X = {} for imu in [ \"imu1\" , \"imu2\" ]: xs_imu = xs . take ( sys . name_to_idx ( imu ), axis = 1 ) X [ imu ] = {} X [ imu ][ \"pos\" ] = xs_imu . pos X [ imu ][ \"quat\" ] = xs_imu . rot X [ imu ][ \"imu\" ] = x_xy . imu ( xs_imu , sys . gravity , sys . dt ) params = tree_utils . tree_slice ( sys . links . joint_params [ \"knee\" ], sys . name_to_idx ( \"tibia\" )) return qs , xs , X , params data = x_xy . build_generator ( sys , x_xy . MotionConfig ( t_min = 0.1 , t_max = 0.75 , T = 30 ), finalize_fn = finalize_fn , randomize_joint_params = True , eager = True , aslist = True , seed = 1 , sizes = 32 ) eager data generation: 1it [00:07, 7.23s/it] idx = 5 qs , xs , X , params = data [ idx ] import matplotlib.pyplot as plt phi = jnp . linspace ( 0.0 , jnp . pi )[:, None ] # meter -&gt; centimeter trans_x , trans_y = jax . vmap ( lambda arr : build_mlp_knee ()[ 1 ]( params , arr ))( phi ) . T * 100 plt . scatter ( trans_x , trans_y , c = phi , cmap = \"coolwarm\" ) plt . colorbar () plt . grid () plt . xlabel ( \"x translation [cm]\" ) plt . ylabel ( \"y translation [cm]\" ) Text(0, 0.5, 'y translation [cm]') media . show_video ( x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"target\" , width = 1280 , height = 720 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [00:05<00:00, 133.26it/s] This browser does not support the video tag.","title":"Registering a Knee Joint Type"},{"location":"notebooks/machine_learning/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install --quiet 'ring @ git+https://github.com/SimiPixel/ring'\" ) import ring # automatically detects colab or not ring . utils . setup_colab_env () import mediapy import jax.numpy as jnp import tree_utils import ring from diodem import benchmark imtp = benchmark . IMTP ([ \"seg2\" , \"seg3\" , \"seg4\" ], sparse = True , joint_axes = True , dt = False ) exp_id = 1 motion = \"fast_slow_fast\" ringnet = ring . RING ( lam = [ - 1 , 0 , 1 ], Ts = 0.01 ) errors , X , y , yhat , xs , xs_noimu = benchmark . benchmark ( imtp , exp_id , motion , ringnet , warmup = 5.0 ) sys = imtp . sys ( exp_id ) frames = sys . render_prediction ( xs , yhat , render_every_nth = 4 , transparent_segment_to_root = False , width = 640 , height = 480 , camera = \"c\" , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\".5 -.5 1.25\" target=\"3\"></camera>' ,}) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 875/875 [00:09<00:00, 93.81it/s] errors {'seg2': {'mae': 2.7917402, 'std': 1.5290443}, 'seg3': {'mae': 6.0479784, 'std': 3.081823}, 'seg4': {'mae': 5.7122917, 'std': 2.900498}} mediapy . show_video ( frames , fps = 25.0 ) This browser does not support the video tag.","title":"Machine learning"},{"location":"notebooks/magnetometer_modeling/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Magnetometer modeling \u00a4 from x_xy.subpkgs import exp import matplotlib.pyplot as plt import jax import x_xy import jax.numpy as jnp import numpy as np hz = 100 markerMap = { \"seg1\" : 2 , \"seg5\" : 2 , \"seg2\" : 1 , \"seg3\" : 2 , \"seg4\" : 4 } def load_data ( seg : str , t1 : float , t2 : float , motion : str = \"fast\" ): data = exp . load_data ( \"S_06\" , motion , resample_to_hz = hz )[ seg ] # extract a small window from long time series for plotting pos , rot , imu_data = jax . tree_map ( lambda arr : arr [ int ( t1 * hz ): int ( t2 * hz )], ( data [ f \"marker { markerMap [ seg ] } \" ], data [ \"quat\" ], data [ \"imu_rigid\" ])) rot = x_xy . maths . quat_inv ( rot ) # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation xs = x_xy . Transform . create ( pos , rot ) return pos , rot , xs , imu_data t1 , t2 = 3.0 , 9.0 pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 ) Real-world Magnetic-field \u00a4 def plot ( * mag_data ): mag_data = jax . tree_map ( lambda arr : arr [: - 100 ], mag_data ) _ , axes = plt . subplots ( 1 , len ( mag_data ), figsize = ( len ( mag_data ) * 6 , 4 )) axes = [ axes ] if not isinstance ( axes , np . ndarray ) else axes ts = jnp . arange ( t1 , t2 - 1.0 , step = 1 / hz ) for i , mag in enumerate ( mag_data ): axes [ i ] . plot ( ts , mag , label = [ \"x\" , \"y\" , \"z\" ]) axes [ i ] . grid () axes [ i ] . set_xlabel ( \"time [s]\" ) axes [ 0 ] . legend () plot ( imu_data [ \"mag\" ]) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , jax . random . PRNGKey ( 1 ), has_magnetometer = True , low_pass_filter_rot_alpha = 0.5 ) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ]) Optimize Magnetic Field Vector \u00a4 from scipy.optimize import minimize def optimize_parameters ( seg : str , motion : str ): t1 , t2 = 0.0 , 500.0 pos , rot , xs , imu_data = load_data ( seg , t1 , t2 , motion ) @jax . jit def objective ( params ): magvec = params #alpha = np.clip(alpha, 0.0, 1.0) imu_sim = x_xy . imu ( xs , jnp . zeros (( 3 ,)), 1 / hz , low_pass_filter_rot_alpha = 0.5 , magvec = magvec , has_magnetometer = True ) return jnp . mean (( imu_data [ \"mag\" ] - imu_sim [ \"mag\" ]) ** 2 ) res = minimize ( objective , jnp . array ([ 0.0 , .7 , - .7 ]), method = \"Nelder-Mead\" ) perfect = np . array ([ 0 , res . x [ 1 ], res . x [ 2 ]]) perfect /= np . linalg . norm ( perfect ) dip_angle = np . arctan2 ( perfect [ 1 ], perfect [ 2 ]) return res . x , np . linalg . norm ( res . x ), np . rad2deg ( dip_angle ) - 90 for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"slow1\" )) (array([-0.05669107, 0.13636727, -0.56856133]), 0.5874282070698279, 76.5125997928424) (array([ 0.02870585, 0.14479726, -0.5529681 ]), 0.5723320607239446, 75.32629421386511) (array([ 0.07342922, 0.27993262, -0.6070893 ]), 0.6725411131056166, 65.24528171284635) (array([ 0.06965261, 0.12674702, -0.66338645]), 0.6789682416674281, 79.18339336223758) (array([-0.02896293, 0.24820061, -0.55680701]), 0.6103084782009606, 65.9747430877396) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"fast\" )) (array([-0.08539633, 0.15602869, -0.49032469]), 0.5215896749593268, 72.34814710540633) (array([ 0.05422703, 0.13053918, -0.2375643 ]), 0.27643777497021754, 61.211650723518005) (array([ 0.17069941, 0.16292433, -0.49904502]), 0.5520222414783663, 71.9195779531855) (array([ 0.03610723, 0.06886188, -0.5142856 ]), 0.5201301476029805, 82.37356382782355) (array([-0.13417971, 0.32559843, -0.40739543]), 0.5385067931956347, 51.36746475752713) Test optimized magnetic field vector pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 , \"fast\" ) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , has_magnetometer = True , low_pass_filter_rot_alpha = 0.56 , magvec = jnp . array ([ - 0.08957149 , 0.17059967 , - 0.59387128 ])) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ]) pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 , \"slow1\" ) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , has_magnetometer = True , low_pass_filter_rot_alpha = 0.5 , magvec = jnp . array ([ - 0.05896413 , 0.14859727 , - 0.6037423 ]), noisy = True , key = jax . random . PRNGKey ( 7 )) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ])","title":"Magnetometer modeling"},{"location":"notebooks/magnetometer_modeling/#magnetometer-modeling","text":"from x_xy.subpkgs import exp import matplotlib.pyplot as plt import jax import x_xy import jax.numpy as jnp import numpy as np hz = 100 markerMap = { \"seg1\" : 2 , \"seg5\" : 2 , \"seg2\" : 1 , \"seg3\" : 2 , \"seg4\" : 4 } def load_data ( seg : str , t1 : float , t2 : float , motion : str = \"fast\" ): data = exp . load_data ( \"S_06\" , motion , resample_to_hz = hz )[ seg ] # extract a small window from long time series for plotting pos , rot , imu_data = jax . tree_map ( lambda arr : arr [ int ( t1 * hz ): int ( t2 * hz )], ( data [ f \"marker { markerMap [ seg ] } \" ], data [ \"quat\" ], data [ \"imu_rigid\" ])) rot = x_xy . maths . quat_inv ( rot ) # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation xs = x_xy . Transform . create ( pos , rot ) return pos , rot , xs , imu_data t1 , t2 = 3.0 , 9.0 pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 )","title":"Magnetometer modeling"},{"location":"notebooks/magnetometer_modeling/#real-world-magnetic-field","text":"def plot ( * mag_data ): mag_data = jax . tree_map ( lambda arr : arr [: - 100 ], mag_data ) _ , axes = plt . subplots ( 1 , len ( mag_data ), figsize = ( len ( mag_data ) * 6 , 4 )) axes = [ axes ] if not isinstance ( axes , np . ndarray ) else axes ts = jnp . arange ( t1 , t2 - 1.0 , step = 1 / hz ) for i , mag in enumerate ( mag_data ): axes [ i ] . plot ( ts , mag , label = [ \"x\" , \"y\" , \"z\" ]) axes [ i ] . grid () axes [ i ] . set_xlabel ( \"time [s]\" ) axes [ 0 ] . legend () plot ( imu_data [ \"mag\" ]) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , jax . random . PRNGKey ( 1 ), has_magnetometer = True , low_pass_filter_rot_alpha = 0.5 ) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ])","title":"Real-world Magnetic-field"},{"location":"notebooks/magnetometer_modeling/#optimize-magnetic-field-vector","text":"from scipy.optimize import minimize def optimize_parameters ( seg : str , motion : str ): t1 , t2 = 0.0 , 500.0 pos , rot , xs , imu_data = load_data ( seg , t1 , t2 , motion ) @jax . jit def objective ( params ): magvec = params #alpha = np.clip(alpha, 0.0, 1.0) imu_sim = x_xy . imu ( xs , jnp . zeros (( 3 ,)), 1 / hz , low_pass_filter_rot_alpha = 0.5 , magvec = magvec , has_magnetometer = True ) return jnp . mean (( imu_data [ \"mag\" ] - imu_sim [ \"mag\" ]) ** 2 ) res = minimize ( objective , jnp . array ([ 0.0 , .7 , - .7 ]), method = \"Nelder-Mead\" ) perfect = np . array ([ 0 , res . x [ 1 ], res . x [ 2 ]]) perfect /= np . linalg . norm ( perfect ) dip_angle = np . arctan2 ( perfect [ 1 ], perfect [ 2 ]) return res . x , np . linalg . norm ( res . x ), np . rad2deg ( dip_angle ) - 90 for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"slow1\" )) (array([-0.05669107, 0.13636727, -0.56856133]), 0.5874282070698279, 76.5125997928424) (array([ 0.02870585, 0.14479726, -0.5529681 ]), 0.5723320607239446, 75.32629421386511) (array([ 0.07342922, 0.27993262, -0.6070893 ]), 0.6725411131056166, 65.24528171284635) (array([ 0.06965261, 0.12674702, -0.66338645]), 0.6789682416674281, 79.18339336223758) (array([-0.02896293, 0.24820061, -0.55680701]), 0.6103084782009606, 65.9747430877396) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"fast\" )) (array([-0.08539633, 0.15602869, -0.49032469]), 0.5215896749593268, 72.34814710540633) (array([ 0.05422703, 0.13053918, -0.2375643 ]), 0.27643777497021754, 61.211650723518005) (array([ 0.17069941, 0.16292433, -0.49904502]), 0.5520222414783663, 71.9195779531855) (array([ 0.03610723, 0.06886188, -0.5142856 ]), 0.5201301476029805, 82.37356382782355) (array([-0.13417971, 0.32559843, -0.40739543]), 0.5385067931956347, 51.36746475752713) Test optimized magnetic field vector pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 , \"fast\" ) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , has_magnetometer = True , low_pass_filter_rot_alpha = 0.56 , magvec = jnp . array ([ - 0.08957149 , 0.17059967 , - 0.59387128 ])) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ]) pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 , \"slow1\" ) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , has_magnetometer = True , low_pass_filter_rot_alpha = 0.5 , magvec = jnp . array ([ - 0.05896413 , 0.14859727 , - 0.6037423 ]), noisy = True , key = jax . random . PRNGKey ( 7 )) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ])","title":"Optimize Magnetic Field Vector"},{"location":"notebooks/morph_system/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Different Anchors (explains sys_composer.morph_system) \u00a4 import x_xy import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media def show_video ( sys , xs : x_xy . Transform ) -& gt ; None : assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"targetfar\" , height = 480 , width = 640 ) # convert rgba to rgb frames = [ frame [ ... , : 3 ] for frame in frames ] media . show_video ( frames , fps = 25 ) In this system the middle segment seg2 acts as \"anchor\". xml_str = \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 1\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . load_sys_from_str ( xml_str ) gen = x_xy . build_generator ( sys , x_xy . MotionConfig ( T = 10.0 , t_max = 1.5 , dang_max_free_spherical = 0.1 , dpos_max = 0.1 ), _compat = True ) _ , xs = gen ( jax . random . PRNGKey ( 1 )) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01<00:00, 162.68it/s] This browser does not support the video tag. Can you see what i mean? The middle segment has all the \"global rotation and translation\". Let's move the anchor to seg1 but without changing the xml syntax. This can be done with the subpackage sys_composer . from x_xy.subpkgs import sys_composer # the new parents of seg2, seg1, imu1, seg3, imu2 are ... new_parents = [ \"seg1\" , - 1 , \"seg1\" , \"seg2\" , \"seg3\" ] sys = sys_composer . morph_system ( sys , new_parents = new_parents ) gen = x_xy . build_generator ( sys , x_xy . MotionConfig ( T = 10.0 , t_max = 1.5 , dang_max_free_spherical = 0.1 , dpos_max = 0.1 ), _compat = True ) _ , xs = gen ( jax . random . PRNGKey ( 1 )) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01<00:00, 147.05it/s] This browser does not support the video tag. Pretty cool, ha? :)","title":"Morph system"},{"location":"notebooks/morph_system/#different-anchors-explains-sys_composermorph_system","text":"import x_xy import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media def show_video ( sys , xs : x_xy . Transform ) -& gt ; None : assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"targetfar\" , height = 480 , width = 640 ) # convert rgba to rgb frames = [ frame [ ... , : 3 ] for frame in frames ] media . show_video ( frames , fps = 25 ) In this system the middle segment seg2 acts as \"anchor\". xml_str = \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 1\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . load_sys_from_str ( xml_str ) gen = x_xy . build_generator ( sys , x_xy . MotionConfig ( T = 10.0 , t_max = 1.5 , dang_max_free_spherical = 0.1 , dpos_max = 0.1 ), _compat = True ) _ , xs = gen ( jax . random . PRNGKey ( 1 )) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01<00:00, 162.68it/s] This browser does not support the video tag. Can you see what i mean? The middle segment has all the \"global rotation and translation\". Let's move the anchor to seg1 but without changing the xml syntax. This can be done with the subpackage sys_composer . from x_xy.subpkgs import sys_composer # the new parents of seg2, seg1, imu1, seg3, imu2 are ... new_parents = [ \"seg1\" , - 1 , \"seg1\" , \"seg2\" , \"seg3\" ] sys = sys_composer . morph_system ( sys , new_parents = new_parents ) gen = x_xy . build_generator ( sys , x_xy . MotionConfig ( T = 10.0 , t_max = 1.5 , dang_max_free_spherical = 0.1 , dpos_max = 0.1 ), _compat = True ) _ , xs = gen ( jax . random . PRNGKey ( 1 )) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01<00:00, 147.05it/s] This browser does not support the video tag. Pretty cool, ha? :)","title":"Different Anchors (explains sys_composer.morph_system)"},{"location":"notebooks/motion_artifact_rejection/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install --quiet 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'\" ) os . system ( \"pip install --quiet mediapy\" ) import x_xy # automatically detects colab or not x_xy . utils . setup_colab_env () import jax import jax.numpy as jnp import mediapy as media def show_video ( sys , xs , ** kwargs ): media . show_video ( x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"target\" , width = 640 , height = 480 , ** kwargs ), fps = 25 ) knee_xml_str = \"\"\" <x_xy model=\"knee_flexible_imus\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"5 5 5 25 25 25\" joint=\"free\" name=\"femur\" pos=\"0.5 0.5 0.3\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.05 0.4\" euler=\"0 90 0\" mass=\"1\" pos=\"0.2 0 0\" type=\"capsule\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"0.2 0 0.05\" pos_max=\"0.35 0 0\" pos_min=\"0.05 0 0\"> <geom dim=\"0.05\" type=\"xyz\"></geom> <geom color=\"orange\" dim=\"0.05 0.05 0.02\" mass=\"0.1\" type=\"box\"></geom> </body> <body damping=\"3\" joint=\"ry\" name=\"tibia\" pos=\"0.4 0 0\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.04 0.4\" euler=\"0 90 0\" mass=\"1\" pos=\"0.2 0 0\" type=\"capsule\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.2 0 0.05\" pos_max=\"0.35 0 0\" pos_min=\"0.05 0 0\"> <geom dim=\"0.05\" type=\"xyz\"></geom> <geom color=\"orange\" dim=\"0.05 0.05 0.02\" mass=\"0.1\" type=\"box\"></geom> </body> <geom dim=\"0.025 0.05 0.2\" mass=\"0\" pos=\"0.45 0 .1\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . load_sys_from_str ( knee_xml_str ) media . show_image ( x_xy . render ( sys , camera = \"target\" , height = 480 , width = 640 )[ 0 ]) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00, 14.47it/s] T = 20.0 T_initial_nomotion = 2.0 config = x_xy . MotionConfig ( t_min = 0.1 , t_max = 0.75 , T = T , ang0_min = 0.0 , ang0_max = 0.0 , pos_min =- 1.0 , pos_max = 1.0 , dpos_max = 0.5 ) config = x_xy . join_motionconfigs ([ config . to_nomotion_config (), config ], [ T_initial_nomotion ]) ( X , y ), ( _ , qs , xs , sys_mod ) = x_xy . build_generator ( sys , config , imu_motion_artifacts = True , dynamic_simulation = True , eager = True , aslist = True , seed = 1 , sizes = 1 , keep_output_extras = True , imu_motion_artifacts_kwargs = dict ( hide_injected_bodies = False ))[ 0 ] /Users/simon/Documents/PYTHON/x_xy_v2/x_xy/algorithms/generator/motion_artifacts.py:80: UserWarning: `sys.links.joint_params` has been set to zero, this might lead to unexpected behaviour unless you use `randomize_joint_params` warnings.warn( /Users/simon/Documents/PYTHON/x_xy_v2/x_xy/algorithms/generator/base.py:184: UserWarning: `imu_motion_artifacts` is enabled but not `randomize_motion_artifacts` warnings.warn( eager data generation: 1it [00:28, 28.97s/it] show_video ( sys_mod , xs , show_floor = False ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:01<00:00, 315.52it/s] This browser does not support the video tag. sys_frozen = sys_mod . freeze ( \"tibia\" ) . freeze ( \"femur\" ) def freeze_x ( q_obs ): q_frozen = jnp . concatenate ( tuple ( q_obs [:, sys_mod . idx_map ( \"q\" )[ name ]] for name in [ \"_imu1\" , \"imu1\" , \"_imu2\" , \"imu2\" ]), axis =- 1 ) return jax . vmap ( lambda q : x_xy . algorithms . forward_kinematics_transforms ( sys_frozen , q )[ 0 ])( q_frozen ) show_video ( sys_frozen , freeze_x ( qs )) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:02<00:00, 172.52it/s] This browser does not support the video tag.","title":"Motion artifact rejection"},{"location":"notebooks/visualisation/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . import ring import mediapy as media import jax from diodem import load_data sys_str = \"\"\" <x_xy> <worldbody> <geom dim=\"0.1\" type=\"xyz\"></geom> <body joint=\"free\" name=\"seg\" pos=\"0 0 .5\"> <geom color=\"dustin_exp_blue\" dim=\"0.15 0.075 0.05\" mass=\"0.2\" pos=\"0.03 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu\" pos=\"0.0 0.0 0.03\"> <geom color=\"dustin_exp_orange\" dim=\"0.05 0.03 0.02\" mass=\"0.1\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( sys_str ) ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:04<00:00, 4.35s/it] media . show_video ( sys . render ( x , width = 640 , height = 480 , camera = \"target\" , render_every_nth = 4 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1500/1500 [00:14<00:00, 102.87it/s] This browser does not support the video tag. exp_data = load_data ( exp_id = 1 , motion_start = \"fast\" ) exp_data . keys () dict_keys(['seg1', 'seg2', 'seg3', 'seg4', 'seg5']) exp_data [ \"seg1\" ] . keys () dict_keys(['imu_nonrigid', 'imu_rigid', 'marker1', 'marker2', 'marker3', 'marker4', 'quat']) segment = \"seg2\" omc_data_sys = { \"seg\" : { \"pos\" : exp_data [ segment ][ \"marker1\" ], \"quat\" : exp_data [ segment ][ \"quat\" ], }, \"imu\" : { \"quat\" : exp_data [ segment ][ \"quat\" ], } } omc_data_sys {'seg': {'pos': array([[-0.00217298, 1.31229643, -0.06881995], [-0.00217508, 1.31225208, -0.06880918], [-0.00217637, 1.31223445, -0.06880335], ..., [-0.07191098, 1.33661952, -0.07041251], [-0.07191038, 1.33658217, -0.07042007], [-0.07190987, 1.3365283 , -0.07043372]]), 'quat': array([[ 0.95854069, 0.11865217, -0.03095211, -0.25722244], [ 0.95854969, 0.11859988, -0.03091764, -0.25721714], [ 0.95855869, 0.11854759, -0.03088317, -0.25721185], ..., [ 0.95514079, 0.11290525, -0.03582784, -0.27143111], [ 0.95514079, 0.11290525, -0.03582784, -0.27143111], [ 0.95514079, 0.11290525, -0.03582784, -0.27143111]])}, 'imu': {'quat': array([[ 0.95854069, 0.11865217, -0.03095211, -0.25722244], [ 0.95854969, 0.11859988, -0.03091764, -0.25721714], [ 0.95855869, 0.11854759, -0.03088317, -0.25721185], ..., [ 0.95514079, 0.11290525, -0.03582784, -0.27143111], [ 0.95514079, 0.11290525, -0.03582784, -0.27143111], [ 0.95514079, 0.11290525, -0.03582784, -0.27143111]])}} x = ring . sim2real . xs_from_raw ( sys , omc_data_sys ) # vectorize this function over time @jax . vmap def update_position_vector_of_imu ( x ): state = ring . State . create ( sys , x = x ) # populate minimal coordinates `state.q` from maximal coordinates `state.x` state = ring . algorithms . inverse_kinematics ( sys , state ) # re-calculate maximal coordiantes `state.x` from minimal coordinates `state.q` # this uses the position vector specified in the system (and so the xml file) # to produce an offset between IMu and segment geom box _ , state = ring . algorithms . forward_kinematics ( sys , state ) return state . x x = update_position_vector_of_imu ( x ) media . show_video ( sys . render ( x , width = 640 , height = 480 , camera = \"target\" , render_every_nth = 4 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1075/1075 [00:09<00:00, 113.41it/s] This browser does not support the video tag.","title":"Visualisation"},{"location":"prism/ss_23_marcel_thomas/notebook/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Training the RNNO with rigid phases (PRISM SS2023) \u00a4 In this notebook, we define a custom hinge joint, which is configured to generate pauses (no movement) inside the generated data series. We use this joint to train the RNNO and perfrom inference with the generated parameters. import x_xy import jax import jax.numpy as jnp import jax.random as random from x_xy.subpkgs.ml import rnno , callbacks , train , load from x_xy.subpkgs import sim2real , sys_composer import tree_utils import matplotlib.pyplot as plt import mediapy as media Defining the System \u00a4 A system is defined in an XML structure. To read a system, an XML file may be used. It is also possible to define the system inline by using a string in XML-syntax. In the following, we define two three-segment chains: three_seg_rigid = r \"\"\" <x_xy model=\"three_seg_rigid\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\"> <geom color=\"red\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"rsry\" name=\"seg1\" pos=\"0 0 0\"> <geom color=\"yellow\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"-0.1 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.1 0.0 0.03\"> <geom color=\"green\" dim=\"0.05 0.01 0.01\" mass=\"2\" pos=\"0 0 0\" type=\"box\"></geom> </body> </body> <body joint=\"rsrz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom color=\"blue\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.1 0.0 0.03\"> <geom color=\"green\" dim=\"0.05 0.01 0.01\" mass=\"2\" pos=\"0 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> <defaults> <geom color=\"1 0.8 0.7 1\" edge_color=\"black\"></geom> </defaults> </x_xy> \"\"\" dustin_exp_xml_seg1 = r \"\"\" <x_xy model=\"dustin_exp\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg1\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"-0.1 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg2\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"rz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" Registering the joint axis \u00a4 For this scenario, we define two systems: One for generating data with rigid phases and one for inference. To generate the random data with rigid phases, we first have to register a joint type, that allows for the creation of such data. We call this joint 'rsr\\<x|y|z>', a hinge joint that produces r andom s ometimes r igid data, and turns around the respective axis \\(x\\) , \\(y\\) or \\(z\\) in its frame. </x|y|z> Generating random data \u00a4 The random data is generated by the following functions: # Helper function - Creates an array of values x &lt;- [0, 1] which may be multiplied to another sequence. def motion_amplifier ( time : float , sampling_rate : float , key_rigid_phases : jax . Array , n_rigid_phases = 3 , rigid_duration_cov = jnp . array ([ 0.02 ] * 3 ), transition_cov = jnp . array ([ 0.1 ] * 3 ) ) -& gt ; jax . Array : error_msg = \"motion_amplifier: There must be a variance for each rigid phase!\" assert rigid_duration_cov . shape == ( n_rigid_phases ,) == transition_cov . shape , error_msg n_frames = int ( time / sampling_rate ) key_rigid_means , key_rigid_variances , key_slope_down_variances , key_slope_up_variances = random . split ( key_rigid_phases , 4 ) # Calculate center points of rigid phases means = jnp . sort ( random . uniform ( key_rigid_means , shape = ( n_rigid_phases , 1 ), minval = 0 , maxval = n_frames ) . T ) # Calculate durations, which is twice the rigid distance from the center points for each rigid phase. rigid_distances = jnp . abs ( random . multivariate_normal ( key_rigid_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( rigid_duration_cov * n_frames ) ** 2 ))) # Calculate transition durations transition_slowdown_durations = jnp . abs ( random . multivariate_normal ( key_slope_down_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( transition_cov * n_frames ) ** 2 ) )) transition_speedup_durations = jnp . abs ( random . multivariate_normal ( key_slope_up_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( transition_cov * n_frames ) ** 2 ) )) # Phase start and end points rigid_starts = ( means - rigid_distances ) . astype ( int ) . flatten () rigid_ends = ( means + rigid_distances ) . astype ( int ) . flatten () starts_slowing = ( means - rigid_distances - transition_slowdown_durations ) . astype ( int ) . flatten () ends_moving = ( means + rigid_distances + transition_speedup_durations ) . astype ( int ) . flatten () # Create masks def create_mask ( start , end ): nonlocal n_frames return jnp . where ( jnp . arange ( n_frames ) & lt ; start , 1 , 0 ) + jnp . where ( jnp . arange ( n_frames ) & gt ; = end , 1 , 0 ) mask = jax . vmap ( create_mask ) rigid_mask = jnp . prod ( mask ( rigid_starts , rigid_ends ), axis = 0 ) slowdown_masks = mask ( starts_slowing , rigid_starts ) . astype ( float ) speedup_masks = mask ( rigid_ends , ends_moving ) . astype ( float ) # We have to define an inline function in order to make this code JIT-able def linsp ( mask , start , end , begin_val , carry_fun ): range = end - start def true_fun ( carry , x ): return ( carry_fun ( carry , range ), 1 - carry ) def false_fun ( carry , x ): return ( carry , x ) def f ( carry , x ): return jax . lax . cond ( x == 0 , true_fun , false_fun , * ( carry , x )) return jax . lax . scan ( f , begin_val , mask )[ 1 ] linsp_desc = jax . vmap ( lambda m , s1 , s2 : linsp ( m , s1 , s2 , 0.0 , lambda carry , range : carry + 1 / range )) slowdown_mask = jnp . prod ( linsp_desc ( slowdown_masks , starts_slowing , rigid_starts ), axis = 0 ) linsp_asc = jax . vmap ( lambda m , s1 , s2 : linsp ( m , s1 , s2 , 1.0 , lambda carry , range : carry - 1 / range )) speedup_mask = jnp . prod ( linsp_asc ( speedup_masks , rigid_ends , ends_moving ), axis = 0 ) return jnp . min ( jnp . stack ([ rigid_mask , slowdown_mask , speedup_mask ]), axis = 0 ) # Random generator: Uses the motion_amplifier to dampen/null the randomly generated angles. def random_angles_with_rigid_phases_over_time ( key_t , key_ang , dt , key_rigid_phases , n_rigid_phases = 3 , rigid_duration_cov = jnp . array ([ 0.02 ] * 3 ), transition_cov = jnp . array ([ 0.1 ] * 3 ), config : x_xy . algorithms . MotionConfig = x_xy . algorithms . MotionConfig () ) -& gt ; jax . Array : mask = motion_amplifier ( config . T , dt , key_rigid_phases , n_rigid_phases , rigid_duration_cov , transition_cov ) qs = x_xy . algorithms . random_angle_over_time ( key_t = key_t , key_ang = key_ang , ANG_0 = config . ang0_max , dang_min = config . dang_min , dang_max = config . dang_max , delta_ang_min = config . delta_ang_min , delta_ang_max = config . delta_ang_max , t_min = config . t_min , t_max = config . t_max , T = config . T , Ts = dt , randomized_interpolation = config . randomized_interpolation_angle , range_of_motion = config . range_of_motion_hinge , range_of_motion_method = config . range_of_motion_hinge_method ) # derivate qs qs_diff = jnp . diff ( qs , axis = 0 ) # mulitply with motion amplifier qs_diff = qs_diff * mask [: - 1 ] # integrate qs_diff qs_rigid_phases = jnp . concatenate (( qs [ 0 : 1 ], jnp . cumsum ( qs_diff , axis = 0 ))) return qs_rigid_phases Defining the random joint function \u00a4 First of all, we have to define our problem. This means, parameterzing the random function. Two possible scenarios are implemented below: \"BEST_RUN\" and \"MANY_TINY_STOPS\", both of which achieved adequate results. The problems are defined as \\(P=(N, \\mathbf{\\sigma}_{r}, \\mathbf{\\sigma}_{tr})\\) , with \\(N\\) being the number of rigid phases, \\(\\mathbf{\\sigma}_r\\) the covariance used for calculating the length of each rigid phase and \\(\\mathbf{\\sigma}_{tr}\\) for the length of each transition phase respectively. It also holds that \\(\\mathbf{\\sigma}_r, \\mathbf{\\sigma}_{tr} \\in \\mathbb{R}^N\\) , with each entry being the variance for exactly one rigid phase. BEST_RUN = ( 1 , jnp . array ([ 0.02 ]), jnp . array ([ 0.1 ])) MANY_TINY_STOPS = ( 30 , jnp . array ([ 0.001 ] * 30 ), jnp . array ([ 0.0001 ] * 30 )) ################################################################################## # Define your own problem configuration here :) # PROBLEM = BEST_RUN # &lt;- Change this assignment to use it. ################################################################################## def define_joints (): def _draw_sometimes_rigid ( config : x_xy . algorithms . MotionConfig , key_t : jax . Array , key_value : jax . Array , dt : float , joint_params : jax . Array ) -& gt ; jax . Array : key_t , key_rigid_phases = jax . random . split ( key_t ) return random_angles_with_rigid_phases_over_time ( key_t = key_t , key_ang = key_value , dt = dt , key_rigid_phases = key_rigid_phases , n_rigid_phases = PROBLEM [ 0 ], rigid_duration_cov = PROBLEM [ 1 ], transition_cov = PROBLEM [ 2 ], config = config ) def _rxyz_transform ( q , _ , axis ): q = jnp . squeeze ( q ) rot = x_xy . maths . quat_rot_axis ( axis , q ) return x_xy . base . Transform . create ( rot = rot ) rsrx_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 1.0 , 0 , 0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) rsry_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 0 , 1.0 , 0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) rsrz_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 0 , 0 , 1.0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) try : x_xy . algorithms . register_new_joint_type ( \"rsrx\" , rsrx_joint , 1 ) x_xy . algorithms . register_new_joint_type ( \"rsry\" , rsry_joint , 1 ) x_xy . algorithms . register_new_joint_type ( \"rsrz\" , rsrz_joint , 1 ) except AssertionError : print ( \"Warning: Joints have already been registered!\" ) define_joints () Note: it is also possible to support multiple problems at the same time, by implementing them as seperate joint types, or by injecting the x_xy.algorithms.MotionConfig class e.g. by inheritance. After we defined the joint type, we can load the system: sys_rigid = x_xy . io . load_sys_from_str ( three_seg_rigid ) sys_inference = x_xy . io . load_sys_from_str ( dustin_exp_xml_seg1 ) Generating raw data \u00a4 For both training and inference, we first need a set of raw data. In our example, sys_rigid is used to generate the problem-specific data for each IMU. This data will be used for training and later by sys_inference to estimate the position and orientation of seg2 , which has no IMU attached. def finalize_fn_imu_data ( key , q , x , sys ): imu_seg_attachment = { \"imu1\" : \"seg1\" , \"imu2\" : \"seg3\" } X = {} for imu , seg in imu_seg_attachment . items (): key , consume = jax . random . split ( key ) X [ seg ] = x_xy . algorithms . imu ( x . take ( sys . name_to_idx ( imu ), 1 ), sys . gravity , sys . dt , consume , True ) return X def finalize_fn_rel_pose_data ( key , _ , x , sys ): y = x_xy . algorithms . rel_pose ( sys_scan = sys_inference , xs = x , sys_xs = sys ) return y def finalize_fn ( key , q , x , sys ): X = finalize_fn_imu_data ( key , q , x , sys ) # Since no IMU is attached to seg2, we need to provide dummy data. X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) y = finalize_fn_rel_pose_data ( key , q , x , sys ) return X , y The generated data comes is returned in the tuple \\((\\mathbf{X}, \\mathbf{y})\\) , with \\(\\mathbf{X}\\) being the generated IMU accelorometer and gyroscope data and \\(\\mathbf{y}\\) the orientation of each segment, in form of a unit quaternion. Train the model \u00a4 Before we begin with the actual training, we first define a setup function. This is called before training on each time series. The function below alters the length of segments and the position of the IMUs of the system, to simulate inaccuracies, e.g. when dealing with experimental data. def setup_fn_seg2 ( key , sys : x_xy . base . System ) -& gt ; x_xy . base . System : def replace_pos ( transforms , new_pos , name : str ): i = sys . name_to_idx ( name ) return transforms . index_set ( i , transforms [ i ] . replace ( pos = new_pos )) def draw_pos_uniform ( key , pos_min , pos_max ): key , c1 , c2 , c3 = jax . random . split ( key , num = 4 ) pos = jnp . array ( [ jax . random . uniform ( c1 , minval = pos_min [ 0 ], maxval = pos_max [ 0 ]), jax . random . uniform ( c2 , minval = pos_min [ 1 ], maxval = pos_max [ 1 ]), jax . random . uniform ( c3 , minval = pos_min [ 2 ], maxval = pos_max [ 2 ]), ] ) return key , pos ts = sys . links . transform1 # seg1 relative to seg2 key , pos = draw_pos_uniform ( key , [ - 0.3 , - 0.02 , - 0.02 ], [ - 0.05 , 0.02 , 0.02 ]) ts = replace_pos ( ts , pos , \"seg1\" ) # imu1 relative to seg1 key , pos = draw_pos_uniform ( key , [ - 0.25 , - 0.05 , - 0.05 ], [ - 0.05 , 0.05 , 0.05 ]) ts = replace_pos ( ts , pos , \"imu1\" ) # seg3 relative to seg2 key , pos = draw_pos_uniform ( key , [ 0.05 , - 0.02 , - 0.02 ], [ 0.3 , 0.02 , 0.02 ]) ts = replace_pos ( ts , pos , \"seg3\" ) # imu2 relative to seg2 key , pos = draw_pos_uniform ( key , [ 0.05 , - 0.05 , - 0.05 ], [ 0.25 , 0.05 , 0.05 ]) ts = replace_pos ( ts , pos , \"imu2\" ) return sys . replace ( links = sys . links . replace ( transform1 = ts )) With this, we can now train the model: We first define the batch size and number of epochs. For good results, a relatively large number of epochs is required, as the mean average angle error in training converges relatively late in training. Then we plug together the setup- and finalize functions in a generator function, which will provide the batched training data. A logger might also be added, such as a neptune logger. When using neptune, the environment-variables NEPTUNE_TOKEN and NEPTUNE_PROJECT must be set accordingly. TRAINING_BATCH_SIZE = 80 EPOCHS = 1500 params_path = \"parameters.pickle\" KEY_GEN = random . PRNGKey ( 1 ) KEY_NETWORK = random . PRNGKey ( 1 ) gen = x_xy . algorithms . build_generator ( sys_rigid , x_xy . algorithms . MotionConfig (), setup_fn_seg2 , finalize_fn ) gen = x_xy . algorithms . batch_generators_lazy ( gen , TRAINING_BATCH_SIZE ) # Set 'upload' to True if a logger is attached. save_params = callbacks . SaveParamsTrainingLoopCallback ( params_path , upload = False ) loggers = [] # loggers.append(NeptuneLogger()) # You may add loggers here, e.g. a Neptune Logger network = rnno . make_rnno ( sys_inference ) WARNING! Executing this code can take a long time (due to the very high number of epochs) and will probably take up a huge portion of your memory. If you run this code on a GPU, a batch size of 80 takes more than 50 GB of VRAM, so if the execution fails, it might be because of missing GPU memory. To circumvent this, the batch size can be decreased, however, the results will suffer from that. train ( gen , EPOCHS , network , loggers = loggers , callbacks = [ save_params ], key_generator = KEY_GEN , key_network = KEY_NETWORK ) Infering data \u00a4 def finalize_fn_inference ( key , q , x , sys ): X = finalize_fn_imu_data ( key , q , x , sys ) y = finalize_fn_rel_pose_data ( key , q , x , sys ) return X , y , x def generate_inference_data ( sys , config : x_xy . algorithms . MotionConfig , seed = random . PRNGKey ( 1 ,)): generator = x_xy . algorithms . build_generator ( sys , config , finalize_fn = finalize_fn_inference ) X , y , xs = generator ( seed ) return X , y , xs To control the data generated, the MotionConfig data is used. It contains all necessary information about the to-be-generated data series, e.g. time ( config.T ), except for the sampling rate, which is stored in the system object ( <sys>.dt ) and set in the XML-definition. The finalize function and its return values are similiar to the training finilaize function, however, an addtitional \\(\\mathbf{xs}\\) is returned, containing the actual position and rotation. This can be used for rendering purposes later. Also, the data is not batched, as we currently are only interested in one time series. config = x_xy . algorithms . MotionConfig () print ( f \"Generating data for a time series of { config . T } seconds, with a sampling rate of { 1 / sys_inference . dt } Hz.\" ) # If you are unhappy with your data series, you can alter this seed: seed = random . PRNGKey ( 1337 ,) X , y , xs = generate_inference_data ( sys_rigid , config , seed ) # Add dummy IMU data for segment 2 (which has no IMU attached) X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) Generating data for a time series of 60.0 seconds, with a sampling rate of 100.0 Hz. Inference \u00a4 To do inference, we first need to load the parameters (weights) of our model. params = load ( \"parameters.pickle\" ) Finally, we have everything we need to do inference! Let's see how our network performs... # Run prediction: X_3d = tree_utils . to_3d_if_2d ( X , strict = True ) initial_params , state = network . init ( random . PRNGKey ( 1 ,), X_3d ) yhat , _ = network . apply ( params , tree_utils . add_batch_dim ( state ), X_3d ) yhat = tree_utils . to_2d_if_3d ( yhat , strict = True ) # Plot prediction: def plot_segment ( segment : str , axis : str , ax ): axis_idx = \"xyz\" . index ( axis ) euler_angles_hat_seg2 = jnp . rad2deg ( x_xy . maths . quat_to_euler ( yhat [ segment ])[:, axis_idx ]) euler_angles_seg2 = jnp . rad2deg ( x_xy . maths . quat_to_euler ( y [ segment ])[:, axis_idx ]) ax . plot ( euler_angles_hat_seg2 , label = \"prediction\" ) ax . set_ylim (( - 180 , 180 )) ax . set_title ( f \" { segment } ( { axis } -axis)\" ) ax . plot ( euler_angles_seg2 , label = \"truth\" ) ax . set_xlabel ( \"time [s]\" ) ax . set_ylabel ( \"euler angles [deg]\" ) ax . legend () print ( f \" { segment } : medium absolute error { jnp . average ( jnp . abs ( euler_angles_hat_seg2 - euler_angles_seg2 )) } deg\" ) fig , axs = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) plot_segment ( \"seg2\" , 'y' , axs [ 0 ]) plot_segment ( \"seg3\" , 'z' , axs [ 1 ]) plt . show () seg2: medium absolute error 0.524849534034729 deg seg3: medium absolute error 0.5137953162193298 deg Let's also render a video of the prediction and the truth: # Extract translations from data-generating system... translations , rotations = sim2real . unzip_xs ( sys_inference , sim2real . match_xs ( sys_inference , xs , sys_rigid )) yhat_inv = jax . tree_map ( lambda quat : x_xy . maths . quat_inv ( quat ), yhat ) # ... swap rotations with predicted ones... rotations_hat = [] for i , name in enumerate ( sys_inference . link_names ): if name in yhat_inv : rotations_name = x_xy . Transform . create ( rot = yhat_inv [ name ]) else : rotations_name = rotations . take ( i , axis = 1 ) rotations_hat . append ( rotations_name ) # ... and plug the positions and rotations back together. rotations_hat = rotations_hat [ 0 ] . batch ( * rotations_hat [ 1 :]) . transpose (( 1 , 0 , 2 )) xs_hat = sim2real . zip_xs ( sys_inference , translations , rotations_hat ) # Create combined system that shall be rendered and its transforms sys_render = sys_composer . inject_system ( sys_rigid , sys_inference . add_prefix_suffix ( suffix = \"_hat\" )) xs_render = x_xy . Transform . concatenate ( xs , xs_hat , axis = 1 ) # Render prediction and truth: frames = x_xy . render ( sys_render , [ xs_render [ i ] for i in range ( xs_render . shape ( axis = 0 ))], camera = 'target' ) media . show_video ([ frame [ ... , : 3 ] for frame in frames ], fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000/6000 [00:16<00:00, 374.76it/s] This browser does not support the video tag.","title":"Notebook"},{"location":"prism/ss_23_marcel_thomas/notebook/#training-the-rnno-with-rigid-phases-prism-ss2023","text":"In this notebook, we define a custom hinge joint, which is configured to generate pauses (no movement) inside the generated data series. We use this joint to train the RNNO and perfrom inference with the generated parameters. import x_xy import jax import jax.numpy as jnp import jax.random as random from x_xy.subpkgs.ml import rnno , callbacks , train , load from x_xy.subpkgs import sim2real , sys_composer import tree_utils import matplotlib.pyplot as plt import mediapy as media","title":"Training the RNNO with rigid phases (PRISM SS2023)"},{"location":"prism/ss_23_marcel_thomas/notebook/#defining-the-system","text":"A system is defined in an XML structure. To read a system, an XML file may be used. It is also possible to define the system inline by using a string in XML-syntax. In the following, we define two three-segment chains: three_seg_rigid = r \"\"\" <x_xy model=\"three_seg_rigid\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\"> <geom color=\"red\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"rsry\" name=\"seg1\" pos=\"0 0 0\"> <geom color=\"yellow\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"-0.1 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.1 0.0 0.03\"> <geom color=\"green\" dim=\"0.05 0.01 0.01\" mass=\"2\" pos=\"0 0 0\" type=\"box\"></geom> </body> </body> <body joint=\"rsrz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom color=\"blue\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.1 0.0 0.03\"> <geom color=\"green\" dim=\"0.05 0.01 0.01\" mass=\"2\" pos=\"0 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> <defaults> <geom color=\"1 0.8 0.7 1\" edge_color=\"black\"></geom> </defaults> </x_xy> \"\"\" dustin_exp_xml_seg1 = r \"\"\" <x_xy model=\"dustin_exp\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg1\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"-0.1 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg2\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"rz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\"","title":"Defining the System"},{"location":"prism/ss_23_marcel_thomas/notebook/#registering-the-joint-axis","text":"For this scenario, we define two systems: One for generating data with rigid phases and one for inference. To generate the random data with rigid phases, we first have to register a joint type, that allows for the creation of such data. We call this joint 'rsr\\<x|y|z>', a hinge joint that produces r andom s ometimes r igid data, and turns around the respective axis \\(x\\) , \\(y\\) or \\(z\\) in its frame. </x|y|z>","title":"Registering the joint axis"},{"location":"prism/ss_23_marcel_thomas/notebook/#generating-random-data","text":"The random data is generated by the following functions: # Helper function - Creates an array of values x &lt;- [0, 1] which may be multiplied to another sequence. def motion_amplifier ( time : float , sampling_rate : float , key_rigid_phases : jax . Array , n_rigid_phases = 3 , rigid_duration_cov = jnp . array ([ 0.02 ] * 3 ), transition_cov = jnp . array ([ 0.1 ] * 3 ) ) -& gt ; jax . Array : error_msg = \"motion_amplifier: There must be a variance for each rigid phase!\" assert rigid_duration_cov . shape == ( n_rigid_phases ,) == transition_cov . shape , error_msg n_frames = int ( time / sampling_rate ) key_rigid_means , key_rigid_variances , key_slope_down_variances , key_slope_up_variances = random . split ( key_rigid_phases , 4 ) # Calculate center points of rigid phases means = jnp . sort ( random . uniform ( key_rigid_means , shape = ( n_rigid_phases , 1 ), minval = 0 , maxval = n_frames ) . T ) # Calculate durations, which is twice the rigid distance from the center points for each rigid phase. rigid_distances = jnp . abs ( random . multivariate_normal ( key_rigid_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( rigid_duration_cov * n_frames ) ** 2 ))) # Calculate transition durations transition_slowdown_durations = jnp . abs ( random . multivariate_normal ( key_slope_down_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( transition_cov * n_frames ) ** 2 ) )) transition_speedup_durations = jnp . abs ( random . multivariate_normal ( key_slope_up_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( transition_cov * n_frames ) ** 2 ) )) # Phase start and end points rigid_starts = ( means - rigid_distances ) . astype ( int ) . flatten () rigid_ends = ( means + rigid_distances ) . astype ( int ) . flatten () starts_slowing = ( means - rigid_distances - transition_slowdown_durations ) . astype ( int ) . flatten () ends_moving = ( means + rigid_distances + transition_speedup_durations ) . astype ( int ) . flatten () # Create masks def create_mask ( start , end ): nonlocal n_frames return jnp . where ( jnp . arange ( n_frames ) & lt ; start , 1 , 0 ) + jnp . where ( jnp . arange ( n_frames ) & gt ; = end , 1 , 0 ) mask = jax . vmap ( create_mask ) rigid_mask = jnp . prod ( mask ( rigid_starts , rigid_ends ), axis = 0 ) slowdown_masks = mask ( starts_slowing , rigid_starts ) . astype ( float ) speedup_masks = mask ( rigid_ends , ends_moving ) . astype ( float ) # We have to define an inline function in order to make this code JIT-able def linsp ( mask , start , end , begin_val , carry_fun ): range = end - start def true_fun ( carry , x ): return ( carry_fun ( carry , range ), 1 - carry ) def false_fun ( carry , x ): return ( carry , x ) def f ( carry , x ): return jax . lax . cond ( x == 0 , true_fun , false_fun , * ( carry , x )) return jax . lax . scan ( f , begin_val , mask )[ 1 ] linsp_desc = jax . vmap ( lambda m , s1 , s2 : linsp ( m , s1 , s2 , 0.0 , lambda carry , range : carry + 1 / range )) slowdown_mask = jnp . prod ( linsp_desc ( slowdown_masks , starts_slowing , rigid_starts ), axis = 0 ) linsp_asc = jax . vmap ( lambda m , s1 , s2 : linsp ( m , s1 , s2 , 1.0 , lambda carry , range : carry - 1 / range )) speedup_mask = jnp . prod ( linsp_asc ( speedup_masks , rigid_ends , ends_moving ), axis = 0 ) return jnp . min ( jnp . stack ([ rigid_mask , slowdown_mask , speedup_mask ]), axis = 0 ) # Random generator: Uses the motion_amplifier to dampen/null the randomly generated angles. def random_angles_with_rigid_phases_over_time ( key_t , key_ang , dt , key_rigid_phases , n_rigid_phases = 3 , rigid_duration_cov = jnp . array ([ 0.02 ] * 3 ), transition_cov = jnp . array ([ 0.1 ] * 3 ), config : x_xy . algorithms . MotionConfig = x_xy . algorithms . MotionConfig () ) -& gt ; jax . Array : mask = motion_amplifier ( config . T , dt , key_rigid_phases , n_rigid_phases , rigid_duration_cov , transition_cov ) qs = x_xy . algorithms . random_angle_over_time ( key_t = key_t , key_ang = key_ang , ANG_0 = config . ang0_max , dang_min = config . dang_min , dang_max = config . dang_max , delta_ang_min = config . delta_ang_min , delta_ang_max = config . delta_ang_max , t_min = config . t_min , t_max = config . t_max , T = config . T , Ts = dt , randomized_interpolation = config . randomized_interpolation_angle , range_of_motion = config . range_of_motion_hinge , range_of_motion_method = config . range_of_motion_hinge_method ) # derivate qs qs_diff = jnp . diff ( qs , axis = 0 ) # mulitply with motion amplifier qs_diff = qs_diff * mask [: - 1 ] # integrate qs_diff qs_rigid_phases = jnp . concatenate (( qs [ 0 : 1 ], jnp . cumsum ( qs_diff , axis = 0 ))) return qs_rigid_phases","title":"Generating random data"},{"location":"prism/ss_23_marcel_thomas/notebook/#defining-the-random-joint-function","text":"First of all, we have to define our problem. This means, parameterzing the random function. Two possible scenarios are implemented below: \"BEST_RUN\" and \"MANY_TINY_STOPS\", both of which achieved adequate results. The problems are defined as \\(P=(N, \\mathbf{\\sigma}_{r}, \\mathbf{\\sigma}_{tr})\\) , with \\(N\\) being the number of rigid phases, \\(\\mathbf{\\sigma}_r\\) the covariance used for calculating the length of each rigid phase and \\(\\mathbf{\\sigma}_{tr}\\) for the length of each transition phase respectively. It also holds that \\(\\mathbf{\\sigma}_r, \\mathbf{\\sigma}_{tr} \\in \\mathbb{R}^N\\) , with each entry being the variance for exactly one rigid phase. BEST_RUN = ( 1 , jnp . array ([ 0.02 ]), jnp . array ([ 0.1 ])) MANY_TINY_STOPS = ( 30 , jnp . array ([ 0.001 ] * 30 ), jnp . array ([ 0.0001 ] * 30 )) ################################################################################## # Define your own problem configuration here :) # PROBLEM = BEST_RUN # &lt;- Change this assignment to use it. ################################################################################## def define_joints (): def _draw_sometimes_rigid ( config : x_xy . algorithms . MotionConfig , key_t : jax . Array , key_value : jax . Array , dt : float , joint_params : jax . Array ) -& gt ; jax . Array : key_t , key_rigid_phases = jax . random . split ( key_t ) return random_angles_with_rigid_phases_over_time ( key_t = key_t , key_ang = key_value , dt = dt , key_rigid_phases = key_rigid_phases , n_rigid_phases = PROBLEM [ 0 ], rigid_duration_cov = PROBLEM [ 1 ], transition_cov = PROBLEM [ 2 ], config = config ) def _rxyz_transform ( q , _ , axis ): q = jnp . squeeze ( q ) rot = x_xy . maths . quat_rot_axis ( axis , q ) return x_xy . base . Transform . create ( rot = rot ) rsrx_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 1.0 , 0 , 0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) rsry_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 0 , 1.0 , 0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) rsrz_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 0 , 0 , 1.0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) try : x_xy . algorithms . register_new_joint_type ( \"rsrx\" , rsrx_joint , 1 ) x_xy . algorithms . register_new_joint_type ( \"rsry\" , rsry_joint , 1 ) x_xy . algorithms . register_new_joint_type ( \"rsrz\" , rsrz_joint , 1 ) except AssertionError : print ( \"Warning: Joints have already been registered!\" ) define_joints () Note: it is also possible to support multiple problems at the same time, by implementing them as seperate joint types, or by injecting the x_xy.algorithms.MotionConfig class e.g. by inheritance. After we defined the joint type, we can load the system: sys_rigid = x_xy . io . load_sys_from_str ( three_seg_rigid ) sys_inference = x_xy . io . load_sys_from_str ( dustin_exp_xml_seg1 )","title":"Defining the random joint function"},{"location":"prism/ss_23_marcel_thomas/notebook/#generating-raw-data","text":"For both training and inference, we first need a set of raw data. In our example, sys_rigid is used to generate the problem-specific data for each IMU. This data will be used for training and later by sys_inference to estimate the position and orientation of seg2 , which has no IMU attached. def finalize_fn_imu_data ( key , q , x , sys ): imu_seg_attachment = { \"imu1\" : \"seg1\" , \"imu2\" : \"seg3\" } X = {} for imu , seg in imu_seg_attachment . items (): key , consume = jax . random . split ( key ) X [ seg ] = x_xy . algorithms . imu ( x . take ( sys . name_to_idx ( imu ), 1 ), sys . gravity , sys . dt , consume , True ) return X def finalize_fn_rel_pose_data ( key , _ , x , sys ): y = x_xy . algorithms . rel_pose ( sys_scan = sys_inference , xs = x , sys_xs = sys ) return y def finalize_fn ( key , q , x , sys ): X = finalize_fn_imu_data ( key , q , x , sys ) # Since no IMU is attached to seg2, we need to provide dummy data. X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) y = finalize_fn_rel_pose_data ( key , q , x , sys ) return X , y The generated data comes is returned in the tuple \\((\\mathbf{X}, \\mathbf{y})\\) , with \\(\\mathbf{X}\\) being the generated IMU accelorometer and gyroscope data and \\(\\mathbf{y}\\) the orientation of each segment, in form of a unit quaternion.","title":"Generating raw data"},{"location":"prism/ss_23_marcel_thomas/notebook/#train-the-model","text":"Before we begin with the actual training, we first define a setup function. This is called before training on each time series. The function below alters the length of segments and the position of the IMUs of the system, to simulate inaccuracies, e.g. when dealing with experimental data. def setup_fn_seg2 ( key , sys : x_xy . base . System ) -& gt ; x_xy . base . System : def replace_pos ( transforms , new_pos , name : str ): i = sys . name_to_idx ( name ) return transforms . index_set ( i , transforms [ i ] . replace ( pos = new_pos )) def draw_pos_uniform ( key , pos_min , pos_max ): key , c1 , c2 , c3 = jax . random . split ( key , num = 4 ) pos = jnp . array ( [ jax . random . uniform ( c1 , minval = pos_min [ 0 ], maxval = pos_max [ 0 ]), jax . random . uniform ( c2 , minval = pos_min [ 1 ], maxval = pos_max [ 1 ]), jax . random . uniform ( c3 , minval = pos_min [ 2 ], maxval = pos_max [ 2 ]), ] ) return key , pos ts = sys . links . transform1 # seg1 relative to seg2 key , pos = draw_pos_uniform ( key , [ - 0.3 , - 0.02 , - 0.02 ], [ - 0.05 , 0.02 , 0.02 ]) ts = replace_pos ( ts , pos , \"seg1\" ) # imu1 relative to seg1 key , pos = draw_pos_uniform ( key , [ - 0.25 , - 0.05 , - 0.05 ], [ - 0.05 , 0.05 , 0.05 ]) ts = replace_pos ( ts , pos , \"imu1\" ) # seg3 relative to seg2 key , pos = draw_pos_uniform ( key , [ 0.05 , - 0.02 , - 0.02 ], [ 0.3 , 0.02 , 0.02 ]) ts = replace_pos ( ts , pos , \"seg3\" ) # imu2 relative to seg2 key , pos = draw_pos_uniform ( key , [ 0.05 , - 0.05 , - 0.05 ], [ 0.25 , 0.05 , 0.05 ]) ts = replace_pos ( ts , pos , \"imu2\" ) return sys . replace ( links = sys . links . replace ( transform1 = ts )) With this, we can now train the model: We first define the batch size and number of epochs. For good results, a relatively large number of epochs is required, as the mean average angle error in training converges relatively late in training. Then we plug together the setup- and finalize functions in a generator function, which will provide the batched training data. A logger might also be added, such as a neptune logger. When using neptune, the environment-variables NEPTUNE_TOKEN and NEPTUNE_PROJECT must be set accordingly. TRAINING_BATCH_SIZE = 80 EPOCHS = 1500 params_path = \"parameters.pickle\" KEY_GEN = random . PRNGKey ( 1 ) KEY_NETWORK = random . PRNGKey ( 1 ) gen = x_xy . algorithms . build_generator ( sys_rigid , x_xy . algorithms . MotionConfig (), setup_fn_seg2 , finalize_fn ) gen = x_xy . algorithms . batch_generators_lazy ( gen , TRAINING_BATCH_SIZE ) # Set 'upload' to True if a logger is attached. save_params = callbacks . SaveParamsTrainingLoopCallback ( params_path , upload = False ) loggers = [] # loggers.append(NeptuneLogger()) # You may add loggers here, e.g. a Neptune Logger network = rnno . make_rnno ( sys_inference ) WARNING! Executing this code can take a long time (due to the very high number of epochs) and will probably take up a huge portion of your memory. If you run this code on a GPU, a batch size of 80 takes more than 50 GB of VRAM, so if the execution fails, it might be because of missing GPU memory. To circumvent this, the batch size can be decreased, however, the results will suffer from that. train ( gen , EPOCHS , network , loggers = loggers , callbacks = [ save_params ], key_generator = KEY_GEN , key_network = KEY_NETWORK )","title":"Train the model"},{"location":"prism/ss_23_marcel_thomas/notebook/#infering-data","text":"def finalize_fn_inference ( key , q , x , sys ): X = finalize_fn_imu_data ( key , q , x , sys ) y = finalize_fn_rel_pose_data ( key , q , x , sys ) return X , y , x def generate_inference_data ( sys , config : x_xy . algorithms . MotionConfig , seed = random . PRNGKey ( 1 ,)): generator = x_xy . algorithms . build_generator ( sys , config , finalize_fn = finalize_fn_inference ) X , y , xs = generator ( seed ) return X , y , xs To control the data generated, the MotionConfig data is used. It contains all necessary information about the to-be-generated data series, e.g. time ( config.T ), except for the sampling rate, which is stored in the system object ( <sys>.dt ) and set in the XML-definition. The finalize function and its return values are similiar to the training finilaize function, however, an addtitional \\(\\mathbf{xs}\\) is returned, containing the actual position and rotation. This can be used for rendering purposes later. Also, the data is not batched, as we currently are only interested in one time series. config = x_xy . algorithms . MotionConfig () print ( f \"Generating data for a time series of { config . T } seconds, with a sampling rate of { 1 / sys_inference . dt } Hz.\" ) # If you are unhappy with your data series, you can alter this seed: seed = random . PRNGKey ( 1337 ,) X , y , xs = generate_inference_data ( sys_rigid , config , seed ) # Add dummy IMU data for segment 2 (which has no IMU attached) X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) Generating data for a time series of 60.0 seconds, with a sampling rate of 100.0 Hz.","title":"Infering data"},{"location":"prism/ss_23_marcel_thomas/notebook/#inference","text":"To do inference, we first need to load the parameters (weights) of our model. params = load ( \"parameters.pickle\" ) Finally, we have everything we need to do inference! Let's see how our network performs... # Run prediction: X_3d = tree_utils . to_3d_if_2d ( X , strict = True ) initial_params , state = network . init ( random . PRNGKey ( 1 ,), X_3d ) yhat , _ = network . apply ( params , tree_utils . add_batch_dim ( state ), X_3d ) yhat = tree_utils . to_2d_if_3d ( yhat , strict = True ) # Plot prediction: def plot_segment ( segment : str , axis : str , ax ): axis_idx = \"xyz\" . index ( axis ) euler_angles_hat_seg2 = jnp . rad2deg ( x_xy . maths . quat_to_euler ( yhat [ segment ])[:, axis_idx ]) euler_angles_seg2 = jnp . rad2deg ( x_xy . maths . quat_to_euler ( y [ segment ])[:, axis_idx ]) ax . plot ( euler_angles_hat_seg2 , label = \"prediction\" ) ax . set_ylim (( - 180 , 180 )) ax . set_title ( f \" { segment } ( { axis } -axis)\" ) ax . plot ( euler_angles_seg2 , label = \"truth\" ) ax . set_xlabel ( \"time [s]\" ) ax . set_ylabel ( \"euler angles [deg]\" ) ax . legend () print ( f \" { segment } : medium absolute error { jnp . average ( jnp . abs ( euler_angles_hat_seg2 - euler_angles_seg2 )) } deg\" ) fig , axs = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) plot_segment ( \"seg2\" , 'y' , axs [ 0 ]) plot_segment ( \"seg3\" , 'z' , axs [ 1 ]) plt . show () seg2: medium absolute error 0.524849534034729 deg seg3: medium absolute error 0.5137953162193298 deg Let's also render a video of the prediction and the truth: # Extract translations from data-generating system... translations , rotations = sim2real . unzip_xs ( sys_inference , sim2real . match_xs ( sys_inference , xs , sys_rigid )) yhat_inv = jax . tree_map ( lambda quat : x_xy . maths . quat_inv ( quat ), yhat ) # ... swap rotations with predicted ones... rotations_hat = [] for i , name in enumerate ( sys_inference . link_names ): if name in yhat_inv : rotations_name = x_xy . Transform . create ( rot = yhat_inv [ name ]) else : rotations_name = rotations . take ( i , axis = 1 ) rotations_hat . append ( rotations_name ) # ... and plug the positions and rotations back together. rotations_hat = rotations_hat [ 0 ] . batch ( * rotations_hat [ 1 :]) . transpose (( 1 , 0 , 2 )) xs_hat = sim2real . zip_xs ( sys_inference , translations , rotations_hat ) # Create combined system that shall be rendered and its transforms sys_render = sys_composer . inject_system ( sys_rigid , sys_inference . add_prefix_suffix ( suffix = \"_hat\" )) xs_render = x_xy . Transform . concatenate ( xs , xs_hat , axis = 1 ) # Render prediction and truth: frames = x_xy . render ( sys_render , [ xs_render [ i ] for i in range ( xs_render . shape ( axis = 0 ))], camera = 'target' ) media . show_video ([ frame [ ... , : 3 ] for frame in frames ], fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000/6000 [00:16<00:00, 374.76it/s] This browser does not support the video tag.","title":"Inference"},{"location":"prism/ss_23_moritz/notebook/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Training the RNNo with a custom loss function \u00a4 This notebook showcases how train an RNNo network with a custom loss function rather than the default mean-reduces angle error. This is showcased by scaling the error by a softmax over the time axis, which puts more weight on the time intervals with a higher deviation compared to ones with lower deviation. import jax import jax.numpy as jnp import tree_utils from jax.nn import softmax import matplotlib.pyplot as plt import mediapy import x_xy from x_xy.subpkgs import ml , sim2real , sys_composer Set the batch size and number of training episodes according to the available hardware. BATCHSIZE = 32 NUM_TRAINING_EPISODES = 1500 Defining the systems \u00a4 We use two separate systems, both parsed from XML strings: one for training ( sys ) and one for inference ( dustin_sys ). sys_str = r \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"orange\"></geom> </defaults> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"red\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"red\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . io . load_sys_from_str ( sys_str ) dustin_exp_xml_seg1 = r \"\"\" <x_xy model=\"dustin_exp\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"white\"></geom> </defaults> <worldbody> <body joint=\"free\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg2\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"rz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys_inference = x_xy . io . load_sys_from_str ( dustin_exp_xml_seg1 ) Generating the motion data \u00a4 Our motion data will be automatically generated using a Generator , which can be customised using an MotionConfig . The Generator will generate data for both q , that is the state of all the joint angles in the system, as well as xs , which describes the orientations of all the links in the system. To use this data for training our RNNo, we first have to bring it into the correct form using a finalise_fn . def finalise_fn ( key : jax . Array , q : jax . Array , xs : x_xy . Transform , sys : x_xy . System ): def xs_by_name ( name : str ): return xs . take ( sys . name_to_idx ( name ), axis = 1 ) key , * consume = jax . random . split ( key , 3 ) # the input X to our RNNo is the IMU data of segments 1 and 3 X = { \"seg1\" : x_xy . imu ( xs_by_name ( \"imu1\" ), sys . gravity , sys . dt , consume [ 0 ], True ), \"seg3\" : x_xy . imu ( xs_by_name ( \"imu2\" ), sys . gravity , sys . dt , consume [ 1 ], True ), } # seg2 has no IMU, but we still need to make an entry in our X X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) # the output of the RNNo is the estimated relative poses of our segments y = x_xy . algorithms . rel_pose ( sys_scan = sys_inference , xs = xs , sys_xs = sys ) return X , y config = x_xy . algorithms . MotionConfig ( dpos_max = 0.3 , ang0_min = 0.0 , ang0_max = 0.0 ) gen = x_xy . build_generator ( sys , config , finalize_fn = finalise_fn ) gen = x_xy . batch_generator ( gen , BATCHSIZE ) Custom loss function \u00a4 To customise the loss function of the RNNo, we transform the error values before they are averaged. The input to our loss function will be both \\(q\\) , the real joint state, as well as \\(\\hat{q}\\) , the joint space estimated by our RNNo. q and q_hat will both be jax.Array s of shape (T_tbp, 4) , where the first axis is slice over time (of our TBPTT length) and the second axis are the 4 components of a quaternion. In this notebook we want to change the relative weightings of the errors at different times using a softmax function in order to put more weight on larger errors. First we convert the errors from quaterions to angles. Then we scale each error angle by a factor, calculated from a softmax over the angles. The calculation of the factors includes a call to jax.lax.stop_gradient to make it so our gradients are only from the errors themselves, not the factors as well. def make_loss_fn ( beta ): def metric_fn ( q , q_hat ): return x_xy . maths . angle_error ( q , q_hat ) ** 2 if beta is not None : def loss_fn ( q , q_hat ): # q.shape == q_hat.shape == (1000, 4) angles = metric_fn ( q , q_hat ) factors = angles . shape [ - 1 ] * softmax ( beta * jax . lax . stop_gradient ( angles ), axis =- 1 ) errors = factors * angles return errors else : loss_fn = metric_fn return loss_fn beta determines the strength of our weighting: the larger beta, the more relative weight we put on the larger errors, while beta = 0.0 makes the scaling factors uniform one and gives us back our unweighted errors. Alternatively beta = None bypasses the scaling altogether. beta = 1.0 rnno = ml . make_rnno ( sys_inference ) loss_fn = make_loss_fn ( beta ) save_params = ml . callbacks . SaveParamsTrainingLoopCallback ( \"parameters.pickle\" , upload = False ) ml . train ( gen , NUM_TRAINING_EPISODES , rnno , callbacks = [ save_params ], loss_fn = loss_fn ) To visualise our network, we can render it using mediapy. First we generate some motion data. gen = x_xy . build_generator ( sys , config ) key = jax . random . PRNGKey ( 1 ) q , xs = gen ( key ) We need to again bring the motion data in the correct form for our RNNo and can then run inference of the generated data. params = ml . load ( \"parameters.pickle\" ) X , y = finalise_fn ( key , q , xs , sys ) X = tree_utils . add_batch_dim ( X ) _ , state = rnno . init ( key , X ) state = tree_utils . add_batch_dim ( state ) y_hat , _ = rnno . apply ( params , state , X ) y_hat = tree_utils . to_2d_if_3d ( y_hat , strict = True ) First we want to plot the angle error for both segment 2 and segment 3 over time. y [ \"seg2\" ][: 10 ] y_hat [ \"seg2\" ] fig , ax = plt . subplots () angle_error2 = jnp . rad2deg ( x_xy . maths . angle_error ( y [ \"seg2\" ], y_hat [ \"seg2\" ])) angle_error3 = jnp . rad2deg ( x_xy . maths . angle_error ( y [ \"seg3\" ], y_hat [ \"seg3\" ])) T = jnp . arange ( angle_error2 . size ) * sys_inference . dt ax . plot ( T , angle_error2 , label = \"seg2\" ) ax . plot ( T , angle_error3 , label = \"seg3\" ) ax . set_xlabel ( \"time [s]\" ) ax . set_ylabel ( \"abs. angle error [deg]\" ) ax . legend () plt . show () Next we have to create an xs_hat of the estimated orientations, so that we can render them. # Extract translations from data-generating system... translations , rotations = sim2real . unzip_xs ( sys_inference , sim2real . match_xs ( sys_inference , xs , sys ) ) y_hat_inv = jax . tree_map ( lambda quat : x_xy . maths . quat_inv ( quat ), y_hat ) # ... swap rotations with predicted ones... rotations_hat = [] for i , name in enumerate ( sys_inference . link_names ): if name in y_hat_inv : rotations_name = x_xy . Transform . create ( rot = y_hat_inv [ name ]) else : rotations_name = rotations . take ( i , axis = 1 ) rotations_hat . append ( rotations_name ) # ... and plug the positions and rotations back together. rotations_hat = rotations_hat [ 0 ] . batch ( * rotations_hat [ 1 :]) . transpose (( 1 , 0 , 2 )) xs_hat = sim2real . zip_xs ( sys_inference , translations , rotations_hat ) # Create combined system that shall be rendered and its transforms sys_render = sys_composer . inject_system ( sys , sys_inference . add_prefix_suffix ( suffix = \"_hat\" )) xs_render = x_xy . Transform . concatenate ( xs , xs_hat , axis = 1 ) Now we can render both the predicted system (in white) as well as the real system (in orange). xs_list = [ xs_render [ i ] for i in range ( xs_render . shape ())] frames = x_xy . render ( sys_render , xs_list , camera = \"targetfar\" ) mediapy . show_video ([ frame [ ... , : 3 ] for frame in frames ], fps = int ( 1 / sys . dt ))","title":"Notebook"},{"location":"prism/ss_23_moritz/notebook/#training-the-rnno-with-a-custom-loss-function","text":"This notebook showcases how train an RNNo network with a custom loss function rather than the default mean-reduces angle error. This is showcased by scaling the error by a softmax over the time axis, which puts more weight on the time intervals with a higher deviation compared to ones with lower deviation. import jax import jax.numpy as jnp import tree_utils from jax.nn import softmax import matplotlib.pyplot as plt import mediapy import x_xy from x_xy.subpkgs import ml , sim2real , sys_composer Set the batch size and number of training episodes according to the available hardware. BATCHSIZE = 32 NUM_TRAINING_EPISODES = 1500","title":"Training the RNNo with a custom loss function"},{"location":"prism/ss_23_moritz/notebook/#defining-the-systems","text":"We use two separate systems, both parsed from XML strings: one for training ( sys ) and one for inference ( dustin_sys ). sys_str = r \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"orange\"></geom> </defaults> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"red\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"red\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . io . load_sys_from_str ( sys_str ) dustin_exp_xml_seg1 = r \"\"\" <x_xy model=\"dustin_exp\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"white\"></geom> </defaults> <worldbody> <body joint=\"free\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg2\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"rz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys_inference = x_xy . io . load_sys_from_str ( dustin_exp_xml_seg1 )","title":"Defining the systems"},{"location":"prism/ss_23_moritz/notebook/#generating-the-motion-data","text":"Our motion data will be automatically generated using a Generator , which can be customised using an MotionConfig . The Generator will generate data for both q , that is the state of all the joint angles in the system, as well as xs , which describes the orientations of all the links in the system. To use this data for training our RNNo, we first have to bring it into the correct form using a finalise_fn . def finalise_fn ( key : jax . Array , q : jax . Array , xs : x_xy . Transform , sys : x_xy . System ): def xs_by_name ( name : str ): return xs . take ( sys . name_to_idx ( name ), axis = 1 ) key , * consume = jax . random . split ( key , 3 ) # the input X to our RNNo is the IMU data of segments 1 and 3 X = { \"seg1\" : x_xy . imu ( xs_by_name ( \"imu1\" ), sys . gravity , sys . dt , consume [ 0 ], True ), \"seg3\" : x_xy . imu ( xs_by_name ( \"imu2\" ), sys . gravity , sys . dt , consume [ 1 ], True ), } # seg2 has no IMU, but we still need to make an entry in our X X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) # the output of the RNNo is the estimated relative poses of our segments y = x_xy . algorithms . rel_pose ( sys_scan = sys_inference , xs = xs , sys_xs = sys ) return X , y config = x_xy . algorithms . MotionConfig ( dpos_max = 0.3 , ang0_min = 0.0 , ang0_max = 0.0 ) gen = x_xy . build_generator ( sys , config , finalize_fn = finalise_fn ) gen = x_xy . batch_generator ( gen , BATCHSIZE )","title":"Generating the motion data"},{"location":"prism/ss_23_moritz/notebook/#custom-loss-function","text":"To customise the loss function of the RNNo, we transform the error values before they are averaged. The input to our loss function will be both \\(q\\) , the real joint state, as well as \\(\\hat{q}\\) , the joint space estimated by our RNNo. q and q_hat will both be jax.Array s of shape (T_tbp, 4) , where the first axis is slice over time (of our TBPTT length) and the second axis are the 4 components of a quaternion. In this notebook we want to change the relative weightings of the errors at different times using a softmax function in order to put more weight on larger errors. First we convert the errors from quaterions to angles. Then we scale each error angle by a factor, calculated from a softmax over the angles. The calculation of the factors includes a call to jax.lax.stop_gradient to make it so our gradients are only from the errors themselves, not the factors as well. def make_loss_fn ( beta ): def metric_fn ( q , q_hat ): return x_xy . maths . angle_error ( q , q_hat ) ** 2 if beta is not None : def loss_fn ( q , q_hat ): # q.shape == q_hat.shape == (1000, 4) angles = metric_fn ( q , q_hat ) factors = angles . shape [ - 1 ] * softmax ( beta * jax . lax . stop_gradient ( angles ), axis =- 1 ) errors = factors * angles return errors else : loss_fn = metric_fn return loss_fn beta determines the strength of our weighting: the larger beta, the more relative weight we put on the larger errors, while beta = 0.0 makes the scaling factors uniform one and gives us back our unweighted errors. Alternatively beta = None bypasses the scaling altogether. beta = 1.0 rnno = ml . make_rnno ( sys_inference ) loss_fn = make_loss_fn ( beta ) save_params = ml . callbacks . SaveParamsTrainingLoopCallback ( \"parameters.pickle\" , upload = False ) ml . train ( gen , NUM_TRAINING_EPISODES , rnno , callbacks = [ save_params ], loss_fn = loss_fn ) To visualise our network, we can render it using mediapy. First we generate some motion data. gen = x_xy . build_generator ( sys , config ) key = jax . random . PRNGKey ( 1 ) q , xs = gen ( key ) We need to again bring the motion data in the correct form for our RNNo and can then run inference of the generated data. params = ml . load ( \"parameters.pickle\" ) X , y = finalise_fn ( key , q , xs , sys ) X = tree_utils . add_batch_dim ( X ) _ , state = rnno . init ( key , X ) state = tree_utils . add_batch_dim ( state ) y_hat , _ = rnno . apply ( params , state , X ) y_hat = tree_utils . to_2d_if_3d ( y_hat , strict = True ) First we want to plot the angle error for both segment 2 and segment 3 over time. y [ \"seg2\" ][: 10 ] y_hat [ \"seg2\" ] fig , ax = plt . subplots () angle_error2 = jnp . rad2deg ( x_xy . maths . angle_error ( y [ \"seg2\" ], y_hat [ \"seg2\" ])) angle_error3 = jnp . rad2deg ( x_xy . maths . angle_error ( y [ \"seg3\" ], y_hat [ \"seg3\" ])) T = jnp . arange ( angle_error2 . size ) * sys_inference . dt ax . plot ( T , angle_error2 , label = \"seg2\" ) ax . plot ( T , angle_error3 , label = \"seg3\" ) ax . set_xlabel ( \"time [s]\" ) ax . set_ylabel ( \"abs. angle error [deg]\" ) ax . legend () plt . show () Next we have to create an xs_hat of the estimated orientations, so that we can render them. # Extract translations from data-generating system... translations , rotations = sim2real . unzip_xs ( sys_inference , sim2real . match_xs ( sys_inference , xs , sys ) ) y_hat_inv = jax . tree_map ( lambda quat : x_xy . maths . quat_inv ( quat ), y_hat ) # ... swap rotations with predicted ones... rotations_hat = [] for i , name in enumerate ( sys_inference . link_names ): if name in y_hat_inv : rotations_name = x_xy . Transform . create ( rot = y_hat_inv [ name ]) else : rotations_name = rotations . take ( i , axis = 1 ) rotations_hat . append ( rotations_name ) # ... and plug the positions and rotations back together. rotations_hat = rotations_hat [ 0 ] . batch ( * rotations_hat [ 1 :]) . transpose (( 1 , 0 , 2 )) xs_hat = sim2real . zip_xs ( sys_inference , translations , rotations_hat ) # Create combined system that shall be rendered and its transforms sys_render = sys_composer . inject_system ( sys , sys_inference . add_prefix_suffix ( suffix = \"_hat\" )) xs_render = x_xy . Transform . concatenate ( xs , xs_hat , axis = 1 ) Now we can render both the predicted system (in white) as well as the real system (in orange). xs_list = [ xs_render [ i ] for i in range ( xs_render . shape ())] frames = x_xy . render ( sys_render , xs_list , camera = \"targetfar\" ) mediapy . show_video ([ frame [ ... , : 3 ] for frame in frames ], fps = int ( 1 / sys . dt ))","title":"Custom loss function"}]}