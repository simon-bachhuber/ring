{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Recurrent Inertial Graph-based Estimator (RING) \u00a4 \u2139\ufe0f Tip: Check out my new plug-and-play interface for inertial motion tracking (RING included) here . Installation \u00a4 Supports Python=3.10/3.11/3.12 (tested). Install with pip using pip install imt-ring Typically, this will install jax as cpu-only version. Afterwards, gpu-enabled version can be installed with pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html Documentation \u00a4 Available here . Quickstart Example \u00a4 import ring import numpy as np T : int = 30 # sequence length [s] Ts : float = 0.01 # sampling interval [s] B : int = 1 # batch size lam : list [ int ] = [ 0 , 1 , 2 ] # parent array N : int = len ( lam ) # number of bodies T_i : int = int ( T / Ts ) # number of timesteps X = np . zeros (( B , T_i , N , 9 )) # where X is structured as follows: # X[..., :3] = acc # X[..., 3:6] = gyr # X[..., 6:9] = jointaxis # let's assume we have an IMU on each outer segment of the # three-segment kinematic chain X [ ... , 0 , : 3 ] = acc_segment1 X [ ... , 2 , : 3 ] = acc_segment3 X [ ... , 0 , 3 : 6 ] = gyr_segment1 X [ ... , 2 , 3 : 6 ] = gyr_segment3 ringnet = ring . RING ( lam , Ts ) yhat , _ = ringnet . apply ( X ) # yhat: unit quaternions, shape = (B, T_i, N, 4) Known fixes \u00a4 Offscreen rendering with Mujoco \u00a4 mujoco.FatalError: an OpenGL platform library has not been loaded into this process, this most likely means that a valid OpenGL context has not been created before mjr_makeContext was called Solution: import os os . environ [ \"MUJOCO_GL\" ] = \"egl\" Windows-related: ImportError: DLL load failed while importing ... \u00a4 ImportError: DLL load failed while importing _multiarray_umath: Das angegebene Modul wurde nicht gefunden. Solution: 1. pip uninstall -y jax jaxlib 2. conda install -c conda-forge jax Publications \u00a4 The following publications utilize this software library, and refer to it as the Random Chain Motion Generator (RCMG) (more specifically the function ring.RCMG ): RNN-based Observability Analysis for Magnetometer-Free Sparse Inertial Motion Tracking Plug-and-Play Sparse Inertial Motion Tracking With Sim-to-Real Transfer RNN-based State and Parameter Estimation for Sparse Magnetometer-free Inertial Motion Tracking Other useful ressources \u00a4 Particularly useful is the following publication from Roy Featherstone - A Beginner\u2019s Guide to 6-D Vectors (Part 2) Contact \u00a4 Simon Bachhuber (simon.bachhuber@fau.de)","title":"Home"},{"location":"#recurrent-inertial-graph-based-estimator-ring","text":"\u2139\ufe0f Tip: Check out my new plug-and-play interface for inertial motion tracking (RING included) here .","title":"Recurrent Inertial Graph-based Estimator (RING)"},{"location":"#installation","text":"Supports Python=3.10/3.11/3.12 (tested). Install with pip using pip install imt-ring Typically, this will install jax as cpu-only version. Afterwards, gpu-enabled version can be installed with pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html","title":"Installation"},{"location":"#documentation","text":"Available here .","title":"Documentation"},{"location":"#quickstart-example","text":"import ring import numpy as np T : int = 30 # sequence length [s] Ts : float = 0.01 # sampling interval [s] B : int = 1 # batch size lam : list [ int ] = [ 0 , 1 , 2 ] # parent array N : int = len ( lam ) # number of bodies T_i : int = int ( T / Ts ) # number of timesteps X = np . zeros (( B , T_i , N , 9 )) # where X is structured as follows: # X[..., :3] = acc # X[..., 3:6] = gyr # X[..., 6:9] = jointaxis # let's assume we have an IMU on each outer segment of the # three-segment kinematic chain X [ ... , 0 , : 3 ] = acc_segment1 X [ ... , 2 , : 3 ] = acc_segment3 X [ ... , 0 , 3 : 6 ] = gyr_segment1 X [ ... , 2 , 3 : 6 ] = gyr_segment3 ringnet = ring . RING ( lam , Ts ) yhat , _ = ringnet . apply ( X ) # yhat: unit quaternions, shape = (B, T_i, N, 4)","title":"Quickstart Example"},{"location":"#known-fixes","text":"","title":"Known fixes"},{"location":"#offscreen-rendering-with-mujoco","text":"mujoco.FatalError: an OpenGL platform library has not been loaded into this process, this most likely means that a valid OpenGL context has not been created before mjr_makeContext was called Solution: import os os . environ [ \"MUJOCO_GL\" ] = \"egl\"","title":"Offscreen rendering with Mujoco"},{"location":"#windows-related-importerror-dll-load-failed-while-importing","text":"ImportError: DLL load failed while importing _multiarray_umath: Das angegebene Modul wurde nicht gefunden. Solution: 1. pip uninstall -y jax jaxlib 2. conda install -c conda-forge jax","title":"Windows-related: ImportError: DLL load failed while importing ..."},{"location":"#publications","text":"The following publications utilize this software library, and refer to it as the Random Chain Motion Generator (RCMG) (more specifically the function ring.RCMG ): RNN-based Observability Analysis for Magnetometer-Free Sparse Inertial Motion Tracking Plug-and-Play Sparse Inertial Motion Tracking With Sim-to-Real Transfer RNN-based State and Parameter Estimation for Sparse Magnetometer-free Inertial Motion Tracking","title":"Publications"},{"location":"#other-useful-ressources","text":"Particularly useful is the following publication from Roy Featherstone - A Beginner\u2019s Guide to 6-D Vectors (Part 2)","title":"Other useful ressources"},{"location":"#contact","text":"Simon Bachhuber (simon.bachhuber@fau.de)","title":"Contact"},{"location":"api/","text":"API \u00a4 RING \u00a4 RING \u00a4 RING ( lam , Ts , ** kwargs ) Creates the RING network. Parameters: lam ( list [ int ] | None ) \u2013 parent array, if None must be given via ringnet.apply(..., lam=lam) Ts \u2013 sampling interval of IMU data; time delta in seconds Returns: AbstractFilter \u2013 ring.ml.AbstractFilter: An instantiation of ring.ml.ringnet.RING with trained parameters. Examples: >>> import ring >>> import numpy as np >>> >>> T : int = 30 # sequence length [s] >>> Ts : float = 0.01 # sampling interval [s] >>> B : int = 1 # batch size >>> lam : list [ int ] = [ 0 , 1 , 2 ] # parent array >>> N : int = len ( lam ) # number of bodies >>> T_i : int = int ( T / Ts ) # number of timesteps >>> >>> X = np . zeros (( B , T_i , N , 9 )) >>> # where X is structured as follows: >>> # X[..., :3] = acc >>> # X[..., 3:6] = gyr >>> # X[..., 6:9] = jointaxis >>> >>> # let's assume we have an IMU on each outer segment of the >>> # three-segment kinematic chain >>> X [:, :, 0 , : 3 ] = acc_segment1 >>> X [:, :, 2 , : 3 ] = acc_segment3 >>> X [:, :, 0 , 3 : 6 ] = gyr_segment1 >>> X [:, :, 2 , 3 : 6 ] = gyr_segment3 >>> >>> ringnet = ring . RING ( lam , Ts ) >>> >>> yhat , _ = ringnet . apply ( X ) >>> # yhat : unit quaternions, shape = (B, T_i, N, 4) >>> # yhat[b, :, i] is the orientation from body `i` to parent body `lam[i]` >>> >>> # use `jax.jit` to compile the forward pass >>> jit_apply = jax . jit ( ringnet . apply ) >>> yhat , _ = jit_apply ( X ) >>> >>> # manually pass in and out the hidden state like so >>> initial_state = None >>> yhat , state = ringnet . apply ( X , state = initial_state ) >>> # state: final hidden state, shape = (B, N, 2*H) RING \u00a4 __init__ \u00a4 __init__ ( params = None , lam = None , jit = True , name = None , forward_factory = make_ring , ** kwargs ) Untrained RING network RCMG \u00a4 RCMG \u00a4 __init__ \u00a4 __init__ ( sys , config = jcalc . MotionConfig (), setup_fn = None , finalize_fn = None , add_X_imus = False , add_X_imus_kwargs = dict (), add_X_jointaxes = False , add_X_jointaxes_kwargs = dict (), add_y_relpose = False , add_y_rootincl = False , add_y_rootincl_kwargs = dict (), add_y_rootfull = False , add_y_rootfull_kwargs = dict (), sys_ml = None , randomize_positions = False , randomize_motion_artifacts = False , randomize_joint_params = False , randomize_hz = False , randomize_hz_kwargs = dict (), imu_motion_artifacts = False , imu_motion_artifacts_kwargs = dict (), dynamic_simulation = False , dynamic_simulation_kwargs = dict (), output_transform = None , keep_output_extras = False , use_link_number_in_Xy = False , cor = False , disable_tqdm = False ) Initializes the Random Chain Motion Generator (RCMG). The RCMG generates synthetic joint motion sequences for kinematic and dynamic systems based on predefined motion configurations. It allows for system randomization, augmentation with IMU and joint axis data, and optional dynamic simulation. Parameters: sys ( System | list [ System ] ) \u2013 The system(s) for which motion should be generated. config ( MotionConfig | list [ MotionConfig ] , default: MotionConfig () ) \u2013 Motion configuration(s) defining velocity limits, interpolation methods, and range constraints. Defaults to jcalc.MotionConfig() . setup_fn ( Optional [ SETUP_FN ] , default: None ) \u2013 A function to modify the system before motion generation. Defaults to None . finalize_fn ( Optional [ FINALIZE_FN ] , default: None ) \u2013 A function to modify outputs after motion generation. Defaults to None . add_X_imus ( bool , default: False ) \u2013 Whether to add IMU sensor data to the output. Defaults to False . add_X_imus_kwargs ( dict , default: dict () ) \u2013 Additional keyword arguments for IMU data processing. Defaults to {} . add_X_jointaxes ( bool , default: False ) \u2013 Whether to add joint axis data to the output. Defaults to False . add_X_jointaxes_kwargs ( dict , default: dict () ) \u2013 Additional keyword arguments for joint axis data processing. Defaults to {} . add_y_relpose ( bool , default: False ) \u2013 Whether to add relative pose targets to the output. Defaults to False . add_y_rootincl ( bool , default: False ) \u2013 Whether to add root inclination targets to the output. Defaults to False . add_y_rootincl_kwargs ( dict , default: dict () ) \u2013 Additional keyword arguments for root inclination processing. Defaults to {} . add_y_rootfull ( bool , default: False ) \u2013 Whether to add full root state targets to the output. Defaults to False . add_y_rootfull_kwargs ( dict , default: dict () ) \u2013 Additional keyword arguments for full root state processing. Defaults to {} . sys_ml ( Optional [ System ] , default: None ) \u2013 System that defines the graph and naming structure of the X and y outputs. Defaults to None which then uses the first provided system. randomize_positions ( bool , default: False ) \u2013 Whether to randomised positions based on pos_min and pos_max . Defaults to False . randomize_motion_artifacts ( bool , default: False ) \u2013 Whether to randomize the IMU motion artifact simulation. This randomises the spring stiffness and spring damping parameters of the passive free joint that is added between nonrigid and rigid IMU. Defaults to False . randomize_joint_params ( bool , default: False ) \u2013 Whether to randomize joint parameters by calling JointModel.init_joint_params before every sequence generation. Defaults to False . randomize_hz ( bool , default: False ) \u2013 Whether to randomize the sampling frequency of the generated data. Defaults to False . randomize_hz_kwargs ( dict , default: dict () ) \u2013 Additional keyword arguments for sampling frequency randomization. Defaults to {} . imu_motion_artifacts ( bool , default: False ) \u2013 Whether to simulate nonrigid IMU motion artifacts. Defaults to False . imu_motion_artifacts_kwargs ( dict , default: dict () ) \u2013 Additional keyword arguments for IMU motion artifact simulation. Defaults to {} . dynamic_simulation ( bool , default: False ) \u2013 Whether to use a physics-based simulation to generate motion instead of purely kinematic methods. Defaults to False . dynamic_simulation_kwargs ( dict , default: dict () ) \u2013 Additional keyword arguments for dynamic simulation. Defaults to {} . output_transform ( Optional [ Callable ] , default: None ) \u2013 A function to transform the generated output data. Defaults to None . keep_output_extras ( bool , default: False ) \u2013 Whether to keep additional output metadata. Defaults to False . use_link_number_in_Xy ( bool , default: False ) \u2013 Whether to replace joint names with numerical indices in the output. Defaults to False . cor ( bool , default: False ) \u2013 Whether to replace free joints with center-of-rotation (COR) 9D free joint. Defaults to False . disable_tqdm ( bool , default: False ) \u2013 Whether to disable progress bars during generation. Defaults to False . Raises: AssertionError \u2013 If any of the provided MotionConfig instances are infeasible. Notes This class supports batch generation, lazy and eager data loading, and motion augmentation. If randomize_hz=True , the time step ( dt ) varies according to the specified sampling rates. When cor=True , free joints are replaced with center-of-rotation models, affecting joint motion behavior. to_lazy_gen \u00a4 to_lazy_gen ( sizes = 1 , jit = True ) Returns a generator X, y = gen(key) that lazily generates batched sequences. to_list \u00a4 to_list ( sizes = 1 , seed = 1 ) Returns list of unbatched sequences as numpy arrays. to_folder \u00a4 to_folder ( path , sizes = 1 , seed = 1 , overwrite = True , file_prefix = 'seq' , save_fn = partial ( utils . pickle_save , overwrite = True ), verbose = True ) Stores unbatched sequences as numpy arrays into folder. to_eager_gen \u00a4 to_eager_gen ( batchsize = 1 , sizes = 1 , seed = 1 , shuffle = True , transform = None ) Returns a generator X, y = gen(key) that returns precomputed batched sequences. System \u00a4 System \u00a4 Represents a robotic system consisting of interconnected links and joints. Create it using System.create(...) The System class models the kinematic and dynamic properties of a multibody system, providing methods for state representation, transformations, joint configuration management, and rendering. It supports both minimal and maximal coordinate representations and can be parsed from or saved to XML files. Attributes: link_parents ( list [ int ] ) \u2013 A list specifying the parent index for each link. The root link has a parent index of -1 . links ( Link ) \u2013 A data structure containing information about all links in the system. link_types ( list [ str ] ) \u2013 A list specifying the joint type for each link (e.g., \"free\", \"hinge\", \"prismatic\"). link_damping ( Array ) \u2013 Joint damping coefficients for each link. link_armature ( Array ) \u2013 Armature inertia values for each joint. link_spring_stiffness ( Array ) \u2013 Stiffness values for joint springs. link_spring_zeropoint ( Array ) \u2013 Rest position of joint springs. dt ( float ) \u2013 Simulation time step size. geoms ( list [ Geometry ] ) \u2013 List of geometries associated with the system. gravity ( Array ) \u2013 Gravity vector applied to the system (default: [0, 0, -9.81] ). integration_method ( str ) \u2013 Integration method for simulation (default: \"semi_implicit_euler\"). mass_mat_iters ( int ) \u2013 Number of iterations for mass matrix calculations. link_names ( list [ str ] ) \u2013 Names of the links in the system. model_name ( Optional [ str ] ) \u2013 Name of the system model (if available). omc ( list [ MaxCoordOMC | None] ) \u2013 List of optional Maximal Coordinate representations. Methods: Name Description num_links Returns the number of links in the system. q_size Returns the total number of generalized coordinates ( q ) in the system. qd_size Returns the total number of generalized velocities ( qd ) in the system. name_to_idx str) -> int: Returns the index of a link given its name. idx_to_name int, allow_world: bool = False) -> str: Returns the name of a link given its index. If allow_world is True , returns \"world\" for index -1 . idx_map str) -> dict: Returns a dictionary mapping link names to their indices for a specified type ( \"l\" , \"q\" , or \"d\" ). parent_name str) -> str: Returns the name of the parent link for a given link. change_model_name Optional[str] = None, prefix: Optional[str] = None, suffix: Optional[str] = None) -> \"System\": Changes the name of the system model. change_link_name str, new_name: str) -> \"System\": Renames a specific link. add_prefix_suffix Optional[str] = None, suffix: Optional[str] = None) -> \"System\": Adds both a prefix and suffix to all link names. freeze str | list[str]) -> \"System\": Freezes the specified link(s), making them immovable. unfreeze str, new_joint_type: str) -> \"System\": Unfreezes a frozen link and assigns it a new joint type. change_joint_type str, new_joint_type: str, **kwargs) -> \"System\": Changes the joint type of a specified link. joint_type_simplification str) -> str: Returns a simplified representation of the given joint type. joint_type_is_free_or_cor str) -> bool: Checks if a joint type is either \"free\" or \"cor\". joint_type_is_spherical str) -> bool: Checks if a joint type is \"spherical\". joint_type_is_free_or_cor_or_spherical str) -> bool: Checks if a joint type is \"free\", \"cor\", or \"spherical\". findall_imus bool = True) -> list[str] | list[int]: Finds all IMU sensors in the system. findall_segments bool = True) -> list[str] | list[int]: Finds all non-IMU segments in the system. findall_bodies_to_world bool = False) -> list[int] | list[str]: Returns all bodies directly connected to the world. find_body_to_world bool = False) -> int | str: Returns the root body connected to the world. findall_bodies_with_jointtype str, names: bool = False) -> list[int] | list[str]: Returns all bodies with the specified joint type. children str, names: bool = False) -> list[int] | list[str]: Returns the direct children of a given body. findall_bodies_subsystem str, names: bool = False) -> list[int] | list[str]: Finds all bodies in the subsystem rooted at a given link. scan Callable, in_types: str, *args, reverse: bool = False): Iterates over system elements while applying a function. parse Parses the system, performing consistency checks and computing spatial inertia tensors. render Optional[Transform | list[Transform]] = None, **kwargs) -> list[np.ndarray]: Renders frames of the system using maximal coordinates. render_prediction Transform | list[Transform], yhat: dict | jax.Array | np.ndarray, **kwargs): Renders a predicted state transformation. delete_system str | list[str], strict: bool = True): Removes a subsystem from the system. make_sys_noimu Optional[list[str]] = None): Returns a version of the system without IMU sensors. inject_system \"System\", at_body: Optional[str] = None): Merges another system into this one. morph_system Optional[list[int | str]] = None, new_anchor: Optional[int | str] = None): Reorders the system\u2019s link hierarchy. from_xml str, seed: int = 1) -> \"System\": Loads a system from an XML file. from_str str, seed: int = 1) -> \"System\": Loads a system from an XML string. to_str bool = True) -> str: Serializes the system to an XML string. to_xml str) -> None: Saves the system as an XML file. create str, seed: int = 1) -> \"System\": Creates a System instance from an XML file or string. coordinate_vector_to_q jax.Array, custom_joints: dict[str, Callable] = {}) -> jax.Array: Converts a coordinate vector to minimal coordinates ( q ), applying constraints such as quaternion normalization. Raises: AssertionError \u2013 If the system structure is invalid (e.g., duplicate link names, incorrect parent-child relationships). InvalidSystemError \u2013 If an operation results in an inconsistent system state. Notes The system must be parsed before use to ensure consistency. The system supports batch operations using JAX for efficient computations. Joint types include revolute (\"rx\", \"ry\", \"rz\"), prismatic (\"px\", \"py\", \"pz\"), spherical, free, and more. Inertial properties of links are computed automatically from associated geometries. num_links \u00a4 num_links () Returns the number of links in the system. q_size \u00a4 q_size () Returns the total number of generalized coordinates ( q ) in the system. qd_size \u00a4 qd_size () Returns the total number of generalized velocities ( qd ) in the system. name_to_idx \u00a4 name_to_idx ( name ) Returns the index of a link given its name. idx_to_name \u00a4 idx_to_name ( idx , allow_world = False ) Returns the name of a link given its index. If allow_world is True , returns \"world\" for index -1 . idx_map \u00a4 idx_map ( type ) Returns a dictionary mapping link names to their indices for a specified type ( \"l\" , \"q\" , or \"d\" ). parent_name \u00a4 parent_name ( name ) Returns the name of the parent link for a given link. change_model_name \u00a4 change_model_name ( new_name = None , prefix = None , suffix = None ) Changes the name of the system model. change_link_name \u00a4 change_link_name ( old_name , new_name ) Renames a specific link. add_prefix_suffix \u00a4 add_prefix_suffix ( prefix = None , suffix = None ) Adds either or, or both a prefix and suffix to all link names. freeze \u00a4 freeze ( name ) Freezes the specified link(s), making them immovable (uses frozen joint) unfreeze \u00a4 unfreeze ( name , new_joint_type ) Unfreezes a frozen link and assigns it a new joint type. change_joint_type \u00a4 change_joint_type ( name , new_joint_type , new_arma = None , new_damp = None , new_stif = None , new_zero = None , seed = 1 , warn = True ) Changes the joint type of a specified link. By default damping, stiffness are set to zero. joint_type_simplification staticmethod \u00a4 joint_type_simplification ( typ ) Returns a simplified name of the given joint type. joint_type_is_free_or_cor staticmethod \u00a4 joint_type_is_free_or_cor ( typ ) Checks if a joint type is either \"free\" or \"cor\". joint_type_is_spherical staticmethod \u00a4 joint_type_is_spherical ( typ ) Checks if a joint type is \"spherical\". joint_type_is_free_or_cor_or_spherical staticmethod \u00a4 joint_type_is_free_or_cor_or_spherical ( typ ) Checks if a joint type is \"free\", \"cor\", or \"spherical\". findall_imus \u00a4 findall_imus ( names = True ) Finds all IMU sensors in the system. findall_segments \u00a4 findall_segments ( names = True ) Finds all non-IMU segments in the system. findall_bodies_to_world \u00a4 findall_bodies_to_world ( names = False ) Returns all bodies directly connected to the world. find_body_to_world \u00a4 find_body_to_world ( name = False ) Returns the root body connected to the world. findall_bodies_with_jointtype \u00a4 findall_bodies_with_jointtype ( typ , names = False ) Returns all bodies with the specified joint type. children \u00a4 children ( name , names = False ) List all direct children of body, does not include body itself findall_bodies_subsystem \u00a4 findall_bodies_subsystem ( name , names = False ) List all children and children's children; does not include body itself scan \u00a4 scan ( f , in_types , * args , reverse = False ) Scan f along each link in system whilst carrying along state. Parameters: f ( Callable [..., Y ] ) \u2013 f(y: Y, *args) -> y in_types ( str ) \u2013 string specifying the type of each input arg: 'l' is an input to be split according to link ranges 'q' is an input to be split according to q ranges 'd' is an input to be split according to qd ranges args \u2013 Arguments passed to f , and split to match the link. reverse ( bool , default: False ) \u2013 If true from leaves to root. Defaults to False. Returns: ys \u2013 Stacked output y of f. parse \u00a4 parse () Initial setup of system. System object does not work unless it is parsed. Currently it does: - some consistency checks - populate the spatial inertia tensors - check that all names are unique - check that names are strings - check that all pos_min <= pos_max (unless traced) - order geoms in ascending order based on their parent link idx - check that all links have the correct size of - damping - armature - stiffness - zeropoint - check that n_links == len(sys.omc) render \u00a4 render ( xs = None , camera = None , show_pbar = True , backend = 'mujoco' , render_every_nth = 1 , ** scene_kwargs ) Render frames from system and trajectory of maximal coordinates xs . Parameters: sys ( System ) \u2013 System to render. xs ( Transform | list [ Transform ] , default: None ) \u2013 Single or time-series show_pbar ( bool , default: True ) \u2013 Whether or not to show a progress bar. Returns: list [ ndarray ] \u2013 list[np.ndarray]: Stacked rendered frames. Length == len(xs). render_prediction \u00a4 render_prediction ( xs , yhat , transparent_segment_to_root = True , ** kwargs ) xs matches sys . yhat matches sys_noimu . yhat are child-to-parent. Note that the body in yhat that connects to -1, is parent-to-child! delete_system \u00a4 delete_system ( link_name , strict = True ) Cut subsystem starting at link_name (inclusive) from tree. make_sys_noimu \u00a4 make_sys_noimu ( imu_link_names = None ) Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'} inject_system \u00a4 inject_system ( other_system , at_body = None ) Combine two systems into one. Parameters: sys ( System ) \u2013 Large system. sub_sys ( System ) \u2013 Small system that will be included into the large system sys . at_body ( Optional [ str ] , default: None ) \u2013 Into which body of the large system small system will be included. Defaults to worldbody . Returns: \u2013 base.System: description morph_system \u00a4 morph_system ( new_parents = None , new_anchor = None ) Re-orders the graph underlying the system. Returns a new system. Parameters: sys ( System ) \u2013 System to be modified. new_parents ( list [ int ] , default: None ) \u2013 Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system. Returns: \u2013 base.System: Modified system. from_xml staticmethod \u00a4 from_xml ( path , seed = 1 ) Loads a system from an XML file. from_str staticmethod \u00a4 from_str ( xml , seed = 1 ) Loads a system from an XML string. to_str \u00a4 to_str ( warn = True ) Serializes the system to an XML string. to_xml \u00a4 to_xml ( path ) Saves the system to an XML file. create classmethod \u00a4 create ( path_or_str , seed = 1 ) Creates a System instance from an XML file or string. coordinate_vector_to_q \u00a4 coordinate_vector_to_q ( q , custom_joints = {}) Converts a coordinate vector to minimal coordinates ( q ), applying constraints such as quaternion normalization. MotionConfig \u00a4 MotionConfig dataclass \u00a4 Configuration for joint motion generation in kinematic and dynamic simulations. This class defines the constraints and parameters for generating random joint motions, including angular and positional velocity limits, interpolation methods, and range restrictions for various joint types. Attributes: T ( float ) \u2013 Total duration of the motion sequence (in seconds). t_min ( float ) \u2013 Minimum time interval between two generated joint states. t_max ( float | TimeDependentFloat ) \u2013 Maximum time interval between two generated joint states. dang_min ( float | TimeDependentFloat ) \u2013 Minimum angular velocity (rad/s). dang_max ( float | TimeDependentFloat ) \u2013 Maximum angular velocity (rad/s). dang_min_free_spherical ( float | TimeDependentFloat ) \u2013 Minimum angular velocity for free and spherical joints. dang_max_free_spherical ( float | TimeDependentFloat ) \u2013 Maximum angular velocity for free and spherical joints. delta_ang_min ( float | TimeDependentFloat ) \u2013 Minimum allowed change in joint angle (radians). delta_ang_max ( float | TimeDependentFloat ) \u2013 Maximum allowed change in joint angle (radians). delta_ang_min_free_spherical ( float | TimeDependentFloat ) \u2013 Minimum allowed change in angle for free/spherical joints. delta_ang_max_free_spherical ( float | TimeDependentFloat ) \u2013 Maximum allowed change in angle for free/spherical joints. dpos_min ( float | TimeDependentFloat ) \u2013 Minimum translational velocity. dpos_max ( float | TimeDependentFloat ) \u2013 Maximum translational velocity. pos_min ( float | TimeDependentFloat ) \u2013 Minimum position constraint. pos_max ( float | TimeDependentFloat ) \u2013 Maximum position constraint. pos_min_p3d_x ( float | TimeDependentFloat ) \u2013 Minimum position in x-direction for P3D joints. pos_max_p3d_x ( float | TimeDependentFloat ) \u2013 Maximum position in x-direction for P3D joints. pos_min_p3d_y ( float | TimeDependentFloat ) \u2013 Minimum position in y-direction for P3D joints. pos_max_p3d_y ( float | TimeDependentFloat ) \u2013 Maximum position in y-direction for P3D joints. pos_min_p3d_z ( float | TimeDependentFloat ) \u2013 Minimum position in z-direction for P3D joints. pos_max_p3d_z ( float | TimeDependentFloat ) \u2013 Maximum position in z-direction for P3D joints. cdf_bins_min ( int ) \u2013 Minimum number of bins for cumulative distribution function (CDF)-based random sampling. cdf_bins_max ( Optional [ int ] ) \u2013 Maximum number of bins for CDF-based sampling. randomized_interpolation_angle ( bool ) \u2013 Whether to use randomized interpolation for angular motion. randomized_interpolation_position ( bool ) \u2013 Whether to use randomized interpolation for positional motion. interpolation_method ( str ) \u2013 Interpolation method to be used (default: \"cosine\"). range_of_motion_hinge ( bool ) \u2013 Whether to enforce range-of-motion constraints on hinge joints. range_of_motion_hinge_method ( str ) \u2013 Method used for range-of-motion enforcement (e.g., \"uniform\", \"sigmoid\"). rom_halfsize ( float | TimeDependentFloat ) \u2013 Half-size of the range of motion restriction. ang0_min ( float ) \u2013 Minimum initial joint angle. ang0_max ( float ) \u2013 Maximum initial joint angle. pos0_min ( float ) \u2013 Minimum initial joint position. pos0_max ( float ) \u2013 Maximum initial joint position. cor_t_min ( float ) \u2013 Minimum time step for center-of-rotation (COR) joints. cor_t_max ( float | TimeDependentFloat ) \u2013 Maximum time step for COR joints. cor_dpos_min ( float | TimeDependentFloat ) \u2013 Minimum velocity for COR translation. cor_dpos_max ( float | TimeDependentFloat ) \u2013 Maximum velocity for COR translation. cor_pos_min ( float | TimeDependentFloat ) \u2013 Minimum position for COR translation. cor_pos_max ( float | TimeDependentFloat ) \u2013 Maximum position for COR translation. cor_pos0_min ( float ) \u2013 Initial minimum position for COR translation. cor_pos0_max ( float ) \u2013 Initial maximum position for COR translation. joint_type_specific_overwrites ( dict [ str , dict [ str , Any ]] ) \u2013 A dictionary mapping joint types to specific motion configuration overrides. Methods: Name Description is_feasible Checks if the motion configuration satisfies all constraints. to_nomotion_config Returns a new MotionConfig where all velocities and angle changes are set to zero. overwrite_for_joint_type Applies specific configuration changes for a given joint type. Note: These changes affect all instances of MotionConfig for this joint type. overwrite_for_subsystem Modifies the motion configuration for all joints in a subsystem rooted at link_name . from_register Retrieves a predefined MotionConfig from the global registry. overwrite_for_joint_type staticmethod \u00a4 overwrite_for_joint_type ( joint_type , ** changes ) Changes values of the MotionConfig used by the draw_fn for only a specific joint. Note This applies these changes to all MotionConfigs for this joint type! This takes precedence over Motionconfig.joint_type_specific_overwrites ! overwrite_for_subsystem staticmethod \u00a4 overwrite_for_subsystem ( sys , link_name , ** changes ) Modifies motionconfig of all joints in subsystem with root link_name . Note that if the subsystem contains a free joint then the jointtype will will be re-named to free_<link_name> , then the RCMG flag cor will potentially not work as expected because it searches for all joints of type free to replace with cor . The workaround here is to change the type already from free to cor in the xml file. This takes precedence *over* Motionconfig.joint_type_specific_overwrites`! Parameters: sys ( System ) \u2013 System object that gets updated link_name ( str ) \u2013 Root node of subsystem changes \u2013 Changes to apply to the motionconfig Return base.System: Updated system with new jointtypes join_motionconfigs \u00a4 join_motionconfigs ( configs , boundaries ) Joins multiple MotionConfig objects in time, transitioning between them at specified boundaries. This function takes a list of MotionConfig instances and a corresponding list of boundary times, and constructs a new MotionConfig that varies in time according to the provided segments. Parameters: configs ( list [ MotionConfig ] ) \u2013 A list of MotionConfig objects to be joined. boundaries ( list [ float ] ) \u2013 A list of time values where transitions between configs occur. Must have one element less than configs , as each boundary defines the transition point between two consecutive configurations. Returns: MotionConfig ( MotionConfig ) \u2013 A new MotionConfig object where time-dependent fields transition based on the MotionConfig \u2013 specified boundaries. Raises: AssertionError \u2013 If the number of boundaries does not match len(configs) - 1 . AssertionError \u2013 If time-independent fields have differing values across configs . Notes Only fields that are time-dependent ( float | TimeDependentFloat ) will change over time. Time-independent fields must be the same in all configs , or an error is raised. Extending the RCMG \u00a4 JointModel dataclass \u00a4 Represents the kinematic and dynamic properties of a joint type. A JointModel defines the mathematical functions required to compute joint transformations, motion, control terms, and inverse kinematics. It is used to describe the behavior of various joint types, including revolute, prismatic, spherical, and free joints. Attributes: transform ( Callable [[ Array , Array ], Transform ] ) \u2013 Computes the transformation (position and orientation) of the joint given the joint state q and joint parameters. motion ( list [ Motion | Callable [[ Array ], Motion ]] ) \u2013 Defines the joint motion model. It can be a list of Motion objects or callables that return Motion based on joint parameters. rcmg_draw_fn ( Optional [ DRAW_FN ] ) \u2013 Function used to generate a reference motion trajectory for the joint using Randomized Control Motion Generation (RCMG). p_control_term ( Optional [ P_CONTROL_TERM ] ) \u2013 Function that computes the proportional control term for the joint. qd_from_q ( Optional [ QD_FROM_Q ] ) \u2013 Function to compute joint velocity ( qd ) from joint positions ( q ). coordinate_vector_to_q ( Optional [ COORDINATE_VECTOR_TO_Q ] ) \u2013 Function that maps a coordinate vector to a valid joint state q , ensuring constraints (e.g., wrapping angles or normalizing quaternions). inv_kin ( Optional [ INV_KIN ] ) \u2013 Function that computes the inverse kinematics for the joint, mapping a desired transform to joint coordinates q . init_joint_params ( Optional [ INIT_JOINT_PARAMS ] ) \u2013 Function that initializes joint-specific parameters. utilities ( Optional [ dict [ str , Any ]] ) \u2013 Additional utility functions or metadata related to the joint model. Notes The transform function is essential for computing the joint's spatial transformation based on its generalized coordinates. The motion attribute describes how forces and torques affect the joint. The rcmg_draw_fn is used for RCMG motion generation. The coordinate_vector_to_q is critical for maintaining valid joint states. register_new_joint_type \u00a4 register_new_joint_type ( joint_type , joint_model , q_width , qd_width = None , overwrite = False ) Registers a new joint type with its corresponding JointModel and kinematic properties. This function allows the addition of custom joint types to the system by associating them with a JointModel , specifying their state and velocity dimensions, and optionally overwriting existing joint definitions. Parameters: joint_type ( str ) \u2013 Name of the new joint type to register. joint_model ( JointModel ) \u2013 The JointModel instance defining the kinematic and dynamic properties of the joint. q_width ( int ) \u2013 Number of generalized coordinates (degrees of freedom) required to represent the joint. qd_width ( Optional[int], default=None , default: None ) \u2013 Number of velocity coordinates associated with the joint. Defaults to q_width . overwrite ( bool, default=False , default: False ) \u2013 If True , allows overwriting an existing joint type. Otherwise, raises an error if the joint type already exists. Raises: AssertionError \u2013 If joint_type is \"default\" (reserved name). If joint_type already exists and overwrite=False . If qd_width is not provided and does not default to q_width . If joint_model.motion length does not match qd_width . Notes The function updates global dictionaries that store joint properties, including: _joint_types : Maps joint type names to JointModel instances. base.Q_WIDTHS : Stores the number of state coordinates for each joint type. base.QD_WIDTHS : Stores the number of velocity coordinates for each joint type. If overwrite=True , existing entries are removed before adding the new joint type. Ensures consistency between motion definitions and velocity coordinate dimensions. Example new_joint = JointModel ( transform = my_transform_fn , motion = [ base . Motion . create ( ang = jnp . array ([ 1 , 0 , 0 ]))], ) register_new_joint_type ( \"custom_hinge\" , new_joint , q_width = 1 ) Simulation \u00a4 State \u00a4 Represents the state of a dynamic system in minimal and maximal coordinates. The State class encapsulates both the configuration ( q ) and velocity ( qd ) of the system in minimal coordinates, as well as the corresponding transforms ( x ) in maximal coordinates. Attributes: q ( Array ) \u2013 The joint positions (generalized coordinates) of the system. The size of q matches sys.q_size() . qd ( Array ) \u2013 The joint velocities (generalized velocities) of the system. The size of qd matches sys.qd_size() . x ( Transform ) \u2013 The maximal coordinate representation of all system links, expressed as a Transform object. Methods: Name Description create System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None, x: Optional[Transform] = None, key: Optional[jax.Array] = None, custom_joints: dict[str, Callable] = {}) -> State: Creates a State instance for a given system with optional initial conditions. Usage sys = System.create(\"model.xml\") state = State.create(sys) print(state.q.shape) # Should match sys.q_size() print(state.qd.shape) # Should match sys.qd_size() create classmethod \u00a4 create ( sys , q = None , qd = None , x = None , key = None , custom_joints = {}) Creates a State instance for the given system with optional initial conditions. If no initial values are provided, joint positions ( q ) and velocities ( qd ) are initialized to zero, except for free and spherical joints, which have unit quaternions. Parameters: sys ( System ) \u2013 The system for which to create a state. q ( Optional[jax.Array], default=None , default: None ) \u2013 Initial joint positions. If None , defaults to zeros, with unit quaternion initialization for free and spherical joints. qd ( Optional[jax.Array], default=None , default: None ) \u2013 Initial joint velocities. If None , defaults to zeros. x ( Optional[Transform], default=None , default: None ) \u2013 Initial maximal coordinates of the system links. If None , defaults to zero transforms. key ( Optional[jax.Array], default=None , default: None ) \u2013 Random key for initializing q if no values are provided. custom_joints ( dict[str, Callable], default={} , default: {} ) \u2013 Custom joint functions for mapping coordinate vectors to minimal coordinates. Returns: State ( State ) \u2013 A new instance of the State class representing the initialized system state. Example sys = System.create(\"model.xml\") state = State.create(sys) print(state.q.shape) # Should match sys.q_size() print(state.qd.shape) # Should match sys.qd_size() step \u00a4 step ( sys , state , taus = None , n_substeps = 1 ) Advances the system dynamics by a single timestep using semi-implicit Euler integration. This function updates the system's state by integrating the equations of motion over a timestep, potentially with multiple substeps for improved numerical stability. The method ensures that the system's kinematics are updated before each integration step. Parameters: sys ( System ) \u2013 The system to simulate, containing link information, joint dynamics, and integration parameters. state ( State ) \u2013 The current state of the system, including joint positions ( q ), velocities ( qd ), and transforms ( x ). taus ( Optional [ Array ] , default: None ) \u2013 The control torques applied to the system joints. If None , zero torques are applied. Defaults to None . n_substeps ( int , default: 1 ) \u2013 The number of integration substeps per timestep to improve numerical accuracy. Defaults to 1 . Returns: State \u2013 base.State: The updated state of the system after integration. Raises: AssertionError \u2013 If the system's degrees of freedom ( q and qd ) do not match expectations. AssertionError \u2013 If an unsupported integration method is specified in sys.integration_method . Transform \u00a4 Represents a spatial transformation between two coordinate frames using Pl\u00fccker coordinates. The Transform class defines the relative position and orientation of one frame ( B ) with respect to another frame ( A ). The position ( pos ) is given in the coordinate frame of A , and the rotation ( rot ) is expressed as a unit quaternion representing the relative rotation from frame A to frame B . Attributes: pos ( Vector ) \u2013 The translation vector (position of B relative to A ) in the coordinate frame of A . Shape: (..., 3) , where ... represents optional batch dimensions. rot ( Quaternion ) \u2013 The unit quaternion representing the orientation of B relative to A . Shape: (..., 4) , where ... represents optional batch dimensions. Methods: Name Description create Optional[Vector] = None, rot: Optional[Quaternion] = None) -> Transform: Creates a Transform instance with optional position and rotation. zero Sequence[int] = ()) -> Transform: Returns a zero transform with a given batch shape. as_matrix Returns the 4x4 homogeneous transformation matrix representation of this transform. Usage pos = jnp.array([1.0, 2.0, 3.0]) rot = jnp.array([1.0, 0.0, 0.0, 0.0]) # Identity quaternion T = Transform.create(pos, rot) print(T.pos) # Output: [1. 2. 3.] print(T.rot) # Output: [1. 0. 0. 0.] print(T.as_matrix()) # 4x4 transformation matrix create classmethod \u00a4 create ( pos = None , rot = None ) Creates a Transform instance with the specified position and rotation. At least one of pos or rot must be provided. If only pos is given, the rotation defaults to the identity quaternion [1, 0, 0, 0] . If only rot is given, the position defaults to [0, 0, 0] . Parameters: pos ( Optional[Vector], default=None , default: None ) \u2013 The position of frame B relative to frame A , expressed in frame A coordinates. If None , defaults to a zero vector of shape (3,) . rot ( Optional[Quaternion], default=None , default: None ) \u2013 The unit quaternion representing the orientation of B relative to A . If None , defaults to the identity quaternion (1, 0, 0, 0) . Returns: Transform \u2013 A new Transform instance with the specified position and rotation. Example pos = jnp.array([1.0, 2.0, 3.0]) rot = jnp.array([1.0, 0.0, 0.0, 0.0]) # Identity quaternion T = Transform.create(pos, rot) print(T.pos) # Output: [1. 2. 3.] print(T.rot) # Output: [1. 0. 0. 0.] zero classmethod \u00a4 zero ( shape = ()) Returns a zero transform with a given batch shape. This creates a transform with position (0, 0, 0) and an identity quaternion (1, 0, 0, 0) , which represents no translation or rotation. Parameters: shape ( Sequence[int], default= , default: () ) \u2013 The batch shape for the transform. Defaults to a scalar transform. Returns: Transform ( Transform ) \u2013 A zero transform with the specified batch shape. Example T = Transform.zero() print(T.pos) # Output: [0. 0. 0.] print(T.rot) # Output: [1. 0. 0. 0.] as_matrix \u00a4 as_matrix () Returns the 4x4 homogeneous transformation matrix representation of this transform. The homogeneous transformation matrix is defined as: [ R t ] [ 0 1 ] where R is the 3x3 rotation matrix converted from the quaternion and t is the 3x1 position vector. Returns: Array \u2013 jax.Array: A (4, 4) homogeneous transformation matrix. Example T = Transform.create(jnp.array([1.0, 2.0, 3.0]), jnp.array([1.0, 0.0, 0.0, 0.0])) print(T.as_matrix()) # Output: 4x4 matrix","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#ring","text":"","title":"RING"},{"location":"api/#src.ring.RING","text":"RING ( lam , Ts , ** kwargs ) Creates the RING network. Parameters: lam ( list [ int ] | None ) \u2013 parent array, if None must be given via ringnet.apply(..., lam=lam) Ts \u2013 sampling interval of IMU data; time delta in seconds Returns: AbstractFilter \u2013 ring.ml.AbstractFilter: An instantiation of ring.ml.ringnet.RING with trained parameters. Examples: >>> import ring >>> import numpy as np >>> >>> T : int = 30 # sequence length [s] >>> Ts : float = 0.01 # sampling interval [s] >>> B : int = 1 # batch size >>> lam : list [ int ] = [ 0 , 1 , 2 ] # parent array >>> N : int = len ( lam ) # number of bodies >>> T_i : int = int ( T / Ts ) # number of timesteps >>> >>> X = np . zeros (( B , T_i , N , 9 )) >>> # where X is structured as follows: >>> # X[..., :3] = acc >>> # X[..., 3:6] = gyr >>> # X[..., 6:9] = jointaxis >>> >>> # let's assume we have an IMU on each outer segment of the >>> # three-segment kinematic chain >>> X [:, :, 0 , : 3 ] = acc_segment1 >>> X [:, :, 2 , : 3 ] = acc_segment3 >>> X [:, :, 0 , 3 : 6 ] = gyr_segment1 >>> X [:, :, 2 , 3 : 6 ] = gyr_segment3 >>> >>> ringnet = ring . RING ( lam , Ts ) >>> >>> yhat , _ = ringnet . apply ( X ) >>> # yhat : unit quaternions, shape = (B, T_i, N, 4) >>> # yhat[b, :, i] is the orientation from body `i` to parent body `lam[i]` >>> >>> # use `jax.jit` to compile the forward pass >>> jit_apply = jax . jit ( ringnet . apply ) >>> yhat , _ = jit_apply ( X ) >>> >>> # manually pass in and out the hidden state like so >>> initial_state = None >>> yhat , state = ringnet . apply ( X , state = initial_state ) >>> # state: final hidden state, shape = (B, N, 2*H)","title":"RING"},{"location":"api/#src.ring.ml.ringnet.RING","text":"","title":"RING"},{"location":"api/#rcmg","text":"","title":"RCMG"},{"location":"api/#src.ring.algorithms.generator.base.RCMG","text":"","title":"RCMG"},{"location":"api/#system","text":"","title":"System"},{"location":"api/#src.ring.base.System","text":"Represents a robotic system consisting of interconnected links and joints. Create it using System.create(...) The System class models the kinematic and dynamic properties of a multibody system, providing methods for state representation, transformations, joint configuration management, and rendering. It supports both minimal and maximal coordinate representations and can be parsed from or saved to XML files. Attributes: link_parents ( list [ int ] ) \u2013 A list specifying the parent index for each link. The root link has a parent index of -1 . links ( Link ) \u2013 A data structure containing information about all links in the system. link_types ( list [ str ] ) \u2013 A list specifying the joint type for each link (e.g., \"free\", \"hinge\", \"prismatic\"). link_damping ( Array ) \u2013 Joint damping coefficients for each link. link_armature ( Array ) \u2013 Armature inertia values for each joint. link_spring_stiffness ( Array ) \u2013 Stiffness values for joint springs. link_spring_zeropoint ( Array ) \u2013 Rest position of joint springs. dt ( float ) \u2013 Simulation time step size. geoms ( list [ Geometry ] ) \u2013 List of geometries associated with the system. gravity ( Array ) \u2013 Gravity vector applied to the system (default: [0, 0, -9.81] ). integration_method ( str ) \u2013 Integration method for simulation (default: \"semi_implicit_euler\"). mass_mat_iters ( int ) \u2013 Number of iterations for mass matrix calculations. link_names ( list [ str ] ) \u2013 Names of the links in the system. model_name ( Optional [ str ] ) \u2013 Name of the system model (if available). omc ( list [ MaxCoordOMC | None] ) \u2013 List of optional Maximal Coordinate representations. Methods: Name Description num_links Returns the number of links in the system. q_size Returns the total number of generalized coordinates ( q ) in the system. qd_size Returns the total number of generalized velocities ( qd ) in the system. name_to_idx str) -> int: Returns the index of a link given its name. idx_to_name int, allow_world: bool = False) -> str: Returns the name of a link given its index. If allow_world is True , returns \"world\" for index -1 . idx_map str) -> dict: Returns a dictionary mapping link names to their indices for a specified type ( \"l\" , \"q\" , or \"d\" ). parent_name str) -> str: Returns the name of the parent link for a given link. change_model_name Optional[str] = None, prefix: Optional[str] = None, suffix: Optional[str] = None) -> \"System\": Changes the name of the system model. change_link_name str, new_name: str) -> \"System\": Renames a specific link. add_prefix_suffix Optional[str] = None, suffix: Optional[str] = None) -> \"System\": Adds both a prefix and suffix to all link names. freeze str | list[str]) -> \"System\": Freezes the specified link(s), making them immovable. unfreeze str, new_joint_type: str) -> \"System\": Unfreezes a frozen link and assigns it a new joint type. change_joint_type str, new_joint_type: str, **kwargs) -> \"System\": Changes the joint type of a specified link. joint_type_simplification str) -> str: Returns a simplified representation of the given joint type. joint_type_is_free_or_cor str) -> bool: Checks if a joint type is either \"free\" or \"cor\". joint_type_is_spherical str) -> bool: Checks if a joint type is \"spherical\". joint_type_is_free_or_cor_or_spherical str) -> bool: Checks if a joint type is \"free\", \"cor\", or \"spherical\". findall_imus bool = True) -> list[str] | list[int]: Finds all IMU sensors in the system. findall_segments bool = True) -> list[str] | list[int]: Finds all non-IMU segments in the system. findall_bodies_to_world bool = False) -> list[int] | list[str]: Returns all bodies directly connected to the world. find_body_to_world bool = False) -> int | str: Returns the root body connected to the world. findall_bodies_with_jointtype str, names: bool = False) -> list[int] | list[str]: Returns all bodies with the specified joint type. children str, names: bool = False) -> list[int] | list[str]: Returns the direct children of a given body. findall_bodies_subsystem str, names: bool = False) -> list[int] | list[str]: Finds all bodies in the subsystem rooted at a given link. scan Callable, in_types: str, *args, reverse: bool = False): Iterates over system elements while applying a function. parse Parses the system, performing consistency checks and computing spatial inertia tensors. render Optional[Transform | list[Transform]] = None, **kwargs) -> list[np.ndarray]: Renders frames of the system using maximal coordinates. render_prediction Transform | list[Transform], yhat: dict | jax.Array | np.ndarray, **kwargs): Renders a predicted state transformation. delete_system str | list[str], strict: bool = True): Removes a subsystem from the system. make_sys_noimu Optional[list[str]] = None): Returns a version of the system without IMU sensors. inject_system \"System\", at_body: Optional[str] = None): Merges another system into this one. morph_system Optional[list[int | str]] = None, new_anchor: Optional[int | str] = None): Reorders the system\u2019s link hierarchy. from_xml str, seed: int = 1) -> \"System\": Loads a system from an XML file. from_str str, seed: int = 1) -> \"System\": Loads a system from an XML string. to_str bool = True) -> str: Serializes the system to an XML string. to_xml str) -> None: Saves the system as an XML file. create str, seed: int = 1) -> \"System\": Creates a System instance from an XML file or string. coordinate_vector_to_q jax.Array, custom_joints: dict[str, Callable] = {}) -> jax.Array: Converts a coordinate vector to minimal coordinates ( q ), applying constraints such as quaternion normalization. Raises: AssertionError \u2013 If the system structure is invalid (e.g., duplicate link names, incorrect parent-child relationships). InvalidSystemError \u2013 If an operation results in an inconsistent system state. Notes The system must be parsed before use to ensure consistency. The system supports batch operations using JAX for efficient computations. Joint types include revolute (\"rx\", \"ry\", \"rz\"), prismatic (\"px\", \"py\", \"pz\"), spherical, free, and more. Inertial properties of links are computed automatically from associated geometries.","title":"System"},{"location":"api/#motionconfig","text":"","title":"MotionConfig"},{"location":"api/#src.ring.algorithms.jcalc.MotionConfig","text":"Configuration for joint motion generation in kinematic and dynamic simulations. This class defines the constraints and parameters for generating random joint motions, including angular and positional velocity limits, interpolation methods, and range restrictions for various joint types. Attributes: T ( float ) \u2013 Total duration of the motion sequence (in seconds). t_min ( float ) \u2013 Minimum time interval between two generated joint states. t_max ( float | TimeDependentFloat ) \u2013 Maximum time interval between two generated joint states. dang_min ( float | TimeDependentFloat ) \u2013 Minimum angular velocity (rad/s). dang_max ( float | TimeDependentFloat ) \u2013 Maximum angular velocity (rad/s). dang_min_free_spherical ( float | TimeDependentFloat ) \u2013 Minimum angular velocity for free and spherical joints. dang_max_free_spherical ( float | TimeDependentFloat ) \u2013 Maximum angular velocity for free and spherical joints. delta_ang_min ( float | TimeDependentFloat ) \u2013 Minimum allowed change in joint angle (radians). delta_ang_max ( float | TimeDependentFloat ) \u2013 Maximum allowed change in joint angle (radians). delta_ang_min_free_spherical ( float | TimeDependentFloat ) \u2013 Minimum allowed change in angle for free/spherical joints. delta_ang_max_free_spherical ( float | TimeDependentFloat ) \u2013 Maximum allowed change in angle for free/spherical joints. dpos_min ( float | TimeDependentFloat ) \u2013 Minimum translational velocity. dpos_max ( float | TimeDependentFloat ) \u2013 Maximum translational velocity. pos_min ( float | TimeDependentFloat ) \u2013 Minimum position constraint. pos_max ( float | TimeDependentFloat ) \u2013 Maximum position constraint. pos_min_p3d_x ( float | TimeDependentFloat ) \u2013 Minimum position in x-direction for P3D joints. pos_max_p3d_x ( float | TimeDependentFloat ) \u2013 Maximum position in x-direction for P3D joints. pos_min_p3d_y ( float | TimeDependentFloat ) \u2013 Minimum position in y-direction for P3D joints. pos_max_p3d_y ( float | TimeDependentFloat ) \u2013 Maximum position in y-direction for P3D joints. pos_min_p3d_z ( float | TimeDependentFloat ) \u2013 Minimum position in z-direction for P3D joints. pos_max_p3d_z ( float | TimeDependentFloat ) \u2013 Maximum position in z-direction for P3D joints. cdf_bins_min ( int ) \u2013 Minimum number of bins for cumulative distribution function (CDF)-based random sampling. cdf_bins_max ( Optional [ int ] ) \u2013 Maximum number of bins for CDF-based sampling. randomized_interpolation_angle ( bool ) \u2013 Whether to use randomized interpolation for angular motion. randomized_interpolation_position ( bool ) \u2013 Whether to use randomized interpolation for positional motion. interpolation_method ( str ) \u2013 Interpolation method to be used (default: \"cosine\"). range_of_motion_hinge ( bool ) \u2013 Whether to enforce range-of-motion constraints on hinge joints. range_of_motion_hinge_method ( str ) \u2013 Method used for range-of-motion enforcement (e.g., \"uniform\", \"sigmoid\"). rom_halfsize ( float | TimeDependentFloat ) \u2013 Half-size of the range of motion restriction. ang0_min ( float ) \u2013 Minimum initial joint angle. ang0_max ( float ) \u2013 Maximum initial joint angle. pos0_min ( float ) \u2013 Minimum initial joint position. pos0_max ( float ) \u2013 Maximum initial joint position. cor_t_min ( float ) \u2013 Minimum time step for center-of-rotation (COR) joints. cor_t_max ( float | TimeDependentFloat ) \u2013 Maximum time step for COR joints. cor_dpos_min ( float | TimeDependentFloat ) \u2013 Minimum velocity for COR translation. cor_dpos_max ( float | TimeDependentFloat ) \u2013 Maximum velocity for COR translation. cor_pos_min ( float | TimeDependentFloat ) \u2013 Minimum position for COR translation. cor_pos_max ( float | TimeDependentFloat ) \u2013 Maximum position for COR translation. cor_pos0_min ( float ) \u2013 Initial minimum position for COR translation. cor_pos0_max ( float ) \u2013 Initial maximum position for COR translation. joint_type_specific_overwrites ( dict [ str , dict [ str , Any ]] ) \u2013 A dictionary mapping joint types to specific motion configuration overrides. Methods: Name Description is_feasible Checks if the motion configuration satisfies all constraints. to_nomotion_config Returns a new MotionConfig where all velocities and angle changes are set to zero. overwrite_for_joint_type Applies specific configuration changes for a given joint type. Note: These changes affect all instances of MotionConfig for this joint type. overwrite_for_subsystem Modifies the motion configuration for all joints in a subsystem rooted at link_name . from_register Retrieves a predefined MotionConfig from the global registry.","title":"MotionConfig"},{"location":"api/#src.ring.algorithms.jcalc.join_motionconfigs","text":"join_motionconfigs ( configs , boundaries ) Joins multiple MotionConfig objects in time, transitioning between them at specified boundaries. This function takes a list of MotionConfig instances and a corresponding list of boundary times, and constructs a new MotionConfig that varies in time according to the provided segments. Parameters: configs ( list [ MotionConfig ] ) \u2013 A list of MotionConfig objects to be joined. boundaries ( list [ float ] ) \u2013 A list of time values where transitions between configs occur. Must have one element less than configs , as each boundary defines the transition point between two consecutive configurations. Returns: MotionConfig ( MotionConfig ) \u2013 A new MotionConfig object where time-dependent fields transition based on the MotionConfig \u2013 specified boundaries. Raises: AssertionError \u2013 If the number of boundaries does not match len(configs) - 1 . AssertionError \u2013 If time-independent fields have differing values across configs . Notes Only fields that are time-dependent ( float | TimeDependentFloat ) will change over time. Time-independent fields must be the same in all configs , or an error is raised.","title":"join_motionconfigs"},{"location":"api/#extending-the-rcmg","text":"","title":"Extending the RCMG"},{"location":"api/#src.ring.algorithms.jcalc.JointModel","text":"Represents the kinematic and dynamic properties of a joint type. A JointModel defines the mathematical functions required to compute joint transformations, motion, control terms, and inverse kinematics. It is used to describe the behavior of various joint types, including revolute, prismatic, spherical, and free joints. Attributes: transform ( Callable [[ Array , Array ], Transform ] ) \u2013 Computes the transformation (position and orientation) of the joint given the joint state q and joint parameters. motion ( list [ Motion | Callable [[ Array ], Motion ]] ) \u2013 Defines the joint motion model. It can be a list of Motion objects or callables that return Motion based on joint parameters. rcmg_draw_fn ( Optional [ DRAW_FN ] ) \u2013 Function used to generate a reference motion trajectory for the joint using Randomized Control Motion Generation (RCMG). p_control_term ( Optional [ P_CONTROL_TERM ] ) \u2013 Function that computes the proportional control term for the joint. qd_from_q ( Optional [ QD_FROM_Q ] ) \u2013 Function to compute joint velocity ( qd ) from joint positions ( q ). coordinate_vector_to_q ( Optional [ COORDINATE_VECTOR_TO_Q ] ) \u2013 Function that maps a coordinate vector to a valid joint state q , ensuring constraints (e.g., wrapping angles or normalizing quaternions). inv_kin ( Optional [ INV_KIN ] ) \u2013 Function that computes the inverse kinematics for the joint, mapping a desired transform to joint coordinates q . init_joint_params ( Optional [ INIT_JOINT_PARAMS ] ) \u2013 Function that initializes joint-specific parameters. utilities ( Optional [ dict [ str , Any ]] ) \u2013 Additional utility functions or metadata related to the joint model. Notes The transform function is essential for computing the joint's spatial transformation based on its generalized coordinates. The motion attribute describes how forces and torques affect the joint. The rcmg_draw_fn is used for RCMG motion generation. The coordinate_vector_to_q is critical for maintaining valid joint states.","title":"JointModel"},{"location":"api/#src.ring.algorithms.jcalc.register_new_joint_type","text":"register_new_joint_type ( joint_type , joint_model , q_width , qd_width = None , overwrite = False ) Registers a new joint type with its corresponding JointModel and kinematic properties. This function allows the addition of custom joint types to the system by associating them with a JointModel , specifying their state and velocity dimensions, and optionally overwriting existing joint definitions. Parameters: joint_type ( str ) \u2013 Name of the new joint type to register. joint_model ( JointModel ) \u2013 The JointModel instance defining the kinematic and dynamic properties of the joint. q_width ( int ) \u2013 Number of generalized coordinates (degrees of freedom) required to represent the joint. qd_width ( Optional[int], default=None , default: None ) \u2013 Number of velocity coordinates associated with the joint. Defaults to q_width . overwrite ( bool, default=False , default: False ) \u2013 If True , allows overwriting an existing joint type. Otherwise, raises an error if the joint type already exists. Raises: AssertionError \u2013 If joint_type is \"default\" (reserved name). If joint_type already exists and overwrite=False . If qd_width is not provided and does not default to q_width . If joint_model.motion length does not match qd_width . Notes The function updates global dictionaries that store joint properties, including: _joint_types : Maps joint type names to JointModel instances. base.Q_WIDTHS : Stores the number of state coordinates for each joint type. base.QD_WIDTHS : Stores the number of velocity coordinates for each joint type. If overwrite=True , existing entries are removed before adding the new joint type. Ensures consistency between motion definitions and velocity coordinate dimensions. Example new_joint = JointModel ( transform = my_transform_fn , motion = [ base . Motion . create ( ang = jnp . array ([ 1 , 0 , 0 ]))], ) register_new_joint_type ( \"custom_hinge\" , new_joint , q_width = 1 )","title":"register_new_joint_type"},{"location":"api/#simulation","text":"","title":"Simulation"},{"location":"api/#src.ring.base.State","text":"Represents the state of a dynamic system in minimal and maximal coordinates. The State class encapsulates both the configuration ( q ) and velocity ( qd ) of the system in minimal coordinates, as well as the corresponding transforms ( x ) in maximal coordinates. Attributes: q ( Array ) \u2013 The joint positions (generalized coordinates) of the system. The size of q matches sys.q_size() . qd ( Array ) \u2013 The joint velocities (generalized velocities) of the system. The size of qd matches sys.qd_size() . x ( Transform ) \u2013 The maximal coordinate representation of all system links, expressed as a Transform object. Methods: Name Description create System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None, x: Optional[Transform] = None, key: Optional[jax.Array] = None, custom_joints: dict[str, Callable] = {}) -> State: Creates a State instance for a given system with optional initial conditions. Usage sys = System.create(\"model.xml\") state = State.create(sys) print(state.q.shape) # Should match sys.q_size() print(state.qd.shape) # Should match sys.qd_size()","title":"State"},{"location":"api/#src.ring.algorithms.dynamics.step","text":"step ( sys , state , taus = None , n_substeps = 1 ) Advances the system dynamics by a single timestep using semi-implicit Euler integration. This function updates the system's state by integrating the equations of motion over a timestep, potentially with multiple substeps for improved numerical stability. The method ensures that the system's kinematics are updated before each integration step. Parameters: sys ( System ) \u2013 The system to simulate, containing link information, joint dynamics, and integration parameters. state ( State ) \u2013 The current state of the system, including joint positions ( q ), velocities ( qd ), and transforms ( x ). taus ( Optional [ Array ] , default: None ) \u2013 The control torques applied to the system joints. If None , zero torques are applied. Defaults to None . n_substeps ( int , default: 1 ) \u2013 The number of integration substeps per timestep to improve numerical accuracy. Defaults to 1 . Returns: State \u2013 base.State: The updated state of the system after integration. Raises: AssertionError \u2013 If the system's degrees of freedom ( q and qd ) do not match expectations. AssertionError \u2013 If an unsupported integration method is specified in sys.integration_method .","title":"step"},{"location":"api/#src.ring.base.Transform","text":"Represents a spatial transformation between two coordinate frames using Pl\u00fccker coordinates. The Transform class defines the relative position and orientation of one frame ( B ) with respect to another frame ( A ). The position ( pos ) is given in the coordinate frame of A , and the rotation ( rot ) is expressed as a unit quaternion representing the relative rotation from frame A to frame B . Attributes: pos ( Vector ) \u2013 The translation vector (position of B relative to A ) in the coordinate frame of A . Shape: (..., 3) , where ... represents optional batch dimensions. rot ( Quaternion ) \u2013 The unit quaternion representing the orientation of B relative to A . Shape: (..., 4) , where ... represents optional batch dimensions. Methods: Name Description create Optional[Vector] = None, rot: Optional[Quaternion] = None) -> Transform: Creates a Transform instance with optional position and rotation. zero Sequence[int] = ()) -> Transform: Returns a zero transform with a given batch shape. as_matrix Returns the 4x4 homogeneous transformation matrix representation of this transform. Usage pos = jnp.array([1.0, 2.0, 3.0]) rot = jnp.array([1.0, 0.0, 0.0, 0.0]) # Identity quaternion T = Transform.create(pos, rot) print(T.pos) # Output: [1. 2. 3.] print(T.rot) # Output: [1. 0. 0. 0.] print(T.as_matrix()) # 4x4 transformation matrix","title":"Transform"},{"location":"xml_syntax/","text":"XML Syntax Documentation \u00a4 Overview \u00a4 This document describes the XML syntax used to define a physical system. The structure includes elements for defining bodies, joints, geometries, simulation parameters, and rendering properties. Root Element \u00a4 <x_xy name= \"example_model\" > ... </x_xy> name (string, required): The name of the model. Simulation Parameters \u00a4 <options gravity= \"0 0 -9.81\" dt= \"0.01\" /> gravity (x y z, optional): Global gravity vector. dt (float, optional): Simulation time step. Default Parameters for geom and body \u00a4 Changes the default values. For example: <defaults> <geom mass= \"1.0\" /> </defaults> mass (float, optional): Default mass of geometries. World Definition \u00a4 <worldbody> <body name= \"base\" joint= \"free\" pos= \"0 0 0\" > ... </body> </worldbody> <worldbody> : The root container for all bodies. <body> : Defines a physical body. name (string, required): Unique identifier for the body. joint (string, required): Type of joint connecting to worldbody. pos (x y z, optional): Position in world coordinates. for more see section Bodies below Geometry Definition and Rendering Properties \u00a4 <geom type= \"box\" mass= \"1\" size= \"0.5 0.5 0.5\" color= \"0.8 0.2 0.2\" /> mass (float, required): Mass of geometry. type (string, required): Shape type ( box , sphere , cylinder , xyz , capsule ). dim (Vector of floats, required): Dimensions of the geometry. Its dimensionality depends on the type of the geometry. box : length_x, length_y, length_z sphere : radius cylinder : radius, height xyz : unit_vector_length capsule : radius, length color (rgb or string, optional): RGB color (normalised from 0 to 1) of the object or string identifier of a color such as green, blue, red, orange, ... pos (x y z, optional): Position of geometry in coordinate system of surrouning body. Points to the center of mass of the geometry. Defaults to zeros. euler (x y z, optional): Euler angles in degree. Orientation of geometry in coordinate system of surrouning body. Mutually exclusive with field quat . Defaults to zeros. quat (u x y z, optional): Orientation of geometry in coordinate system of surrouning body. Mutually exclusive with field euler . Defaults to 1 0 0 0. Bodies \u00a4 <body name= \"hinge\" joint= \"rx\" pos= \"0 0 1\" euler= \"90 0 0\" /> name (string, required): Identifier for the body. joint (string, required): Type of joint. Possible values: free : 6D free joint cor : 9D free joint, center of rotation also moves free_2d : 3D free joint (1D rotation + 2D translations) frozen : 0D joint spherical : 3D rotational joint px , py , pz (prismatic joints): 1D translational joints around x/y/z rx , ry , rz (revolute joints): 1D rotational joints around x/y/z saddle : 2D rotational joint p3d : 3D translational joint rr (custom joint): 1D rotational joint with randomised joint axis direction rr_imp (custom joint): 1D rotational joint with randomised joint axis direction that is not a perfect 1D joint; there is a small secondary rotation possible rsaddle (custom joint): 2D rotational joint with randomised joint axes directions pos (x y z, optional): Position relative to parent body. Defaults to zeros. euler (x y z, optional): Euler angles in degree. Orientation relative to parent body. Mutually exclusive with field quat . Defaults to zeros. quat (u x y z, optional): Orientation relative to parent body. Mutually exclusive with field euler . Defaults to 1 0 0 0. pos_min (x y z, optional): Lower bound for randomization of the pos value. Defaults to zeros. pos_max (x y z, optional): Upper bound for randomization of the pos value. Defaults to zeros. damping (Vector of floats, optional): Damping of the joint. It's dimensionality depends on the qd size of the joint type. So for a 1D joint, this is a single float, for a 3D joint it is three floats. Defaults to zeros. armature (Vector of floats, optional): Armature of the joint. It's dimensionality depends on the qd size of the joint type. So for a 1D joint, this is a single float, for a 3D joint it is three floats. Defaults to zeros. spring_stiff (Vector of floats, optional): Spring stiffness of the joint. It's dimensionality depends on the qd size. Defaults to zeros. spring_zero (Vector of floats, optional): Zero point for the spring force of the joint. It's dimensionality depends on the q size of the joint type. Defaults to 1 0 0 0 for spherical , cor , and free , and to zeros else. Example Model \u00a4 <x_xy model= \"inv_pendulum\" > <options gravity= \"0 0 9.81\" dt= \"0.01\" /> <defaults> <geom color= \"white\" /> </defaults> <worldbody> <body name= \"cart\" joint= \"px\" damping= \"0.01\" > <geom type= \"box\" mass= \"1\" dim= \"0.4 0.1 0.1\" /> <body name= \"pendulum\" joint= \"ry\" euler= \"0 -90 0\" damping= \"0.01\" > <geom type= \"box\" mass= \"0.5\" pos= \"0.5 0 0\" dim= \"1 0.1 0.1\" /> </body> </body> </worldbody> </x_xy>","title":"XML Syntax Documentation"},{"location":"xml_syntax/#xml-syntax-documentation","text":"","title":"XML Syntax Documentation"},{"location":"xml_syntax/#overview","text":"This document describes the XML syntax used to define a physical system. The structure includes elements for defining bodies, joints, geometries, simulation parameters, and rendering properties.","title":"Overview"},{"location":"xml_syntax/#root-element","text":"<x_xy name= \"example_model\" > ... </x_xy> name (string, required): The name of the model.","title":"Root Element"},{"location":"xml_syntax/#simulation-parameters","text":"<options gravity= \"0 0 -9.81\" dt= \"0.01\" /> gravity (x y z, optional): Global gravity vector. dt (float, optional): Simulation time step.","title":"Simulation Parameters"},{"location":"xml_syntax/#default-parameters-for-geom-and-body","text":"Changes the default values. For example: <defaults> <geom mass= \"1.0\" /> </defaults> mass (float, optional): Default mass of geometries.","title":"Default Parameters for geom and body"},{"location":"xml_syntax/#world-definition","text":"<worldbody> <body name= \"base\" joint= \"free\" pos= \"0 0 0\" > ... </body> </worldbody> <worldbody> : The root container for all bodies. <body> : Defines a physical body. name (string, required): Unique identifier for the body. joint (string, required): Type of joint connecting to worldbody. pos (x y z, optional): Position in world coordinates. for more see section Bodies below","title":"World Definition"},{"location":"xml_syntax/#geometry-definition-and-rendering-properties","text":"<geom type= \"box\" mass= \"1\" size= \"0.5 0.5 0.5\" color= \"0.8 0.2 0.2\" /> mass (float, required): Mass of geometry. type (string, required): Shape type ( box , sphere , cylinder , xyz , capsule ). dim (Vector of floats, required): Dimensions of the geometry. Its dimensionality depends on the type of the geometry. box : length_x, length_y, length_z sphere : radius cylinder : radius, height xyz : unit_vector_length capsule : radius, length color (rgb or string, optional): RGB color (normalised from 0 to 1) of the object or string identifier of a color such as green, blue, red, orange, ... pos (x y z, optional): Position of geometry in coordinate system of surrouning body. Points to the center of mass of the geometry. Defaults to zeros. euler (x y z, optional): Euler angles in degree. Orientation of geometry in coordinate system of surrouning body. Mutually exclusive with field quat . Defaults to zeros. quat (u x y z, optional): Orientation of geometry in coordinate system of surrouning body. Mutually exclusive with field euler . Defaults to 1 0 0 0.","title":"Geometry Definition and Rendering Properties"},{"location":"xml_syntax/#bodies","text":"<body name= \"hinge\" joint= \"rx\" pos= \"0 0 1\" euler= \"90 0 0\" /> name (string, required): Identifier for the body. joint (string, required): Type of joint. Possible values: free : 6D free joint cor : 9D free joint, center of rotation also moves free_2d : 3D free joint (1D rotation + 2D translations) frozen : 0D joint spherical : 3D rotational joint px , py , pz (prismatic joints): 1D translational joints around x/y/z rx , ry , rz (revolute joints): 1D rotational joints around x/y/z saddle : 2D rotational joint p3d : 3D translational joint rr (custom joint): 1D rotational joint with randomised joint axis direction rr_imp (custom joint): 1D rotational joint with randomised joint axis direction that is not a perfect 1D joint; there is a small secondary rotation possible rsaddle (custom joint): 2D rotational joint with randomised joint axes directions pos (x y z, optional): Position relative to parent body. Defaults to zeros. euler (x y z, optional): Euler angles in degree. Orientation relative to parent body. Mutually exclusive with field quat . Defaults to zeros. quat (u x y z, optional): Orientation relative to parent body. Mutually exclusive with field euler . Defaults to 1 0 0 0. pos_min (x y z, optional): Lower bound for randomization of the pos value. Defaults to zeros. pos_max (x y z, optional): Upper bound for randomization of the pos value. Defaults to zeros. damping (Vector of floats, optional): Damping of the joint. It's dimensionality depends on the qd size of the joint type. So for a 1D joint, this is a single float, for a 3D joint it is three floats. Defaults to zeros. armature (Vector of floats, optional): Armature of the joint. It's dimensionality depends on the qd size of the joint type. So for a 1D joint, this is a single float, for a 3D joint it is three floats. Defaults to zeros. spring_stiff (Vector of floats, optional): Spring stiffness of the joint. It's dimensionality depends on the qd size. Defaults to zeros. spring_zero (Vector of floats, optional): Zero point for the spring force of the joint. It's dimensionality depends on the q size of the joint type. Defaults to 1 0 0 0 for spherical , cor , and free , and to zeros else.","title":"Bodies"},{"location":"xml_syntax/#example-model","text":"<x_xy model= \"inv_pendulum\" > <options gravity= \"0 0 9.81\" dt= \"0.01\" /> <defaults> <geom color= \"white\" /> </defaults> <worldbody> <body name= \"cart\" joint= \"px\" damping= \"0.01\" > <geom type= \"box\" mass= \"1\" dim= \"0.4 0.1 0.1\" /> <body name= \"pendulum\" joint= \"ry\" euler= \"0 -90 0\" damping= \"0.01\" > <geom type= \"box\" mass= \"0.5\" pos= \"0.5 0 0\" dim= \"1 0.1 0.1\" /> </body> </body> </worldbody> </x_xy>","title":"Example Model"},{"location":"notebooks/batched_simulation/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . Batched Dynamical Simulation \u00a4 System object is a registered Jax-PyTree. This means it's a nested array. This enables us to stack multiple systems (or states) to enable vectorized operations. Batched System \u00a4 I.e. simulating two different system with the same initial state. import ring import jax import jax.numpy as jnp xml_str = \"\"\" <x_xy model=\"double_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"2\" euler=\"0 90 0\" joint=\"ry\" name=\"upper\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body damping=\"2\" joint=\"ry\" name=\"lower\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) state = ring . State . create ( sys ) # second system with gravity disabled sys_nograv = sys . replace ( gravity = sys . gravity * 0.0 ) sys_batched = sys . batch ( sys_nograv ) next_state_batched = jax . vmap ( ring . step , in_axes = ( 0 , None ))( sys_batched , state ) # note how the state of the system without gravity has not changed at all next_state_batched . q Array([[0., 0.], [0., 0.]], dtype=float32) Batched State \u00a4 second_state = ring . State . create ( sys , qd = jnp . ones (( 2 ,))) state_batched = state . batch ( second_state ) next_state_batched = jax . vmap ( ring . step , in_axes = ( None , 0 ))( sys , state_batched ) next_state_batched . q Array([[0. , 0. ], [0.01004834, 0.00982152]], dtype=float32) Batched Kinematic Simulation \u00a4 Batched kinematic simulation is done by providing the sizes argument to build_generator batchsize = 8 seed = 1 gen = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), keep_output_extras = True ) . to_lazy_gen ( batchsize ) ( X , y ), ( _ , q , x , _ ) = gen ( jax . random . PRNGKey ( seed )) q . shape (8, 1000, 2)","title":"Batched simulation"},{"location":"notebooks/batched_simulation/#batched-dynamical-simulation","text":"System object is a registered Jax-PyTree. This means it's a nested array. This enables us to stack multiple systems (or states) to enable vectorized operations.","title":"Batched Dynamical Simulation"},{"location":"notebooks/batched_simulation/#batched-system","text":"I.e. simulating two different system with the same initial state. import ring import jax import jax.numpy as jnp xml_str = \"\"\" <x_xy model=\"double_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"2\" euler=\"0 90 0\" joint=\"ry\" name=\"upper\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body damping=\"2\" joint=\"ry\" name=\"lower\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) state = ring . State . create ( sys ) # second system with gravity disabled sys_nograv = sys . replace ( gravity = sys . gravity * 0.0 ) sys_batched = sys . batch ( sys_nograv ) next_state_batched = jax . vmap ( ring . step , in_axes = ( 0 , None ))( sys_batched , state ) # note how the state of the system without gravity has not changed at all next_state_batched . q Array([[0., 0.], [0., 0.]], dtype=float32)","title":"Batched System"},{"location":"notebooks/batched_simulation/#batched-state","text":"second_state = ring . State . create ( sys , qd = jnp . ones (( 2 ,))) state_batched = state . batch ( second_state ) next_state_batched = jax . vmap ( ring . step , in_axes = ( None , 0 ))( sys , state_batched ) next_state_batched . q Array([[0. , 0. ], [0.01004834, 0.00982152]], dtype=float32)","title":"Batched State"},{"location":"notebooks/batched_simulation/#batched-kinematic-simulation","text":"Batched kinematic simulation is done by providing the sizes argument to build_generator batchsize = 8 seed = 1 gen = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), keep_output_extras = True ) . to_lazy_gen ( batchsize ) ( X , y ), ( _ , q , x , _ ) = gen ( jax . random . PRNGKey ( seed )) q . shape (8, 1000, 2)","title":"Batched Kinematic Simulation"},{"location":"notebooks/control/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . Balance an inverted Pendulum on a cart \u00a4 import ring from ring.algorithms.generator.pd_control import _pd_control import jax import jax.numpy as jnp import numpy as np import mediapy as media The step function also takes generalized forces tau applied to the degrees of freedom its third input step(sys, state, taus) . Let's consider an inverted pendulum on a cart, and apply a left-right force onto the cart such that the pole stays in the upright position. xml_str = \"\"\" <x_xy model=\"inv_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"white\" edge_color=\"black\"></geom> </defaults> <worldbody> <body damping=\"0.01\" joint=\"px\" name=\"cart\"> <geom dim=\"0.4 0.1 0.1\" mass=\"1\" type=\"box\"></geom> <body damping=\"0.01\" euler=\"0 -90 0\" joint=\"ry\" name=\"pendulum\"> <geom dim=\"1 0.1 0.1\" mass=\"0.5\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) state = ring . State . create ( sys , q = jnp . array ([ 0.0 , 0.2 ])) xs = [] T = 10.0 for t in range ( int ( T / sys . dt )): measurement_noise = np . random . normal () * 5 phi = jnp . rad2deg ( state . q [ 1 ]) + measurement_noise cart_motor_input = 0.1 * phi * abs ( phi ) taus = jnp . clip ( jnp . array ([ cart_motor_input , 0.0 ]), - 10 , 10 ) state = jax . jit ( ring . step )( sys , state , taus ) xs . append ( state . x ) def show_video ( sys , xs : list [ ring . Transform ]): assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = sys . render ( xs , render_every_nth = 4 , camera = \"c\" , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\"0 -2 2\" target=\"0\"></camera>' }) media . show_video ( frames , fps = 25 ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:02<00:00, 102.28it/s] This browser does not support the video tag. PD Control \u00a4 xml_str = \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"0.01\" euler=\"0 90 0\" joint=\"ry\" name=\"pendulum\" pos=\"0 0 1\"> <geom dim=\"1 0.1 0.1\" mass=\"0.5\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) P , D = jnp . array ([ 10.0 ]), jnp . array ([ 1.0 ]) def simulate_pd_control ( sys , P , D ): controller = _pd_control ( P , D ) # reference signal q_ref = jnp . ones (( 1000 , 1 )) * jnp . pi / 2 controller_state = controller . init ( sys , q_ref ) state = ring . State . create ( sys ) xs = [] T = 5.0 for t in range ( int ( T / sys . dt )): controller_state , taus = jax . jit ( controller . apply )( controller_state , sys , state ) state = jax . jit ( ring . step )( sys , state , taus ) xs . append ( state . x ) return xs xs = simulate_pd_control ( sys , P , D ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:01<00:00, 108.19it/s] This browser does not support the video tag. Note the steady state error. This is because we have gravity and no Integral part (so no PID control). If we remove gravity the steady state error also vanishes (as is expected.) sys_nograv = sys . replace ( gravity = sys . gravity * 0.0 ) xs = simulate_pd_control ( sys_nograv , P , D ) show_video ( sys_nograv , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00<00:00, 166.82it/s] This browser does not support the video tag.","title":"Control"},{"location":"notebooks/control/#balance-an-inverted-pendulum-on-a-cart","text":"import ring from ring.algorithms.generator.pd_control import _pd_control import jax import jax.numpy as jnp import numpy as np import mediapy as media The step function also takes generalized forces tau applied to the degrees of freedom its third input step(sys, state, taus) . Let's consider an inverted pendulum on a cart, and apply a left-right force onto the cart such that the pole stays in the upright position. xml_str = \"\"\" <x_xy model=\"inv_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"white\" edge_color=\"black\"></geom> </defaults> <worldbody> <body damping=\"0.01\" joint=\"px\" name=\"cart\"> <geom dim=\"0.4 0.1 0.1\" mass=\"1\" type=\"box\"></geom> <body damping=\"0.01\" euler=\"0 -90 0\" joint=\"ry\" name=\"pendulum\"> <geom dim=\"1 0.1 0.1\" mass=\"0.5\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) state = ring . State . create ( sys , q = jnp . array ([ 0.0 , 0.2 ])) xs = [] T = 10.0 for t in range ( int ( T / sys . dt )): measurement_noise = np . random . normal () * 5 phi = jnp . rad2deg ( state . q [ 1 ]) + measurement_noise cart_motor_input = 0.1 * phi * abs ( phi ) taus = jnp . clip ( jnp . array ([ cart_motor_input , 0.0 ]), - 10 , 10 ) state = jax . jit ( ring . step )( sys , state , taus ) xs . append ( state . x ) def show_video ( sys , xs : list [ ring . Transform ]): assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = sys . render ( xs , render_every_nth = 4 , camera = \"c\" , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\"0 -2 2\" target=\"0\"></camera>' }) media . show_video ( frames , fps = 25 ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:02<00:00, 102.28it/s] This browser does not support the video tag.","title":"Balance an inverted Pendulum on a cart"},{"location":"notebooks/control/#pd-control","text":"xml_str = \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"0.01\" euler=\"0 90 0\" joint=\"ry\" name=\"pendulum\" pos=\"0 0 1\"> <geom dim=\"1 0.1 0.1\" mass=\"0.5\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) P , D = jnp . array ([ 10.0 ]), jnp . array ([ 1.0 ]) def simulate_pd_control ( sys , P , D ): controller = _pd_control ( P , D ) # reference signal q_ref = jnp . ones (( 1000 , 1 )) * jnp . pi / 2 controller_state = controller . init ( sys , q_ref ) state = ring . State . create ( sys ) xs = [] T = 5.0 for t in range ( int ( T / sys . dt )): controller_state , taus = jax . jit ( controller . apply )( controller_state , sys , state ) state = jax . jit ( ring . step )( sys , state , taus ) xs . append ( state . x ) return xs xs = simulate_pd_control ( sys , P , D ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:01<00:00, 108.19it/s] This browser does not support the video tag. Note the steady state error. This is because we have gravity and no Integral part (so no PID control). If we remove gravity the steady state error also vanishes (as is expected.) sys_nograv = sys . replace ( gravity = sys . gravity * 0.0 ) xs = simulate_pd_control ( sys_nograv , P , D ) show_video ( sys_nograv , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00<00:00, 166.82it/s] This browser does not support the video tag.","title":"PD Control"},{"location":"notebooks/custom_joint_type/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . Defining a custom Joint Type that supports dynamical simulation \u00a4 In this notebook we will define a new joint type that is a hinge joint with a random joint axes direction. It will also support dynamical simulation . import ring from ring import maths , base import jax import jax.numpy as jnp import mediapy as media from ring.algorithms.jcalc import _draw_rxyz We will give this new joint type the identifier rr (random revolute). Although it actually already exists in the library, but we can overwrite it. # we use such a `params` input to specify the joint-axes, if we later then randomize the attribute of the system object # we will have the effect of a hinge joint with a randomized joint axes direction # here we tell the library how it should initialize this `params` PyTree def _draw_random_joint_axis ( key ): return maths . rotate ( jnp . array ([ 1.0 , 0 , 0 ]), maths . quat_random ( key )) def _rr_init_joint_params ( key ): return dict ( joint_axes = _draw_random_joint_axis ( key )) # next, we tell the library how it can randomly draw a trajectory for its generalized coordinate; the hinge joint angle def _rr_transform ( q , params ): # here we use this `params` object axis = params [ \"joint_axes\" ] q = jnp . squeeze ( q ) rot = maths . quat_rot_axis ( axis , q ) return ring . Transform . create ( rot = rot ) # this tells the library how to dynamically simulate the type of joint def _motion_fn ( params ): return base . Motion . create ( ang = params [ \"joint_axes\" ]) # now, we can put it all together into a new `x_xy.JointModel` rr_joint = ring . JointModel ( _rr_transform , motion = [ _motion_fn ], rcmg_draw_fn = _draw_rxyz , init_joint_params = _rr_init_joint_params ) # and then we register the joint; Note that `overwrite`=True, because it already exists; that way you can e.g. overwrite the # default joint types such as the free joint ring . register_new_joint_type ( \"rr\" , rr_joint , q_width = 1 , qd_width = 1 , overwrite = True ) xml_str = \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <geom dim=\"0.1\" type=\"xyz\"></geom> <body damping=\".01\" joint=\"rr\" name=\"pendulum\" pos=\"0 0 0.5\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.5 0.1 0.1\" mass=\"0.5\" pos=\"0.25 0 0\" type=\"box\"></geom> </body> </worldbody> </x_xy> \"\"\" # this seed determines (among other things) the randomness of the joint-axes direction # via the above specified `_rr_init_joint_params` seed : int = 2 sys = ring . System . create ( xml_str , seed = seed ) state = ring . State . create ( sys ) xs = [] for t in range ( 500 ): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) sys . links . joint_params {'rr': {'joint_axes': Array([[ 0.41278404, -0.6329913 , 0.65492845]], dtype=float32)}, 'default': Array([], shape=(1, 0), dtype=float32)} def show_video ( sys , xs : list [ ring . Transform ]): frames = sys . render ( xs , render_every_nth = 4 ) media . show_video ( frames , fps = 25 ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:01<00:00, 94.24it/s] This browser does not support the video tag. the class x_xy.RCMG already has the built-in flag randomize_joint_params which can be toggled in order to use the user-provided logic _rr_init_joint_params for randomizing the joint parameters ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , randomize_joint_params = True , keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:02<00:00, 2.70s/it] show_video ( sys , x ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1500/1500 [00:14<00:00, 103.09it/s] This browser does not support the video tag. but for dynamic_simulation flag to work we additional need to specify the function ring.JointModel.p_control_term print ( rr_joint . p_control_term ) None try : ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , randomize_joint_params = True , keep_output_extras = True , dynamic_simulation = True ) . to_list ()[ 0 ] except NotImplementedError : print ( \"NotImplementedError: Please specify `JointModel.p_control_term` for joint type `rr`\" ) executing generators: 0%| | 0/1 [00:00<?, ?it/s] NotImplementedError: Please specify `JointModel.p_control_term` for joint type `rr`","title":"Custom joint type"},{"location":"notebooks/custom_joint_type/#defining-a-custom-joint-type-that-supports-dynamical-simulation","text":"In this notebook we will define a new joint type that is a hinge joint with a random joint axes direction. It will also support dynamical simulation . import ring from ring import maths , base import jax import jax.numpy as jnp import mediapy as media from ring.algorithms.jcalc import _draw_rxyz We will give this new joint type the identifier rr (random revolute). Although it actually already exists in the library, but we can overwrite it. # we use such a `params` input to specify the joint-axes, if we later then randomize the attribute of the system object # we will have the effect of a hinge joint with a randomized joint axes direction # here we tell the library how it should initialize this `params` PyTree def _draw_random_joint_axis ( key ): return maths . rotate ( jnp . array ([ 1.0 , 0 , 0 ]), maths . quat_random ( key )) def _rr_init_joint_params ( key ): return dict ( joint_axes = _draw_random_joint_axis ( key )) # next, we tell the library how it can randomly draw a trajectory for its generalized coordinate; the hinge joint angle def _rr_transform ( q , params ): # here we use this `params` object axis = params [ \"joint_axes\" ] q = jnp . squeeze ( q ) rot = maths . quat_rot_axis ( axis , q ) return ring . Transform . create ( rot = rot ) # this tells the library how to dynamically simulate the type of joint def _motion_fn ( params ): return base . Motion . create ( ang = params [ \"joint_axes\" ]) # now, we can put it all together into a new `x_xy.JointModel` rr_joint = ring . JointModel ( _rr_transform , motion = [ _motion_fn ], rcmg_draw_fn = _draw_rxyz , init_joint_params = _rr_init_joint_params ) # and then we register the joint; Note that `overwrite`=True, because it already exists; that way you can e.g. overwrite the # default joint types such as the free joint ring . register_new_joint_type ( \"rr\" , rr_joint , q_width = 1 , qd_width = 1 , overwrite = True ) xml_str = \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <geom dim=\"0.1\" type=\"xyz\"></geom> <body damping=\".01\" joint=\"rr\" name=\"pendulum\" pos=\"0 0 0.5\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.5 0.1 0.1\" mass=\"0.5\" pos=\"0.25 0 0\" type=\"box\"></geom> </body> </worldbody> </x_xy> \"\"\" # this seed determines (among other things) the randomness of the joint-axes direction # via the above specified `_rr_init_joint_params` seed : int = 2 sys = ring . System . create ( xml_str , seed = seed ) state = ring . State . create ( sys ) xs = [] for t in range ( 500 ): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) sys . links . joint_params {'rr': {'joint_axes': Array([[ 0.41278404, -0.6329913 , 0.65492845]], dtype=float32)}, 'default': Array([], shape=(1, 0), dtype=float32)} def show_video ( sys , xs : list [ ring . Transform ]): frames = sys . render ( xs , render_every_nth = 4 ) media . show_video ( frames , fps = 25 ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:01<00:00, 94.24it/s] This browser does not support the video tag. the class x_xy.RCMG already has the built-in flag randomize_joint_params which can be toggled in order to use the user-provided logic _rr_init_joint_params for randomizing the joint parameters ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , randomize_joint_params = True , keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:02<00:00, 2.70s/it] show_video ( sys , x ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1500/1500 [00:14<00:00, 103.09it/s] This browser does not support the video tag. but for dynamic_simulation flag to work we additional need to specify the function ring.JointModel.p_control_term print ( rr_joint . p_control_term ) None try : ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , randomize_joint_params = True , keep_output_extras = True , dynamic_simulation = True ) . to_list ()[ 0 ] except NotImplementedError : print ( \"NotImplementedError: Please specify `JointModel.p_control_term` for joint type `rr`\" ) executing generators: 0%| | 0/1 [00:00<?, ?it/s] NotImplementedError: Please specify `JointModel.p_control_term` for joint type `rr`","title":"Defining a custom Joint Type that supports dynamical simulation"},{"location":"notebooks/error_quaternion/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . The error quaternion (required for ML purposes) \u00a4 In this notebook we will talk about what functions you need to do ML with quaternions. After all the purpose of this library is to create training data. Typically, this involves quaternions as target values (to be predicted), similar to an orientation estimation filter (like VQF). So, suppose you want to train some ML model that predicts a quaternion \\(\\hat{q} = f_\\theta(X)\\) . import ring import jax import jax.numpy as jnp import matplotlib.pyplot as plt How to get a quaternion as network output? \u00a4 That's easy enough. You normalize a four dimensional vector. # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X norm = jnp . linalg . norm ( q_unnormalized ) return q_unnormalized / norm def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 But this is dangerous as this might lead to NaNs. X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(nan, dtype=float32) We could try to fix is by adding a small number in the divison. # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X norm = jnp . linalg . norm ( q_unnormalized ) eps = 1e-8 return q_unnormalized / ( norm + eps ) def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(0., dtype=float32) But, still the gradient required for backpropagation gives NaNs. jax . grad ( loss_fn )( params , X , y ) Array([[nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan]], dtype=float32) The solution is a little involved. TLDR; Use x_xy.maths.safe_normalize # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X return ring . maths . safe_normalize ( q_unnormalized ) def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(0., dtype=float32) jax . grad ( loss_fn )( params , X , y ) Array([[0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.]], dtype=float32) A closer look at the function x_xy.maths.angle_error \u00a4 Let's take a closer look at the function x_xy.maths.angle_error which was used in the loss_fn in the above. What is the behaviour of the error function (sort of the metric) between two quaternions as one approaches the other? A first implementation might look like this: def quat_error ( q , qhat ): q_error = ring . maths . quat_mul ( ring . maths . quat_inv ( q ), qhat ) phi = 2 * jnp . arccos ( q_error [ 0 ]) return jnp . abs ( phi ) Let's reduce this function to the critical operation phi = ... and let's assume, without loss of generality, that the target quaternion is the identity quaternion. Then, this effectively becomes about extracting the angle from a quaternion safely. def quat_angle ( q ): return 2 * jnp . arccos ( q [ 0 ]) input_angles = jnp . linspace ( - 0.005 , 0.005 , num = 1000 ) def input_to_output_angles_incorrect ( angle ): q = ring . maths . quat_rot_axis ( jnp . array ([ 1.0 , 0 , 0 ]), angle ) return quat_angle ( q ) def input_to_output_angles_correct ( angle ): q = ring . maths . quat_rot_axis ( jnp . array ([ 1.0 , 0 , 0 ]), angle ) return ring . maths . quat_angle ( q ) plt . plot ( input_angles , jax . vmap ( input_to_output_angles_incorrect )( input_angles ), label = \"incorrect\" ) plt . plot ( input_angles , jax . vmap ( input_to_output_angles_correct )( input_angles ), label = \"correct\" ) plt . legend () plt . show () As one might expect, the gradients are also much more stable. plt . plot ( input_angles , jax . vmap ( jax . grad ( input_to_output_angles_incorrect ))( input_angles ), label = \"incorrect\" ) plt . plot ( input_angles , jax . vmap ( jax . grad ( input_to_output_angles_correct ))( input_angles ), label = \"correct\" ) plt . legend () plt . show () Pytorch library for quaternion operations \u00a4 These functions are for JAX, but the following should work for PyTorch -> https://naver.github.io/roma/","title":"Error quaternion"},{"location":"notebooks/error_quaternion/#the-error-quaternion-required-for-ml-purposes","text":"In this notebook we will talk about what functions you need to do ML with quaternions. After all the purpose of this library is to create training data. Typically, this involves quaternions as target values (to be predicted), similar to an orientation estimation filter (like VQF). So, suppose you want to train some ML model that predicts a quaternion \\(\\hat{q} = f_\\theta(X)\\) . import ring import jax import jax.numpy as jnp import matplotlib.pyplot as plt","title":"The error quaternion (required for ML purposes)"},{"location":"notebooks/error_quaternion/#how-to-get-a-quaternion-as-network-output","text":"That's easy enough. You normalize a four dimensional vector. # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X norm = jnp . linalg . norm ( q_unnormalized ) return q_unnormalized / norm def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 But this is dangerous as this might lead to NaNs. X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(nan, dtype=float32) We could try to fix is by adding a small number in the divison. # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X norm = jnp . linalg . norm ( q_unnormalized ) eps = 1e-8 return q_unnormalized / ( norm + eps ) def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(0., dtype=float32) But, still the gradient required for backpropagation gives NaNs. jax . grad ( loss_fn )( params , X , y ) Array([[nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan], [nan, nan, nan, nan, nan, nan]], dtype=float32) The solution is a little involved. TLDR; Use x_xy.maths.safe_normalize # suppose a 6D IMU input feature_dim = 6 params = jax . random . normal ( jax . random . PRNGKey ( 1 ), ( 4 , feature_dim )) def neural_network ( params , X ): q_unnormalized = params @X return ring . maths . safe_normalize ( q_unnormalized ) def loss_fn ( params , X , y ): q , qhat = y , neural_network ( params , X ) # squared angle error return ring . maths . angle_error ( q , qhat ) ** 2 X = jnp . zeros (( 6 ,)) y = jnp . array ([ 1.0 , 0 , 0 , 0 ]) loss_fn ( params , X , y ) Array(0., dtype=float32) jax . grad ( loss_fn )( params , X , y ) Array([[0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.]], dtype=float32)","title":"How to get a quaternion as network output?"},{"location":"notebooks/error_quaternion/#a-closer-look-at-the-function-x_xymathsangle_error","text":"Let's take a closer look at the function x_xy.maths.angle_error which was used in the loss_fn in the above. What is the behaviour of the error function (sort of the metric) between two quaternions as one approaches the other? A first implementation might look like this: def quat_error ( q , qhat ): q_error = ring . maths . quat_mul ( ring . maths . quat_inv ( q ), qhat ) phi = 2 * jnp . arccos ( q_error [ 0 ]) return jnp . abs ( phi ) Let's reduce this function to the critical operation phi = ... and let's assume, without loss of generality, that the target quaternion is the identity quaternion. Then, this effectively becomes about extracting the angle from a quaternion safely. def quat_angle ( q ): return 2 * jnp . arccos ( q [ 0 ]) input_angles = jnp . linspace ( - 0.005 , 0.005 , num = 1000 ) def input_to_output_angles_incorrect ( angle ): q = ring . maths . quat_rot_axis ( jnp . array ([ 1.0 , 0 , 0 ]), angle ) return quat_angle ( q ) def input_to_output_angles_correct ( angle ): q = ring . maths . quat_rot_axis ( jnp . array ([ 1.0 , 0 , 0 ]), angle ) return ring . maths . quat_angle ( q ) plt . plot ( input_angles , jax . vmap ( input_to_output_angles_incorrect )( input_angles ), label = \"incorrect\" ) plt . plot ( input_angles , jax . vmap ( input_to_output_angles_correct )( input_angles ), label = \"correct\" ) plt . legend () plt . show () As one might expect, the gradients are also much more stable. plt . plot ( input_angles , jax . vmap ( jax . grad ( input_to_output_angles_incorrect ))( input_angles ), label = \"incorrect\" ) plt . plot ( input_angles , jax . vmap ( jax . grad ( input_to_output_angles_correct ))( input_angles ), label = \"correct\" ) plt . legend () plt . show ()","title":"A closer look at the function x_xy.maths.angle_error"},{"location":"notebooks/error_quaternion/#pytorch-library-for-quaternion-operations","text":"These functions are for JAX, but the following should work for PyTorch -> https://naver.github.io/roma/","title":"Pytorch library for quaternion operations"},{"location":"notebooks/experimental_data/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . Loading and working with experimental data \u00a4 import ring import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media def show_video ( sys : ring . System , xs : ring . Transform ) -& gt ; None : assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = sys . render ( xs , camera = \"c\" , height = 480 , width = 640 , render_every_nth = 4 , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\".5 -.5 1.25\" target=\"3\"></camera>' }) media . show_video ( frames , fps = 25 ) Experimental data and system definitions of the experimental setup are located in.. from diodem import load_data , benchmark Multiple experimental trials are available. They have exp_id s and motion_start s and motion_stop s # inertial motion tracking problem (IMTP) exp_id = 1 imtp = benchmark . IMTP ([ f \"seg { i } \" for i in range ( 1 , 6 )]) sys = imtp . sys ( exp_id ) Let's first take a look at the system that was used in the experiments. state = ring . State . create ( sys ) # update the maximal coordinates xs = ring . algorithms . forward_kinematics ( sys , state )[ 1 ] . x show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00, 6.64it/s] This browser does not support the video tag. As you can see a five segment kinematic chain was moved, and for each segment IMU measurements and OMC ground truth is available. Let's load this (no simulated) IMU and OMC data. # `canonical` is the identifier of the first motion pattern performed in this trial # `shaking` is the identifier of the last motion pattern performed in this trial motion_start = \"canonical\" data = load_data ( exp_id , motion_start = motion_start ) data . keys () dict_keys(['seg1', 'seg2', 'seg3', 'seg4', 'seg5']) data [ \"seg1\" ] . keys () dict_keys(['imu_nonrigid', 'imu_rigid', 'marker1', 'marker2', 'marker3', 'marker4', 'quat']) data [ \"seg1\" ][ \"imu_rigid\" ] . keys () dict_keys(['acc', 'gyr', 'mag']) The quaternion quat is to be interpreted as the rotation from segment to an arbitrary OMC inertial frame. The position marker1 is to be interpreted as the position vector from arbitrary OMC inertial frame to a specific marker (marker 1) on the respective segment (vector given in the OMC inertial frame). Then, for each segment actually two IMUs are attached to it. One is rigidly attached, one is non-rigidly attached (via foam). Also, how long is the trial? data [ \"seg1\" ][ \"marker1\" ] . shape (14200, 3) It's 325 seconds of data. Let's take a look at the motion of the whole trial. To render it, we need maximal coordinates xs of all links in the system. X , y , xs , xs_noimu = benchmark . benchmark ( imtp , exp_id , motion_start ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3550/3550 [00:33<00:00, 104.73it/s] This browser does not support the video tag. Perfect. This is a rendered animation of the real experimental motion that was performed. You can see that the spacing between segments is not perfect. This is because in our idealistic system model joints have no spatial dimension but in reality they have. The entire setup is 3D printed, and the joints are also several centimeters long. The segments are 20cm long. We can use this experimental data to validate our simulated approaches or validate ML models that are learned on simulated training data.","title":"Experimental data"},{"location":"notebooks/experimental_data/#loading-and-working-with-experimental-data","text":"import ring import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media def show_video ( sys : ring . System , xs : ring . Transform ) -& gt ; None : assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = sys . render ( xs , camera = \"c\" , height = 480 , width = 640 , render_every_nth = 4 , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\".5 -.5 1.25\" target=\"3\"></camera>' }) media . show_video ( frames , fps = 25 ) Experimental data and system definitions of the experimental setup are located in.. from diodem import load_data , benchmark Multiple experimental trials are available. They have exp_id s and motion_start s and motion_stop s # inertial motion tracking problem (IMTP) exp_id = 1 imtp = benchmark . IMTP ([ f \"seg { i } \" for i in range ( 1 , 6 )]) sys = imtp . sys ( exp_id ) Let's first take a look at the system that was used in the experiments. state = ring . State . create ( sys ) # update the maximal coordinates xs = ring . algorithms . forward_kinematics ( sys , state )[ 1 ] . x show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00, 6.64it/s] This browser does not support the video tag. As you can see a five segment kinematic chain was moved, and for each segment IMU measurements and OMC ground truth is available. Let's load this (no simulated) IMU and OMC data. # `canonical` is the identifier of the first motion pattern performed in this trial # `shaking` is the identifier of the last motion pattern performed in this trial motion_start = \"canonical\" data = load_data ( exp_id , motion_start = motion_start ) data . keys () dict_keys(['seg1', 'seg2', 'seg3', 'seg4', 'seg5']) data [ \"seg1\" ] . keys () dict_keys(['imu_nonrigid', 'imu_rigid', 'marker1', 'marker2', 'marker3', 'marker4', 'quat']) data [ \"seg1\" ][ \"imu_rigid\" ] . keys () dict_keys(['acc', 'gyr', 'mag']) The quaternion quat is to be interpreted as the rotation from segment to an arbitrary OMC inertial frame. The position marker1 is to be interpreted as the position vector from arbitrary OMC inertial frame to a specific marker (marker 1) on the respective segment (vector given in the OMC inertial frame). Then, for each segment actually two IMUs are attached to it. One is rigidly attached, one is non-rigidly attached (via foam). Also, how long is the trial? data [ \"seg1\" ][ \"marker1\" ] . shape (14200, 3) It's 325 seconds of data. Let's take a look at the motion of the whole trial. To render it, we need maximal coordinates xs of all links in the system. X , y , xs , xs_noimu = benchmark . benchmark ( imtp , exp_id , motion_start ) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3550/3550 [00:33<00:00, 104.73it/s] This browser does not support the video tag. Perfect. This is a rendered animation of the real experimental motion that was performed. You can see that the spacing between segments is not perfect. This is because in our idealistic system model joints have no spatial dimension but in reality they have. The entire setup is 3D printed, and the joints are also several centimeters long. The segments are 20cm long. We can use this experimental data to validate our simulated approaches or validate ML models that are learned on simulated training data.","title":"Loading and working with experimental data"},{"location":"notebooks/getting_started/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install --quiet imt-ring\" ) os . system ( \"pip install --quiet matplotlib\" ) import ring # automatically detects colab or not ring . utils . setup_colab_env () import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media Systems are defined with the following xml syntax. xml_str = \"\"\" <x_xy model=\"double_pendulum\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"2\" euler=\"0 90 0\" joint=\"ry\" name=\"upper\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body damping=\"2\" joint=\"ry\" name=\"lower\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" With this xml description of the system, we are ready to load the system using load_sys_from_str . We can also save this to a text-file double_pendulum.xml and load with load_sys_from_xml . sys = ring . System . create ( xml_str ) sys . model_name 'double_pendulum' System objects have many attributes. You may refer to the API documentation for more details. sys . link_names ['upper', 'lower'] Dynamical Simulation \u00a4 Let's start with the most obvious. A physical simulation. We refer to it as \"dynamical simulation\", in contrast to what we do a little later which is a purely kinematic simulation. First, we have to create the dynamical state of the system. It is defined by the all degrees of freedom in the system and their velocities. Here, we have two revolute joints (one degree of freedom). Thus, the minimal coordinates vector \\(q\\) and minimal velocity vector \\(q'\\) has two dimensions. state = ring . State . create ( sys ) state . q Array([0., 0.], dtype=float32) state . qd Array([0., 0.], dtype=float32) next_state = ring . step ( sys , state ) Massive speedups if we use jax.jit to jit-compile the function. % timeit ring . step ( sys , state ) 193 ms \u00b1 10.9 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) % timeit jax . jit ( ring . step )( sys , state ) 104 \u00b5s \u00b1 53.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) Let's unroll the dynamics for multiple timesteps. T = 10.0 xs = [] for _ in range ( int ( T / sys . dt )): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) Next, let's render the frames and create an animation. frames = sys . render ( xs , camera = \"targetfar\" ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.09it/s] def show_video ( frames : list [ np . ndarray ], dt : float ): assert dt == 0.01 # frames are at 100 Hz, but let's create an animation at 25Hz media . show_video ([ frames [ i ][ ... , : 3 ] for i in range ( 0 , len ( frames ), 4 )], fps = 25 ) show_video ( frames , sys . dt ) This browser does not support the video tag. Hmm, pretty boring. Let's get the pendulum into an configuration with some potential energy. All we have to change is the initial state state.q . state = ring . State . create ( sys , q = jnp . array ([ jnp . pi / 2 , 0 ])) T = 10.0 xs = [] for _ in range ( int ( T / sys . dt )): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) frames = sys . render ( xs , camera = \"targetfar\" ) show_video ( frames , sys . dt ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.34it/s] This browser does not support the video tag. That's more like it! Next, we will take a look at \"kinematic simulation\". Kinematic Simulation \u00a4 Let's start with why you would want this. Imagine we want to learn a filter that estimates some quantity of interest from some sensor input. Then, we could try to create many random motions, record the measured sensor input, and the ground truth quantity of interest target values. This is then used as training data for a Machine Learning model. The general interface to kinematic simulation is via x_xy.RCMG . This class can then create - a function (of type Generator ) that maps a PRNG seed to, e.g., X, y data. - a list of data - data on disk (saved via pickle or hdf5) ( X , y ), ( key , q , xs , _ ) = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:02<00:00, 2.57s/it] frames = sys . render ( xs , camera = \"targetfar\" ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.98it/s] This is now completely random, but unphysical motion. It's only kinematics, but that is okay for creating training data. show_video ( frames , sys . dt ) This browser does not support the video tag. X, y Training data / Attaching sensors \u00a4 We are interested in simulating IMU data as input X , and estimating quaternions as target y . We can easily simulate an IMU with only the trajectory of maximal coordinates xs . Suppose, we want to simulate an IMU right that is placed on the lower segment and right at the revolute joint. This is exactly where the coordinate system of the lower segment is placed. Right now the xs trajectory contains both coordinate sytems of upper and lower . # (n_timesteps, n_links, 3) xs . pos . shape (1000, 2, 3) # (n_timesteps, n_links, 4) xs . rot . shape (1000, 2, 4) From the axis with length two, the 0th entry is for upper and the 1st entry is for lower . sys . name_to_idx ( \"upper\" ) 0 sys . name_to_idx ( \"lower\" ) 1 xs_lower = xs . take ( 1 , axis = 1 ) imu_lower = ring . algorithms . imu ( xs_lower , sys . gravity , sys . dt ) imu_lower . keys () dict_keys(['acc', 'gyr']) plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), imu_lower [ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) plt . ylabel ( \"gyro [rad / s]\" ) plt . xlabel ( \"time [s]\" ) plt . legend () plt . show () As you can see it's a two-dimensional problem, which is why only one ( y ) is non-zero. Let's consider a larger kinematic chain in free 3D space. xml_str = \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) data = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), add_X_imus = True , add_y_relpose = True , keep_output_extras = True ) . to_list () # with `keep_output_extras` really everything one could possibly imagine is returned ( X , y ), ( key , qs , xs , sys_mod ) = data [ 0 ] frames = sys . render ( xs , camera = \"targetfar\" ) show_video ( frames , sys . dt ) executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:06<00:00, 6.97s/it] Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 102.55it/s] This browser does not support the video tag. The two orange boxes on segment 1 and segment 3 are modelling our two IMUs. This will be the network's input X data. As target we will try to estimate both relative orientations as y data. X . keys () dict_keys(['seg1', 'seg2', 'seg3']) X [ \"seg1\" ] . keys () dict_keys(['acc', 'gyr']) y . keys () dict_keys(['seg1', 'seg3']) plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), X [ \"seg1\" ][ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) plt . ylabel ( \"gyro [rad / s]\" ) plt . xlabel ( \"time [s]\" ) plt . title ( \"IMU 1 Gyroscope\" ) plt . legend () plt . show () Now, the IMU is non-zero in all three x/y/z components. plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), y [ \"seg1\" ], label = [ \"w\" , \"x\" , \"y\" , \"z\" ]) plt . xlabel ( \"time [s]\" ) plt . title ( \"Relative quaternion from seg2 to seg1\" ) plt . legend () plt . show () Note how the relative quaternion is only around the y-axis. Can you see why? (Hint: Check the defining xml_str .)","title":"Getting started"},{"location":"notebooks/getting_started/#dynamical-simulation","text":"Let's start with the most obvious. A physical simulation. We refer to it as \"dynamical simulation\", in contrast to what we do a little later which is a purely kinematic simulation. First, we have to create the dynamical state of the system. It is defined by the all degrees of freedom in the system and their velocities. Here, we have two revolute joints (one degree of freedom). Thus, the minimal coordinates vector \\(q\\) and minimal velocity vector \\(q'\\) has two dimensions. state = ring . State . create ( sys ) state . q Array([0., 0.], dtype=float32) state . qd Array([0., 0.], dtype=float32) next_state = ring . step ( sys , state ) Massive speedups if we use jax.jit to jit-compile the function. % timeit ring . step ( sys , state ) 193 ms \u00b1 10.9 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) % timeit jax . jit ( ring . step )( sys , state ) 104 \u00b5s \u00b1 53.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) Let's unroll the dynamics for multiple timesteps. T = 10.0 xs = [] for _ in range ( int ( T / sys . dt )): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) Next, let's render the frames and create an animation. frames = sys . render ( xs , camera = \"targetfar\" ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.09it/s] def show_video ( frames : list [ np . ndarray ], dt : float ): assert dt == 0.01 # frames are at 100 Hz, but let's create an animation at 25Hz media . show_video ([ frames [ i ][ ... , : 3 ] for i in range ( 0 , len ( frames ), 4 )], fps = 25 ) show_video ( frames , sys . dt ) This browser does not support the video tag. Hmm, pretty boring. Let's get the pendulum into an configuration with some potential energy. All we have to change is the initial state state.q . state = ring . State . create ( sys , q = jnp . array ([ jnp . pi / 2 , 0 ])) T = 10.0 xs = [] for _ in range ( int ( T / sys . dt )): state = jax . jit ( ring . step )( sys , state ) xs . append ( state . x ) frames = sys . render ( xs , camera = \"targetfar\" ) show_video ( frames , sys . dt ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.34it/s] This browser does not support the video tag. That's more like it! Next, we will take a look at \"kinematic simulation\".","title":"Dynamical Simulation"},{"location":"notebooks/getting_started/#kinematic-simulation","text":"Let's start with why you would want this. Imagine we want to learn a filter that estimates some quantity of interest from some sensor input. Then, we could try to create many random motions, record the measured sensor input, and the ground truth quantity of interest target values. This is then used as training data for a Machine Learning model. The general interface to kinematic simulation is via x_xy.RCMG . This class can then create - a function (of type Generator ) that maps a PRNG seed to, e.g., X, y data. - a list of data - data on disk (saved via pickle or hdf5) ( X , y ), ( key , q , xs , _ ) = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:02<00:00, 2.57s/it] frames = sys . render ( xs , camera = \"targetfar\" ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 105.98it/s] This is now completely random, but unphysical motion. It's only kinematics, but that is okay for creating training data. show_video ( frames , sys . dt ) This browser does not support the video tag.","title":"Kinematic Simulation"},{"location":"notebooks/getting_started/#x-y-training-data-attaching-sensors","text":"We are interested in simulating IMU data as input X , and estimating quaternions as target y . We can easily simulate an IMU with only the trajectory of maximal coordinates xs . Suppose, we want to simulate an IMU right that is placed on the lower segment and right at the revolute joint. This is exactly where the coordinate system of the lower segment is placed. Right now the xs trajectory contains both coordinate sytems of upper and lower . # (n_timesteps, n_links, 3) xs . pos . shape (1000, 2, 3) # (n_timesteps, n_links, 4) xs . rot . shape (1000, 2, 4) From the axis with length two, the 0th entry is for upper and the 1st entry is for lower . sys . name_to_idx ( \"upper\" ) 0 sys . name_to_idx ( \"lower\" ) 1 xs_lower = xs . take ( 1 , axis = 1 ) imu_lower = ring . algorithms . imu ( xs_lower , sys . gravity , sys . dt ) imu_lower . keys () dict_keys(['acc', 'gyr']) plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), imu_lower [ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) plt . ylabel ( \"gyro [rad / s]\" ) plt . xlabel ( \"time [s]\" ) plt . legend () plt . show () As you can see it's a two-dimensional problem, which is why only one ( y ) is non-zero. Let's consider a larger kinematic chain in free 3D space. xml_str = \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( xml_str ) data = ring . RCMG ( sys , ring . MotionConfig ( T = 10.0 , t_max = 1.5 ), add_X_imus = True , add_y_relpose = True , keep_output_extras = True ) . to_list () # with `keep_output_extras` really everything one could possibly imagine is returned ( X , y ), ( key , qs , xs , sys_mod ) = data [ 0 ] frames = sys . render ( xs , camera = \"targetfar\" ) show_video ( frames , sys . dt ) executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:06<00:00, 6.97s/it] Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:09<00:00, 102.55it/s] This browser does not support the video tag. The two orange boxes on segment 1 and segment 3 are modelling our two IMUs. This will be the network's input X data. As target we will try to estimate both relative orientations as y data. X . keys () dict_keys(['seg1', 'seg2', 'seg3']) X [ \"seg1\" ] . keys () dict_keys(['acc', 'gyr']) y . keys () dict_keys(['seg1', 'seg3']) plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), X [ \"seg1\" ][ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) plt . ylabel ( \"gyro [rad / s]\" ) plt . xlabel ( \"time [s]\" ) plt . title ( \"IMU 1 Gyroscope\" ) plt . legend () plt . show () Now, the IMU is non-zero in all three x/y/z components. plt . grid () plt . plot ( np . arange ( 0 , 10.0 , step = sys . dt ), y [ \"seg1\" ], label = [ \"w\" , \"x\" , \"y\" , \"z\" ]) plt . xlabel ( \"time [s]\" ) plt . title ( \"Relative quaternion from seg2 to seg1\" ) plt . legend () plt . show () Note how the relative quaternion is only around the y-axis. Can you see why? (Hint: Check the defining xml_str .)","title":"X, y Training data / Attaching sensors"},{"location":"notebooks/imu_modeling/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); On \"what IMUs measure\" \u00a4 from x_xy.subpkgs import exp import matplotlib.pyplot as plt import jax import x_xy import jax.numpy as jnp hz = 100 markerMap = { \"seg1\" : 2 , \"seg5\" : 2 , \"seg2\" : 1 , \"seg3\" : 2 , \"seg4\" : 4 } def load_data ( seg : str , t1 : float , t2 : float , motion : str = \"fast\" ): data = exp . load_data ( \"S_06\" , motion )[ seg ] # extract a small window from long time series for plotting pos , rot , imu_data = jax . tree_map ( lambda arr : arr [ int ( t1 * hz ): int ( t2 * hz )], ( data [ f \"marker { markerMap [ seg ] } \" ], data [ \"quat\" ], data [ \"imu_rigid\" ])) rot = x_xy . maths . quat_inv ( rot ) # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation xs = x_xy . Transform . create ( pos , rot ) return pos , rot , xs , imu_data t1 , t2 = 3.0 , 9.0 pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 ) Remove gravity from accelerometer to better compare. def linear_acceleration ( xs : x_xy . Transform , acc : jax . Array ) -& gt ; jax . Array : q_E2Imu = xs . rot q_Imu2E = x_xy . maths . quat_inv ( q_E2Imu ) gravity = jnp . array ([ 0 , 0 , 9.81 ]) acc_E_nograv = x_xy . maths . rotate ( acc , q_Imu2E ) - gravity return x_xy . maths . rotate ( acc_E_nograv , q_E2Imu ) imu_data [ \"acc\" ] = linear_acceleration ( xs , imu_data [ \"acc\" ]) Real-world IMU \u00a4 def plot_imu ( imu_data : dict ): imu_data = jax . tree_map ( lambda arr : arr [: - 100 ], imu_data . copy ()) fig , axes = plt . subplots ( 1 , 2 , figsize = ( 12 , 4 )) ts = jnp . arange ( t1 , t2 - 1.0 , step = 1 / hz ) axes [ 0 ] . plot ( ts , imu_data [ \"acc\" ], label = [ \"x\" , \"y\" , \"z\" ]) axes [ 1 ] . plot ( ts , imu_data [ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) for ax in axes : ax . grid () ax . set_xlabel ( \"time [s]\" ) ax . legend () axes [ 0 ] . set_title ( \"Acc\" ) axes [ 1 ] . set_title ( \"Gyr\" ) plot_imu ( imu_data ) Vanilla simulated IMU \u00a4 imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz ) plot_imu ( imu_data ) Accelerometer doesn't look too great! We need low-pass filtering. Two options: Quasi-physical simulation strategy \u00a4 imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz , quasi_physical = True ) plot_imu ( imu_data ) Butterworth filtering \u00a4 imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz , low_pass_filter_pos_f_cutoff = 15.0 , low_pass_filter_rot_alpha = 0.55 ) plot_imu ( imu_data ) Optimize low-pass-filter parameters \u00a4 from scipy.optimize import minimize def optimize_parameters ( seg : str , motion : str ): # include all `fast` data in the optimization t1 , t2 = 0.0 , 500.0 pos , rot , xs , imu_data = load_data ( seg , t1 , t2 , motion ) imu_data [ \"acc\" ] = linear_acceleration ( xs , imu_data [ \"acc\" ]) @jax . jit def objective ( params ): f_cutoff , alpha , offset = params # probably move about 5cm negative x-axis in local CS for e.g. segment 1 pos_offset = x_xy . maths . rotate ( x_xy . maths . rotate ( pos , rot ) + jnp . array ([ offset , 0 , 0 ]), x_xy . maths . quat_inv ( rot )) xs_offset = xs . replace ( pos = pos_offset ) imu = x_xy . imu ( xs_offset , jnp . zeros (( 3 ,)), 1 / hz , low_pass_filter_pos_f_cutoff = f_cutoff , low_pass_filter_rot_alpha = alpha ) return jnp . mean (( imu_data [ \"acc\" ] - imu [ \"acc\" ]) ** 2 ) + jnp . mean (( imu_data [ \"gyr\" ] - imu [ \"gyr\" ]) ** 2 ) return minimize ( objective , jnp . array ([ 5.0 , 1.0 , 0.0 ]), method = \"Nelder-Mead\" ) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"fast\" )) message: Optimization terminated successfully. success: True status: 0 fun: 0.7932413816452026 x: [ 1.135e+01 1.034e+01 1.147e-01] nit: 147 nfev: 287 final_simplex: (array([[ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01]]), array([ 7.932e-01, 7.932e-01, 7.933e-01, 7.933e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.40395233035087585 x: [ 1.123e+01 1.112e+01 1.159e-01] nit: 98 nfev: 198 final_simplex: (array([[ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01]]), array([ 4.040e-01, 4.040e-01, 4.040e-01, 4.040e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.37816864252090454 x: [ 1.190e+01 1.226e+01 1.195e-01] nit: 121 nfev: 238 final_simplex: (array([[ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01]]), array([ 3.782e-01, 3.782e-01, 3.782e-01, 3.782e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.541861355304718 x: [ 1.131e+01 1.372e+01 1.160e-01] nit: 173 nfev: 330 final_simplex: (array([[ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01]]), array([ 5.419e-01, 5.419e-01, 5.419e-01, 5.419e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.6123160123825073 x: [ 1.106e+01 9.883e+00 1.211e-01] nit: 102 nfev: 202 final_simplex: (array([[ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01]]), array([ 6.123e-01, 6.123e-01, 6.123e-01, 6.123e-01])) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"slow1\" )) message: Optimization terminated successfully. success: True status: 0 fun: 0.09304095804691315 x: [ 9.910e+00 3.885e-01 1.136e-01] nit: 111 nfev: 211 final_simplex: (array([[ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01]]), array([ 9.304e-02, 9.305e-02, 9.305e-02, 9.305e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.02368384227156639 x: [ 1.008e+01 3.732e-01 1.332e-01] nit: 97 nfev: 190 final_simplex: (array([[ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01]]), array([ 2.368e-02, 2.369e-02, 2.369e-02, 2.369e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.01580578088760376 x: [ 8.666e+00 3.510e-01 1.343e-01] nit: 111 nfev: 219 final_simplex: (array([[ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.667e+00, 3.510e-01, 1.343e-01]]), array([ 1.581e-02, 1.581e-02, 1.581e-02, 1.581e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.01700039766728878 x: [ 8.336e+00 3.602e-01 1.210e-01] nit: 108 nfev: 208 final_simplex: (array([[ 8.336e+00, 3.602e-01, 1.210e-01], [ 8.336e+00, 3.601e-01, 1.210e-01], [ 8.335e+00, 3.601e-01, 1.210e-01], [ 8.335e+00, 3.602e-01, 1.210e-01]]), array([ 1.700e-02, 1.700e-02, 1.700e-02, 1.700e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.10861615836620331 x: [ 6.784e+00 3.782e-01 5.929e-04] nit: 50 nfev: 107 final_simplex: (array([[ 6.784e+00, 3.782e-01, 5.929e-04], [ 6.784e+00, 3.782e-01, 5.930e-04], [ 6.784e+00, 3.782e-01, 5.930e-04], [ 6.784e+00, 3.782e-01, 5.930e-04]]), array([ 1.086e-01, 1.086e-01, 1.086e-01, 1.086e-01]))","title":"Imu modeling"},{"location":"notebooks/imu_modeling/#on-what-imus-measure","text":"from x_xy.subpkgs import exp import matplotlib.pyplot as plt import jax import x_xy import jax.numpy as jnp hz = 100 markerMap = { \"seg1\" : 2 , \"seg5\" : 2 , \"seg2\" : 1 , \"seg3\" : 2 , \"seg4\" : 4 } def load_data ( seg : str , t1 : float , t2 : float , motion : str = \"fast\" ): data = exp . load_data ( \"S_06\" , motion )[ seg ] # extract a small window from long time series for plotting pos , rot , imu_data = jax . tree_map ( lambda arr : arr [ int ( t1 * hz ): int ( t2 * hz )], ( data [ f \"marker { markerMap [ seg ] } \" ], data [ \"quat\" ], data [ \"imu_rigid\" ])) rot = x_xy . maths . quat_inv ( rot ) # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation xs = x_xy . Transform . create ( pos , rot ) return pos , rot , xs , imu_data t1 , t2 = 3.0 , 9.0 pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 ) Remove gravity from accelerometer to better compare. def linear_acceleration ( xs : x_xy . Transform , acc : jax . Array ) -& gt ; jax . Array : q_E2Imu = xs . rot q_Imu2E = x_xy . maths . quat_inv ( q_E2Imu ) gravity = jnp . array ([ 0 , 0 , 9.81 ]) acc_E_nograv = x_xy . maths . rotate ( acc , q_Imu2E ) - gravity return x_xy . maths . rotate ( acc_E_nograv , q_E2Imu ) imu_data [ \"acc\" ] = linear_acceleration ( xs , imu_data [ \"acc\" ])","title":"On \"what IMUs measure\""},{"location":"notebooks/imu_modeling/#real-world-imu","text":"def plot_imu ( imu_data : dict ): imu_data = jax . tree_map ( lambda arr : arr [: - 100 ], imu_data . copy ()) fig , axes = plt . subplots ( 1 , 2 , figsize = ( 12 , 4 )) ts = jnp . arange ( t1 , t2 - 1.0 , step = 1 / hz ) axes [ 0 ] . plot ( ts , imu_data [ \"acc\" ], label = [ \"x\" , \"y\" , \"z\" ]) axes [ 1 ] . plot ( ts , imu_data [ \"gyr\" ], label = [ \"x\" , \"y\" , \"z\" ]) for ax in axes : ax . grid () ax . set_xlabel ( \"time [s]\" ) ax . legend () axes [ 0 ] . set_title ( \"Acc\" ) axes [ 1 ] . set_title ( \"Gyr\" ) plot_imu ( imu_data )","title":"Real-world IMU"},{"location":"notebooks/imu_modeling/#vanilla-simulated-imu","text":"imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz ) plot_imu ( imu_data ) Accelerometer doesn't look too great! We need low-pass filtering. Two options:","title":"Vanilla simulated IMU"},{"location":"notebooks/imu_modeling/#quasi-physical-simulation-strategy","text":"imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz , quasi_physical = True ) plot_imu ( imu_data )","title":"Quasi-physical simulation strategy"},{"location":"notebooks/imu_modeling/#butterworth-filtering","text":"imu_data = x_xy . imu ( xs , gravity = jnp . zeros (( 3 ,)), dt = 1 / hz , low_pass_filter_pos_f_cutoff = 15.0 , low_pass_filter_rot_alpha = 0.55 ) plot_imu ( imu_data )","title":"Butterworth filtering"},{"location":"notebooks/imu_modeling/#optimize-low-pass-filter-parameters","text":"from scipy.optimize import minimize def optimize_parameters ( seg : str , motion : str ): # include all `fast` data in the optimization t1 , t2 = 0.0 , 500.0 pos , rot , xs , imu_data = load_data ( seg , t1 , t2 , motion ) imu_data [ \"acc\" ] = linear_acceleration ( xs , imu_data [ \"acc\" ]) @jax . jit def objective ( params ): f_cutoff , alpha , offset = params # probably move about 5cm negative x-axis in local CS for e.g. segment 1 pos_offset = x_xy . maths . rotate ( x_xy . maths . rotate ( pos , rot ) + jnp . array ([ offset , 0 , 0 ]), x_xy . maths . quat_inv ( rot )) xs_offset = xs . replace ( pos = pos_offset ) imu = x_xy . imu ( xs_offset , jnp . zeros (( 3 ,)), 1 / hz , low_pass_filter_pos_f_cutoff = f_cutoff , low_pass_filter_rot_alpha = alpha ) return jnp . mean (( imu_data [ \"acc\" ] - imu [ \"acc\" ]) ** 2 ) + jnp . mean (( imu_data [ \"gyr\" ] - imu [ \"gyr\" ]) ** 2 ) return minimize ( objective , jnp . array ([ 5.0 , 1.0 , 0.0 ]), method = \"Nelder-Mead\" ) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"fast\" )) message: Optimization terminated successfully. success: True status: 0 fun: 0.7932413816452026 x: [ 1.135e+01 1.034e+01 1.147e-01] nit: 147 nfev: 287 final_simplex: (array([[ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01], [ 1.135e+01, 1.034e+01, 1.147e-01]]), array([ 7.932e-01, 7.932e-01, 7.933e-01, 7.933e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.40395233035087585 x: [ 1.123e+01 1.112e+01 1.159e-01] nit: 98 nfev: 198 final_simplex: (array([[ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01], [ 1.123e+01, 1.112e+01, 1.159e-01]]), array([ 4.040e-01, 4.040e-01, 4.040e-01, 4.040e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.37816864252090454 x: [ 1.190e+01 1.226e+01 1.195e-01] nit: 121 nfev: 238 final_simplex: (array([[ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01], [ 1.190e+01, 1.226e+01, 1.195e-01]]), array([ 3.782e-01, 3.782e-01, 3.782e-01, 3.782e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.541861355304718 x: [ 1.131e+01 1.372e+01 1.160e-01] nit: 173 nfev: 330 final_simplex: (array([[ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01], [ 1.131e+01, 1.372e+01, 1.160e-01]]), array([ 5.419e-01, 5.419e-01, 5.419e-01, 5.419e-01])) message: Optimization terminated successfully. success: True status: 0 fun: 0.6123160123825073 x: [ 1.106e+01 9.883e+00 1.211e-01] nit: 102 nfev: 202 final_simplex: (array([[ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01], [ 1.106e+01, 9.883e+00, 1.211e-01]]), array([ 6.123e-01, 6.123e-01, 6.123e-01, 6.123e-01])) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"slow1\" )) message: Optimization terminated successfully. success: True status: 0 fun: 0.09304095804691315 x: [ 9.910e+00 3.885e-01 1.136e-01] nit: 111 nfev: 211 final_simplex: (array([[ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01], [ 9.910e+00, 3.885e-01, 1.136e-01]]), array([ 9.304e-02, 9.305e-02, 9.305e-02, 9.305e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.02368384227156639 x: [ 1.008e+01 3.732e-01 1.332e-01] nit: 97 nfev: 190 final_simplex: (array([[ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01], [ 1.008e+01, 3.732e-01, 1.332e-01]]), array([ 2.368e-02, 2.369e-02, 2.369e-02, 2.369e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.01580578088760376 x: [ 8.666e+00 3.510e-01 1.343e-01] nit: 111 nfev: 219 final_simplex: (array([[ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.666e+00, 3.510e-01, 1.343e-01], [ 8.667e+00, 3.510e-01, 1.343e-01]]), array([ 1.581e-02, 1.581e-02, 1.581e-02, 1.581e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.01700039766728878 x: [ 8.336e+00 3.602e-01 1.210e-01] nit: 108 nfev: 208 final_simplex: (array([[ 8.336e+00, 3.602e-01, 1.210e-01], [ 8.336e+00, 3.601e-01, 1.210e-01], [ 8.335e+00, 3.601e-01, 1.210e-01], [ 8.335e+00, 3.602e-01, 1.210e-01]]), array([ 1.700e-02, 1.700e-02, 1.700e-02, 1.700e-02])) message: Optimization terminated successfully. success: True status: 0 fun: 0.10861615836620331 x: [ 6.784e+00 3.782e-01 5.929e-04] nit: 50 nfev: 107 final_simplex: (array([[ 6.784e+00, 3.782e-01, 5.929e-04], [ 6.784e+00, 3.782e-01, 5.930e-04], [ 6.784e+00, 3.782e-01, 5.930e-04], [ 6.784e+00, 3.782e-01, 5.930e-04]]), array([ 1.086e-01, 1.086e-01, 1.086e-01, 1.086e-01]))","title":"Optimize low-pass-filter parameters"},{"location":"notebooks/knee_angle_tracking/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install -q imt-ring\" ) os . system ( \"pip install -q matplotlib\" ) import ring # automatically detects colab or not ring . utils . setup_colab_env () import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media sys_str = \"\"\" <x_xy model=\"knee\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body euler=\"0 0 140\" joint=\"frozen\" name=\"femur\" pos=\"0 0 0.5\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.05 0.4\" mass=\"1\" pos=\"0 0 -0.2\" type=\"capsule\"></geom> <body joint=\"frozen\" name=\"imu_femur\" pos=\"0 .06 -.2\" pos_max=\".05 .08 -.1\" pos_min=\"-.05 0 -.3\"> <geom dim=\"0.05\" type=\"xyz\"></geom> <geom color=\"orange\" dim=\"0.05 0.02 0.05\" mass=\"0.1\" type=\"box\"></geom> </body> <body damping=\"3\" joint=\"rx\" name=\"tibia\" pos=\"0 0 -0.4\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.04 0.4\" mass=\"1\" pos=\"0 0 -0.2\" type=\"capsule\"></geom> <geom dim=\"0.05 0.15 0.025\" mass=\"0.1\" pos=\"0 0.04 -0.45\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu_tibia\" pos=\"0 0.05 -0.2\" pos_max=\".05 .07 -.1\" pos_min=\"-.05 0 -.3\"> <geom dim=\"0.05\" type=\"xyz\"></geom> <geom color=\"orange\" dim=\"0.05 0.02 0.05\" mass=\"0.1\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" # noqa: E501 sys = ring . System . create ( sys_str ) media . show_image ( sys . render ( width = 640 , height = 480 , camera = \"custom\" , add_cameras = { - 1 : '<camera euler=\"80 0 0\" mode=\"fixed\" name=\"custom\" pos=\"0 -1.8 0.4\"></camera>' })[ 0 ]) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00, 3.86it/s] ( X , _ ), ( _ , qs , xs , _ ) = ring . RCMG ( sys , ring . MotionConfig ( T = 20.0 , t_min = 0.3 , t_max = 1.5 ), keep_output_extras = 1 , add_X_imus = 1 ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:05<00:00, 5.41s/it] media . show_video ( sys . render ( xs , width = 640 , height = 480 , camera = \"custom\" , add_cameras = { - 1 : '<camera euler=\"80 0 0\" mode=\"fixed\" name=\"custom\" pos=\"0 -1.8 0.4\"></camera>' }, render_every_nth = 4 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:04<00:00, 102.34it/s] This browser does not support the video tag. X . keys () dict_keys(['femur', 'tibia']) X [ \"femur\" ] . keys () dict_keys(['acc', 'gyr']) # number of timesteps T = 2000 # graph lam = ( - 1 , 0 ) # number of bodies (excluding IMUs); so tibia and femur N = len ( lam ) ringnet = ring . RING ( lam , None ) X_ring = np . zeros (( T , N , 10 )) X_ring [:, 0 , : 3 ] = X [ \"femur\" ][ \"acc\" ] X_ring [:, 0 , 3 : 6 ] = X [ \"femur\" ][ \"gyr\" ] X_ring [:, 1 , : 3 ] = X [ \"tibia\" ][ \"acc\" ] X_ring [:, 1 , 3 : 6 ] = X [ \"tibia\" ][ \"gyr\" ] # time-delta between timesteps or inverse of sampling rate X_ring [:, :, 9 ] = float ( sys . dt ) # We could assume that we don't know the hinge joint axis direction KNOWN_JOINT_AXIS = True if KNOWN_JOINT_AXIS : # the components 6:9 store the axis direction; here it is rx-joint; Revolute x-axis X_ring [:, 1 , 6 ] = 1.0 quaternions , _ = ringnet . apply ( X_ring , lam = lam ) quaternions . shape # quaternions[:, 0] # inclination: orientation from femur to earth # quaternioins[:, 1] # orientation from tibia to femur (2000, 2, 4) ts = np . arange ( 0 , 20.0 , step = sys . dt ) plt . plot ( ts , ring . maths . quat_angle_constantAxisOverTime ( quaternions [:, 1 ]), label = \"knee angle prediction\" ) plt . plot ( ts , - qs , label = \"knee angle truth\" ) plt . grid () plt . legend () plt . xlabel ( \"Time [s]\" ) plt . ylabel ( \"Knee Angle [rad]\" ) Text(0, 0.5, 'Knee Angle [rad]')","title":"Knee angle tracking"},{"location":"notebooks/knee_joint_translational_dof/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install --quiet 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'\" ) os . system ( \"pip install --quiet mediapy\" ) os . system ( \"pip install --quiet matplotlib\" ) os . system ( \"pip install --quiet dm-haiku\" ) import x_xy # automatically detects colab or not x_xy . utils . setup_colab_env () import jax import jax.numpy as jnp import haiku as hk import mediapy as media import tree_utils Registering a Knee Joint Type \u00a4 MAX_TRANSLATION = 0.1 ROM_MIN_RAD = 0.0 ROM_MAX_RAD = jnp . pi def build_mlp_knee ( key : jax . random . PRNGKey = jax . random . PRNGKey ( 1 )): @hk . without_apply_rng @hk . transform def mlp ( x ): net = hk . nets . MLP ([ 10 , 10 , 2 ], activation = jnp . tanh , w_init = hk . initializers . RandomNormal ()) # normalize the x input; [0, 1] x = ( x + ROM_MIN_RAD ) / ( ROM_MAX_RAD - ROM_MIN_RAD ) # center the x input; [-0.5, 0.5] x = ( x - 0.5 ) return net ( x ) example_q = jnp . zeros (( 1 ,)) params = mlp . init ( key , example_q ) def forward ( params , q : jax . Array ): return jax . nn . sigmoid ( mlp . apply ( params , q )) * MAX_TRANSLATION return params , forward def _knee_init_joint_params ( key ): return build_mlp_knee ( key )[ 0 ] def transform_fn_knee ( q : jax . Array , params : jax . Array ) -& gt ; x_xy . Transform : forward = build_mlp_knee ()[ 1 ] pos = jnp . concatenate (( forward ( params , q ), jnp . array ([ 0.0 ]))) axis = jnp . array ([ 0 , 0 , 1.0 ]) rot = x_xy . maths . quat_rot_axis ( axis , jnp . squeeze ( q )) return x_xy . Transform ( pos , rot ) def draw_fn_knee ( config : x_xy . MotionConfig , key_t , key_value , dt , params ): qs = x_xy . algorithms . jcalc . _draw_rxyz ( config , key_t , key_value , dt , params ) # rom constraints return ( qs / ( 2 * jnp . pi ) + 0.5 ) * ( ROM_MAX_RAD - ROM_MIN_RAD ) + ROM_MIN_RAD x_xy . register_new_joint_type ( \"knee\" , x_xy . JointModel ( transform_fn_knee , rcmg_draw_fn = draw_fn_knee , init_joint_params = _knee_init_joint_params ), 1 , 0 ) HIP_REVOLUTE_JOINT = True xml_str = f \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <geom dim=\"0.15\" type=\"xyz\"></geom> <body euler=\"90 90 0\" joint=\"py\" name=\"_femur\" pos=\"0.5 0.5 0.8\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <body \"frozen\" } \"=\"\" else=\"\" hip_revolute_joint=\"\" if=\"\" joint=\" { \" name=\" femur \" rz\" = \"\" > < geom dim = \"0.1\" type = \"xyz\" ></ geom > < geom dim = \"0.05 0.4\" euler = \"0 90 0\" mass = \"10\" pos = \"0.2 0 0\" type = \"capsule\" ></ geom > < body joint = \"frozen\" name = \"imu1\" pos = \"0.2 0 0.06\" > < geom dim = \"0.05\" type = \"xyz\" ></ geom > < geom color = \"orange\" dim = \"0.05 0.05 0.02\" mass = \"0\" type = \"box\" ></ geom > </ body > < body joint = \"knee\" name = \"tibia\" pos = \"0.4 0 0\" > < geom dim = \"0.1\" type = \"xyz\" ></ geom > < geom dim = \"0.04 0.4\" euler = \"0 90 0\" mass = \"10\" pos = \"0.2 0 0\" type = \"capsule\" ></ geom > < body joint = \"frozen\" name = \"imu2\" pos = \"0.2 0 0.06\" > < geom dim = \"0.05\" type = \"xyz\" ></ geom > < geom color = \"orange\" dim = \"0.05 0.05 0.02\" mass = \"0\" type = \"box\" ></ geom > </ body > < geom dim = \"0.025 0.2 0.05\" mass = \"5.0\" pos = \"0.45 -.1 0\" type = \"box\" ></ geom > </ body > </ body > </ body > </ worldbody > </ x_xy > \"\"\" sys = x_xy.load_sys_from_str(xml_str) def finalize_fn ( key , qs , xs : x_xy . Transform , sys : x_xy . System ): X = {} for imu in [ \"imu1\" , \"imu2\" ]: xs_imu = xs . take ( sys . name_to_idx ( imu ), axis = 1 ) X [ imu ] = {} X [ imu ][ \"pos\" ] = xs_imu . pos X [ imu ][ \"quat\" ] = xs_imu . rot X [ imu ][ \"imu\" ] = x_xy . imu ( xs_imu , sys . gravity , sys . dt ) params = tree_utils . tree_slice ( sys . links . joint_params [ \"knee\" ], sys . name_to_idx ( \"tibia\" )) return qs , xs , X , params data = x_xy . build_generator ( sys , x_xy . MotionConfig ( t_min = 0.1 , t_max = 0.75 , T = 30 ), finalize_fn = finalize_fn , randomize_joint_params = True , eager = True , aslist = True , seed = 1 , sizes = 32 ) eager data generation: 1it [00:07, 7.23s/it] idx = 5 qs , xs , X , params = data [ idx ] import matplotlib.pyplot as plt phi = jnp . linspace ( 0.0 , jnp . pi )[:, None ] # meter -&gt; centimeter trans_x , trans_y = jax . vmap ( lambda arr : build_mlp_knee ()[ 1 ]( params , arr ))( phi ) . T * 100 plt . scatter ( trans_x , trans_y , c = phi , cmap = \"coolwarm\" ) plt . colorbar () plt . grid () plt . xlabel ( \"x translation [cm]\" ) plt . ylabel ( \"y translation [cm]\" ) Text(0, 0.5, 'y translation [cm]') media . show_video ( x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"target\" , width = 1280 , height = 720 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [00:05<00:00, 133.26it/s] This browser does not support the video tag.","title":"Knee joint translational dof"},{"location":"notebooks/knee_joint_translational_dof/#registering-a-knee-joint-type","text":"MAX_TRANSLATION = 0.1 ROM_MIN_RAD = 0.0 ROM_MAX_RAD = jnp . pi def build_mlp_knee ( key : jax . random . PRNGKey = jax . random . PRNGKey ( 1 )): @hk . without_apply_rng @hk . transform def mlp ( x ): net = hk . nets . MLP ([ 10 , 10 , 2 ], activation = jnp . tanh , w_init = hk . initializers . RandomNormal ()) # normalize the x input; [0, 1] x = ( x + ROM_MIN_RAD ) / ( ROM_MAX_RAD - ROM_MIN_RAD ) # center the x input; [-0.5, 0.5] x = ( x - 0.5 ) return net ( x ) example_q = jnp . zeros (( 1 ,)) params = mlp . init ( key , example_q ) def forward ( params , q : jax . Array ): return jax . nn . sigmoid ( mlp . apply ( params , q )) * MAX_TRANSLATION return params , forward def _knee_init_joint_params ( key ): return build_mlp_knee ( key )[ 0 ] def transform_fn_knee ( q : jax . Array , params : jax . Array ) -& gt ; x_xy . Transform : forward = build_mlp_knee ()[ 1 ] pos = jnp . concatenate (( forward ( params , q ), jnp . array ([ 0.0 ]))) axis = jnp . array ([ 0 , 0 , 1.0 ]) rot = x_xy . maths . quat_rot_axis ( axis , jnp . squeeze ( q )) return x_xy . Transform ( pos , rot ) def draw_fn_knee ( config : x_xy . MotionConfig , key_t , key_value , dt , params ): qs = x_xy . algorithms . jcalc . _draw_rxyz ( config , key_t , key_value , dt , params ) # rom constraints return ( qs / ( 2 * jnp . pi ) + 0.5 ) * ( ROM_MAX_RAD - ROM_MIN_RAD ) + ROM_MIN_RAD x_xy . register_new_joint_type ( \"knee\" , x_xy . JointModel ( transform_fn_knee , rcmg_draw_fn = draw_fn_knee , init_joint_params = _knee_init_joint_params ), 1 , 0 ) HIP_REVOLUTE_JOINT = True xml_str = f \"\"\" <x_xy> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <geom dim=\"0.15\" type=\"xyz\"></geom> <body euler=\"90 90 0\" joint=\"py\" name=\"_femur\" pos=\"0.5 0.5 0.8\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <body \"frozen\" } \"=\"\" else=\"\" hip_revolute_joint=\"\" if=\"\" joint=\" { \" name=\" femur \" rz\" = \"\" > < geom dim = \"0.1\" type = \"xyz\" ></ geom > < geom dim = \"0.05 0.4\" euler = \"0 90 0\" mass = \"10\" pos = \"0.2 0 0\" type = \"capsule\" ></ geom > < body joint = \"frozen\" name = \"imu1\" pos = \"0.2 0 0.06\" > < geom dim = \"0.05\" type = \"xyz\" ></ geom > < geom color = \"orange\" dim = \"0.05 0.05 0.02\" mass = \"0\" type = \"box\" ></ geom > </ body > < body joint = \"knee\" name = \"tibia\" pos = \"0.4 0 0\" > < geom dim = \"0.1\" type = \"xyz\" ></ geom > < geom dim = \"0.04 0.4\" euler = \"0 90 0\" mass = \"10\" pos = \"0.2 0 0\" type = \"capsule\" ></ geom > < body joint = \"frozen\" name = \"imu2\" pos = \"0.2 0 0.06\" > < geom dim = \"0.05\" type = \"xyz\" ></ geom > < geom color = \"orange\" dim = \"0.05 0.05 0.02\" mass = \"0\" type = \"box\" ></ geom > </ body > < geom dim = \"0.025 0.2 0.05\" mass = \"5.0\" pos = \"0.45 -.1 0\" type = \"box\" ></ geom > </ body > </ body > </ body > </ worldbody > </ x_xy > \"\"\" sys = x_xy.load_sys_from_str(xml_str) def finalize_fn ( key , qs , xs : x_xy . Transform , sys : x_xy . System ): X = {} for imu in [ \"imu1\" , \"imu2\" ]: xs_imu = xs . take ( sys . name_to_idx ( imu ), axis = 1 ) X [ imu ] = {} X [ imu ][ \"pos\" ] = xs_imu . pos X [ imu ][ \"quat\" ] = xs_imu . rot X [ imu ][ \"imu\" ] = x_xy . imu ( xs_imu , sys . gravity , sys . dt ) params = tree_utils . tree_slice ( sys . links . joint_params [ \"knee\" ], sys . name_to_idx ( \"tibia\" )) return qs , xs , X , params data = x_xy . build_generator ( sys , x_xy . MotionConfig ( t_min = 0.1 , t_max = 0.75 , T = 30 ), finalize_fn = finalize_fn , randomize_joint_params = True , eager = True , aslist = True , seed = 1 , sizes = 32 ) eager data generation: 1it [00:07, 7.23s/it] idx = 5 qs , xs , X , params = data [ idx ] import matplotlib.pyplot as plt phi = jnp . linspace ( 0.0 , jnp . pi )[:, None ] # meter -&gt; centimeter trans_x , trans_y = jax . vmap ( lambda arr : build_mlp_knee ()[ 1 ]( params , arr ))( phi ) . T * 100 plt . scatter ( trans_x , trans_y , c = phi , cmap = \"coolwarm\" ) plt . colorbar () plt . grid () plt . xlabel ( \"x translation [cm]\" ) plt . ylabel ( \"y translation [cm]\" ) Text(0, 0.5, 'y translation [cm]') media . show_video ( x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"target\" , width = 1280 , height = 720 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [00:05<00:00, 133.26it/s] This browser does not support the video tag.","title":"Registering a Knee Joint Type"},{"location":"notebooks/machine_learning/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install --quiet 'ring @ git+https://github.com/SimiPixel/ring'\" ) import ring # automatically detects colab or not ring . utils . setup_colab_env () import mediapy import jax.numpy as jnp import tree_utils import ring from diodem import benchmark imtp = benchmark . IMTP ([ \"seg2\" , \"seg3\" , \"seg4\" ], sparse = True , joint_axes = True , dt = False ) exp_id = 1 motion = \"fast_slow_fast\" ringnet = ring . RING ( lam = [ - 1 , 0 , 1 ], Ts = 0.01 ) errors , X , y , yhat , xs , xs_noimu = benchmark . benchmark ( imtp , exp_id , motion , ringnet , warmup = 5.0 ) sys = imtp . sys ( exp_id ) frames = sys . render_prediction ( xs , yhat , render_every_nth = 4 , transparent_segment_to_root = False , width = 640 , height = 480 , camera = \"c\" , add_cameras = { - 1 : '<camera mode=\"targetbody\" name=\"c\" pos=\".5 -.5 1.25\" target=\"3\"></camera>' ,}) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 875/875 [00:09<00:00, 93.81it/s] errors {'seg2': {'mae': 2.7917402, 'std': 1.5290443}, 'seg3': {'mae': 6.0479784, 'std': 3.081823}, 'seg4': {'mae': 5.7122917, 'std': 2.900498}} mediapy . show_video ( frames , fps = 25.0 ) This browser does not support the video tag.","title":"Machine learning"},{"location":"notebooks/magnetometer_modeling/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Magnetometer modeling \u00a4 from x_xy.subpkgs import exp import matplotlib.pyplot as plt import jax import x_xy import jax.numpy as jnp import numpy as np hz = 100 markerMap = { \"seg1\" : 2 , \"seg5\" : 2 , \"seg2\" : 1 , \"seg3\" : 2 , \"seg4\" : 4 } def load_data ( seg : str , t1 : float , t2 : float , motion : str = \"fast\" ): data = exp . load_data ( \"S_06\" , motion , resample_to_hz = hz )[ seg ] # extract a small window from long time series for plotting pos , rot , imu_data = jax . tree_map ( lambda arr : arr [ int ( t1 * hz ): int ( t2 * hz )], ( data [ f \"marker { markerMap [ seg ] } \" ], data [ \"quat\" ], data [ \"imu_rigid\" ])) rot = x_xy . maths . quat_inv ( rot ) # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation xs = x_xy . Transform . create ( pos , rot ) return pos , rot , xs , imu_data t1 , t2 = 3.0 , 9.0 pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 ) Real-world Magnetic-field \u00a4 def plot ( * mag_data ): mag_data = jax . tree_map ( lambda arr : arr [: - 100 ], mag_data ) _ , axes = plt . subplots ( 1 , len ( mag_data ), figsize = ( len ( mag_data ) * 6 , 4 )) axes = [ axes ] if not isinstance ( axes , np . ndarray ) else axes ts = jnp . arange ( t1 , t2 - 1.0 , step = 1 / hz ) for i , mag in enumerate ( mag_data ): axes [ i ] . plot ( ts , mag , label = [ \"x\" , \"y\" , \"z\" ]) axes [ i ] . grid () axes [ i ] . set_xlabel ( \"time [s]\" ) axes [ 0 ] . legend () plot ( imu_data [ \"mag\" ]) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , jax . random . PRNGKey ( 1 ), has_magnetometer = True , low_pass_filter_rot_alpha = 0.5 ) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ]) Optimize Magnetic Field Vector \u00a4 from scipy.optimize import minimize def optimize_parameters ( seg : str , motion : str ): t1 , t2 = 0.0 , 500.0 pos , rot , xs , imu_data = load_data ( seg , t1 , t2 , motion ) @jax . jit def objective ( params ): magvec = params #alpha = np.clip(alpha, 0.0, 1.0) imu_sim = x_xy . imu ( xs , jnp . zeros (( 3 ,)), 1 / hz , low_pass_filter_rot_alpha = 0.5 , magvec = magvec , has_magnetometer = True ) return jnp . mean (( imu_data [ \"mag\" ] - imu_sim [ \"mag\" ]) ** 2 ) res = minimize ( objective , jnp . array ([ 0.0 , .7 , - .7 ]), method = \"Nelder-Mead\" ) perfect = np . array ([ 0 , res . x [ 1 ], res . x [ 2 ]]) perfect /= np . linalg . norm ( perfect ) dip_angle = np . arctan2 ( perfect [ 1 ], perfect [ 2 ]) return res . x , np . linalg . norm ( res . x ), np . rad2deg ( dip_angle ) - 90 for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"slow1\" )) (array([-0.05669107, 0.13636727, -0.56856133]), 0.5874282070698279, 76.5125997928424) (array([ 0.02870585, 0.14479726, -0.5529681 ]), 0.5723320607239446, 75.32629421386511) (array([ 0.07342922, 0.27993262, -0.6070893 ]), 0.6725411131056166, 65.24528171284635) (array([ 0.06965261, 0.12674702, -0.66338645]), 0.6789682416674281, 79.18339336223758) (array([-0.02896293, 0.24820061, -0.55680701]), 0.6103084782009606, 65.9747430877396) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"fast\" )) (array([-0.08539633, 0.15602869, -0.49032469]), 0.5215896749593268, 72.34814710540633) (array([ 0.05422703, 0.13053918, -0.2375643 ]), 0.27643777497021754, 61.211650723518005) (array([ 0.17069941, 0.16292433, -0.49904502]), 0.5520222414783663, 71.9195779531855) (array([ 0.03610723, 0.06886188, -0.5142856 ]), 0.5201301476029805, 82.37356382782355) (array([-0.13417971, 0.32559843, -0.40739543]), 0.5385067931956347, 51.36746475752713) Test optimized magnetic field vector pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 , \"fast\" ) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , has_magnetometer = True , low_pass_filter_rot_alpha = 0.56 , magvec = jnp . array ([ - 0.08957149 , 0.17059967 , - 0.59387128 ])) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ]) pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 , \"slow1\" ) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , has_magnetometer = True , low_pass_filter_rot_alpha = 0.5 , magvec = jnp . array ([ - 0.05896413 , 0.14859727 , - 0.6037423 ]), noisy = True , key = jax . random . PRNGKey ( 7 )) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ])","title":"Magnetometer modeling"},{"location":"notebooks/magnetometer_modeling/#magnetometer-modeling","text":"from x_xy.subpkgs import exp import matplotlib.pyplot as plt import jax import x_xy import jax.numpy as jnp import numpy as np hz = 100 markerMap = { \"seg1\" : 2 , \"seg5\" : 2 , \"seg2\" : 1 , \"seg3\" : 2 , \"seg4\" : 4 } def load_data ( seg : str , t1 : float , t2 : float , motion : str = \"fast\" ): data = exp . load_data ( \"S_06\" , motion , resample_to_hz = hz )[ seg ] # extract a small window from long time series for plotting pos , rot , imu_data = jax . tree_map ( lambda arr : arr [ int ( t1 * hz ): int ( t2 * hz )], ( data [ f \"marker { markerMap [ seg ] } \" ], data [ \"quat\" ], data [ \"imu_rigid\" ])) rot = x_xy . maths . quat_inv ( rot ) # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation xs = x_xy . Transform . create ( pos , rot ) return pos , rot , xs , imu_data t1 , t2 = 3.0 , 9.0 pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 )","title":"Magnetometer modeling"},{"location":"notebooks/magnetometer_modeling/#real-world-magnetic-field","text":"def plot ( * mag_data ): mag_data = jax . tree_map ( lambda arr : arr [: - 100 ], mag_data ) _ , axes = plt . subplots ( 1 , len ( mag_data ), figsize = ( len ( mag_data ) * 6 , 4 )) axes = [ axes ] if not isinstance ( axes , np . ndarray ) else axes ts = jnp . arange ( t1 , t2 - 1.0 , step = 1 / hz ) for i , mag in enumerate ( mag_data ): axes [ i ] . plot ( ts , mag , label = [ \"x\" , \"y\" , \"z\" ]) axes [ i ] . grid () axes [ i ] . set_xlabel ( \"time [s]\" ) axes [ 0 ] . legend () plot ( imu_data [ \"mag\" ]) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , jax . random . PRNGKey ( 1 ), has_magnetometer = True , low_pass_filter_rot_alpha = 0.5 ) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ])","title":"Real-world Magnetic-field"},{"location":"notebooks/magnetometer_modeling/#optimize-magnetic-field-vector","text":"from scipy.optimize import minimize def optimize_parameters ( seg : str , motion : str ): t1 , t2 = 0.0 , 500.0 pos , rot , xs , imu_data = load_data ( seg , t1 , t2 , motion ) @jax . jit def objective ( params ): magvec = params #alpha = np.clip(alpha, 0.0, 1.0) imu_sim = x_xy . imu ( xs , jnp . zeros (( 3 ,)), 1 / hz , low_pass_filter_rot_alpha = 0.5 , magvec = magvec , has_magnetometer = True ) return jnp . mean (( imu_data [ \"mag\" ] - imu_sim [ \"mag\" ]) ** 2 ) res = minimize ( objective , jnp . array ([ 0.0 , .7 , - .7 ]), method = \"Nelder-Mead\" ) perfect = np . array ([ 0 , res . x [ 1 ], res . x [ 2 ]]) perfect /= np . linalg . norm ( perfect ) dip_angle = np . arctan2 ( perfect [ 1 ], perfect [ 2 ]) return res . x , np . linalg . norm ( res . x ), np . rad2deg ( dip_angle ) - 90 for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"slow1\" )) (array([-0.05669107, 0.13636727, -0.56856133]), 0.5874282070698279, 76.5125997928424) (array([ 0.02870585, 0.14479726, -0.5529681 ]), 0.5723320607239446, 75.32629421386511) (array([ 0.07342922, 0.27993262, -0.6070893 ]), 0.6725411131056166, 65.24528171284635) (array([ 0.06965261, 0.12674702, -0.66338645]), 0.6789682416674281, 79.18339336223758) (array([-0.02896293, 0.24820061, -0.55680701]), 0.6103084782009606, 65.9747430877396) for seg in [ \"seg1\" , \"seg2\" , \"seg3\" , \"seg4\" , \"seg5\" ]: print ( optimize_parameters ( seg , \"fast\" )) (array([-0.08539633, 0.15602869, -0.49032469]), 0.5215896749593268, 72.34814710540633) (array([ 0.05422703, 0.13053918, -0.2375643 ]), 0.27643777497021754, 61.211650723518005) (array([ 0.17069941, 0.16292433, -0.49904502]), 0.5520222414783663, 71.9195779531855) (array([ 0.03610723, 0.06886188, -0.5142856 ]), 0.5201301476029805, 82.37356382782355) (array([-0.13417971, 0.32559843, -0.40739543]), 0.5385067931956347, 51.36746475752713) Test optimized magnetic field vector pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 , \"fast\" ) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , has_magnetometer = True , low_pass_filter_rot_alpha = 0.56 , magvec = jnp . array ([ - 0.08957149 , 0.17059967 , - 0.59387128 ])) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ]) pos , rot , xs , imu_data = load_data ( \"seg1\" , t1 , t2 , \"slow1\" ) imu_data_sim = x_xy . imu ( xs , jnp . array ([ 0 , 0 , 9.81 ]), 1 / hz , has_magnetometer = True , low_pass_filter_rot_alpha = 0.5 , magvec = jnp . array ([ - 0.05896413 , 0.14859727 , - 0.6037423 ]), noisy = True , key = jax . random . PRNGKey ( 7 )) plot ( imu_data [ \"mag\" ], imu_data_sim [ \"mag\" ])","title":"Optimize Magnetic Field Vector"},{"location":"notebooks/morph_system/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Different Anchors (explains sys_composer.morph_system) \u00a4 import x_xy import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media def show_video ( sys , xs : x_xy . Transform ) -& gt ; None : assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"targetfar\" , height = 480 , width = 640 ) # convert rgba to rgb frames = [ frame [ ... , : 3 ] for frame in frames ] media . show_video ( frames , fps = 25 ) In this system the middle segment seg2 acts as \"anchor\". xml_str = \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 1\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . load_sys_from_str ( xml_str ) gen = x_xy . build_generator ( sys , x_xy . MotionConfig ( T = 10.0 , t_max = 1.5 , dang_max_free_spherical = 0.1 , dpos_max = 0.1 ), _compat = True ) _ , xs = gen ( jax . random . PRNGKey ( 1 )) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01<00:00, 162.68it/s] This browser does not support the video tag. Can you see what i mean? The middle segment has all the \"global rotation and translation\". Let's move the anchor to seg1 but without changing the xml syntax. This can be done with the subpackage sys_composer . from x_xy.subpkgs import sys_composer # the new parents of seg2, seg1, imu1, seg3, imu2 are ... new_parents = [ \"seg1\" , - 1 , \"seg1\" , \"seg2\" , \"seg3\" ] sys = sys_composer . morph_system ( sys , new_parents = new_parents ) gen = x_xy . build_generator ( sys , x_xy . MotionConfig ( T = 10.0 , t_max = 1.5 , dang_max_free_spherical = 0.1 , dpos_max = 0.1 ), _compat = True ) _ , xs = gen ( jax . random . PRNGKey ( 1 )) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01<00:00, 147.05it/s] This browser does not support the video tag. Pretty cool, ha? :)","title":"Morph system"},{"location":"notebooks/morph_system/#different-anchors-explains-sys_composermorph_system","text":"import x_xy import jax import jax.numpy as jnp import numpy as np import matplotlib.pyplot as plt import mediapy as media def show_video ( sys , xs : x_xy . Transform ) -& gt ; None : assert sys . dt == 0.01 # only render every fourth to get a framerate of 25 fps frames = x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"targetfar\" , height = 480 , width = 640 ) # convert rgba to rgb frames = [ frame [ ... , : 3 ] for frame in frames ] media . show_video ( frames , fps = 25 ) In this system the middle segment seg2 acts as \"anchor\". xml_str = \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 1\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom color=\"self\" dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"orange\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . load_sys_from_str ( xml_str ) gen = x_xy . build_generator ( sys , x_xy . MotionConfig ( T = 10.0 , t_max = 1.5 , dang_max_free_spherical = 0.1 , dpos_max = 0.1 ), _compat = True ) _ , xs = gen ( jax . random . PRNGKey ( 1 )) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01<00:00, 162.68it/s] This browser does not support the video tag. Can you see what i mean? The middle segment has all the \"global rotation and translation\". Let's move the anchor to seg1 but without changing the xml syntax. This can be done with the subpackage sys_composer . from x_xy.subpkgs import sys_composer # the new parents of seg2, seg1, imu1, seg3, imu2 are ... new_parents = [ \"seg1\" , - 1 , \"seg1\" , \"seg2\" , \"seg3\" ] sys = sys_composer . morph_system ( sys , new_parents = new_parents ) gen = x_xy . build_generator ( sys , x_xy . MotionConfig ( T = 10.0 , t_max = 1.5 , dang_max_free_spherical = 0.1 , dpos_max = 0.1 ), _compat = True ) _ , xs = gen ( jax . random . PRNGKey ( 1 )) show_video ( sys , xs ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01<00:00, 147.05it/s] This browser does not support the video tag. Pretty cool, ha? :)","title":"Different Anchors (explains sys_composer.morph_system)"},{"location":"notebooks/motion_artifact_rejection/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); This example is available as a jupyter notebook here . And on Google Colab here Setup the environment if this is executed on Google Colab. Make sure to change the runtime type to GPU . To do this go to Runtime -> Change runtime type -> GPU Otherwise, rendering won't work in Google Colab. import os try : import google.colab IN_COLAB = True except : IN_COLAB = False if IN_COLAB : os . system ( \"pip install --quiet 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'\" ) os . system ( \"pip install --quiet mediapy\" ) import x_xy # automatically detects colab or not x_xy . utils . setup_colab_env () import jax import jax.numpy as jnp import mediapy as media def show_video ( sys , xs , ** kwargs ): media . show_video ( x_xy . render ( sys , [ xs [ i ] for i in range ( 0 , xs . shape (), 4 )], camera = \"target\" , width = 640 , height = 480 , ** kwargs ), fps = 25 ) knee_xml_str = \"\"\" <x_xy model=\"knee_flexible_imus\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body damping=\"5 5 5 25 25 25\" joint=\"free\" name=\"femur\" pos=\"0.5 0.5 0.3\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.05 0.4\" euler=\"0 90 0\" mass=\"1\" pos=\"0.2 0 0\" type=\"capsule\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"0.2 0 0.05\" pos_max=\"0.35 0 0\" pos_min=\"0.05 0 0\"> <geom dim=\"0.05\" type=\"xyz\"></geom> <geom color=\"orange\" dim=\"0.05 0.05 0.02\" mass=\"0.1\" type=\"box\"></geom> </body> <body damping=\"3\" joint=\"ry\" name=\"tibia\" pos=\"0.4 0 0\"> <geom dim=\"0.1\" type=\"xyz\"></geom> <geom dim=\"0.04 0.4\" euler=\"0 90 0\" mass=\"1\" pos=\"0.2 0 0\" type=\"capsule\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.2 0 0.05\" pos_max=\"0.35 0 0\" pos_min=\"0.05 0 0\"> <geom dim=\"0.05\" type=\"xyz\"></geom> <geom color=\"orange\" dim=\"0.05 0.05 0.02\" mass=\"0.1\" type=\"box\"></geom> </body> <geom dim=\"0.025 0.05 0.2\" mass=\"0\" pos=\"0.45 0 .1\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . load_sys_from_str ( knee_xml_str ) media . show_image ( x_xy . render ( sys , camera = \"target\" , height = 480 , width = 640 )[ 0 ]) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00, 14.47it/s] T = 20.0 T_initial_nomotion = 2.0 config = x_xy . MotionConfig ( t_min = 0.1 , t_max = 0.75 , T = T , ang0_min = 0.0 , ang0_max = 0.0 , pos_min =- 1.0 , pos_max = 1.0 , dpos_max = 0.5 ) config = x_xy . join_motionconfigs ([ config . to_nomotion_config (), config ], [ T_initial_nomotion ]) ( X , y ), ( _ , qs , xs , sys_mod ) = x_xy . build_generator ( sys , config , imu_motion_artifacts = True , dynamic_simulation = True , eager = True , aslist = True , seed = 1 , sizes = 1 , keep_output_extras = True , imu_motion_artifacts_kwargs = dict ( hide_injected_bodies = False ))[ 0 ] /Users/simon/Documents/PYTHON/x_xy_v2/x_xy/algorithms/generator/motion_artifacts.py:80: UserWarning: `sys.links.joint_params` has been set to zero, this might lead to unexpected behaviour unless you use `randomize_joint_params` warnings.warn( /Users/simon/Documents/PYTHON/x_xy_v2/x_xy/algorithms/generator/base.py:184: UserWarning: `imu_motion_artifacts` is enabled but not `randomize_motion_artifacts` warnings.warn( eager data generation: 1it [00:28, 28.97s/it] show_video ( sys_mod , xs , show_floor = False ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:01<00:00, 315.52it/s] This browser does not support the video tag. sys_frozen = sys_mod . freeze ( \"tibia\" ) . freeze ( \"femur\" ) def freeze_x ( q_obs ): q_frozen = jnp . concatenate ( tuple ( q_obs [:, sys_mod . idx_map ( \"q\" )[ name ]] for name in [ \"_imu1\" , \"imu1\" , \"_imu2\" , \"imu2\" ]), axis =- 1 ) return jax . vmap ( lambda q : x_xy . algorithms . forward_kinematics_transforms ( sys_frozen , q )[ 0 ])( q_frozen ) show_video ( sys_frozen , freeze_x ( qs )) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:02<00:00, 172.52it/s] This browser does not support the video tag.","title":"Motion artifact rejection"},{"location":"notebooks/visualisation/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Note This example is available as a jupyter notebook here . import ring import mediapy as media import jax from diodem import load_data sys_str = \"\"\" <x_xy> <worldbody> <geom dim=\"0.1\" type=\"xyz\"></geom> <body joint=\"free\" name=\"seg\" pos=\"0 0 .5\"> <geom color=\"dustin_exp_blue\" dim=\"0.15 0.075 0.05\" mass=\"0.2\" pos=\"0.03 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu\" pos=\"0.0 0.0 0.03\"> <geom color=\"dustin_exp_orange\" dim=\"0.05 0.03 0.02\" mass=\"0.1\" type=\"box\"></geom> </body> </body> </worldbody> </x_xy> \"\"\" sys = ring . System . create ( sys_str ) ( X , y ), ( key , q , x , _ ) = ring . RCMG ( sys , keep_output_extras = True ) . to_list ()[ 0 ] executing generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:04<00:00, 4.35s/it] media . show_video ( sys . render ( x , width = 640 , height = 480 , camera = \"target\" , render_every_nth = 4 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1500/1500 [00:14<00:00, 102.87it/s] This browser does not support the video tag. exp_data = load_data ( exp_id = 1 , motion_start = \"fast\" ) exp_data . keys () dict_keys(['seg1', 'seg2', 'seg3', 'seg4', 'seg5']) exp_data [ \"seg1\" ] . keys () dict_keys(['imu_nonrigid', 'imu_rigid', 'marker1', 'marker2', 'marker3', 'marker4', 'quat']) segment = \"seg2\" omc_data_sys = { \"seg\" : { \"pos\" : exp_data [ segment ][ \"marker1\" ], \"quat\" : exp_data [ segment ][ \"quat\" ], }, \"imu\" : { \"quat\" : exp_data [ segment ][ \"quat\" ], } } omc_data_sys {'seg': {'pos': array([[-0.00217298, 1.31229643, -0.06881995], [-0.00217508, 1.31225208, -0.06880918], [-0.00217637, 1.31223445, -0.06880335], ..., [-0.07191098, 1.33661952, -0.07041251], [-0.07191038, 1.33658217, -0.07042007], [-0.07190987, 1.3365283 , -0.07043372]]), 'quat': array([[ 0.95854069, 0.11865217, -0.03095211, -0.25722244], [ 0.95854969, 0.11859988, -0.03091764, -0.25721714], [ 0.95855869, 0.11854759, -0.03088317, -0.25721185], ..., [ 0.95514079, 0.11290525, -0.03582784, -0.27143111], [ 0.95514079, 0.11290525, -0.03582784, -0.27143111], [ 0.95514079, 0.11290525, -0.03582784, -0.27143111]])}, 'imu': {'quat': array([[ 0.95854069, 0.11865217, -0.03095211, -0.25722244], [ 0.95854969, 0.11859988, -0.03091764, -0.25721714], [ 0.95855869, 0.11854759, -0.03088317, -0.25721185], ..., [ 0.95514079, 0.11290525, -0.03582784, -0.27143111], [ 0.95514079, 0.11290525, -0.03582784, -0.27143111], [ 0.95514079, 0.11290525, -0.03582784, -0.27143111]])}} x = ring . sim2real . xs_from_raw ( sys , omc_data_sys ) # vectorize this function over time @jax . vmap def update_position_vector_of_imu ( x ): state = ring . State . create ( sys , x = x ) # populate minimal coordinates `state.q` from maximal coordinates `state.x` state = ring . algorithms . inverse_kinematics ( sys , state ) # re-calculate maximal coordiantes `state.x` from minimal coordinates `state.q` # this uses the position vector specified in the system (and so the xml file) # to produce an offset between IMu and segment geom box _ , state = ring . algorithms . forward_kinematics ( sys , state ) return state . x x = update_position_vector_of_imu ( x ) media . show_video ( sys . render ( x , width = 640 , height = 480 , camera = \"target\" , render_every_nth = 4 ), fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1075/1075 [00:09<00:00, 113.41it/s] This browser does not support the video tag.","title":"Visualisation"},{"location":"prism/ss_23_marcel_thomas/notebook/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Training the RNNO with rigid phases (PRISM SS2023) \u00a4 In this notebook, we define a custom hinge joint, which is configured to generate pauses (no movement) inside the generated data series. We use this joint to train the RNNO and perfrom inference with the generated parameters. import x_xy import jax import jax.numpy as jnp import jax.random as random from x_xy.subpkgs.ml import rnno , callbacks , train , load from x_xy.subpkgs import sim2real , sys_composer import tree_utils import matplotlib.pyplot as plt import mediapy as media Defining the System \u00a4 A system is defined in an XML structure. To read a system, an XML file may be used. It is also possible to define the system inline by using a string in XML-syntax. In the following, we define two three-segment chains: three_seg_rigid = r \"\"\" <x_xy model=\"three_seg_rigid\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\"> <geom color=\"red\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"rsry\" name=\"seg1\" pos=\"0 0 0\"> <geom color=\"yellow\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"-0.1 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.1 0.0 0.03\"> <geom color=\"green\" dim=\"0.05 0.01 0.01\" mass=\"2\" pos=\"0 0 0\" type=\"box\"></geom> </body> </body> <body joint=\"rsrz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom color=\"blue\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.1 0.0 0.03\"> <geom color=\"green\" dim=\"0.05 0.01 0.01\" mass=\"2\" pos=\"0 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> <defaults> <geom color=\"1 0.8 0.7 1\" edge_color=\"black\"></geom> </defaults> </x_xy> \"\"\" dustin_exp_xml_seg1 = r \"\"\" <x_xy model=\"dustin_exp\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg1\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"-0.1 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg2\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"rz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" Registering the joint axis \u00a4 For this scenario, we define two systems: One for generating data with rigid phases and one for inference. To generate the random data with rigid phases, we first have to register a joint type, that allows for the creation of such data. We call this joint 'rsr\\<x|y|z>', a hinge joint that produces r andom s ometimes r igid data, and turns around the respective axis \\(x\\) , \\(y\\) or \\(z\\) in its frame. </x|y|z> Generating random data \u00a4 The random data is generated by the following functions: # Helper function - Creates an array of values x &lt;- [0, 1] which may be multiplied to another sequence. def motion_amplifier ( time : float , sampling_rate : float , key_rigid_phases : jax . Array , n_rigid_phases = 3 , rigid_duration_cov = jnp . array ([ 0.02 ] * 3 ), transition_cov = jnp . array ([ 0.1 ] * 3 ) ) -& gt ; jax . Array : error_msg = \"motion_amplifier: There must be a variance for each rigid phase!\" assert rigid_duration_cov . shape == ( n_rigid_phases ,) == transition_cov . shape , error_msg n_frames = int ( time / sampling_rate ) key_rigid_means , key_rigid_variances , key_slope_down_variances , key_slope_up_variances = random . split ( key_rigid_phases , 4 ) # Calculate center points of rigid phases means = jnp . sort ( random . uniform ( key_rigid_means , shape = ( n_rigid_phases , 1 ), minval = 0 , maxval = n_frames ) . T ) # Calculate durations, which is twice the rigid distance from the center points for each rigid phase. rigid_distances = jnp . abs ( random . multivariate_normal ( key_rigid_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( rigid_duration_cov * n_frames ) ** 2 ))) # Calculate transition durations transition_slowdown_durations = jnp . abs ( random . multivariate_normal ( key_slope_down_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( transition_cov * n_frames ) ** 2 ) )) transition_speedup_durations = jnp . abs ( random . multivariate_normal ( key_slope_up_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( transition_cov * n_frames ) ** 2 ) )) # Phase start and end points rigid_starts = ( means - rigid_distances ) . astype ( int ) . flatten () rigid_ends = ( means + rigid_distances ) . astype ( int ) . flatten () starts_slowing = ( means - rigid_distances - transition_slowdown_durations ) . astype ( int ) . flatten () ends_moving = ( means + rigid_distances + transition_speedup_durations ) . astype ( int ) . flatten () # Create masks def create_mask ( start , end ): nonlocal n_frames return jnp . where ( jnp . arange ( n_frames ) & lt ; start , 1 , 0 ) + jnp . where ( jnp . arange ( n_frames ) & gt ; = end , 1 , 0 ) mask = jax . vmap ( create_mask ) rigid_mask = jnp . prod ( mask ( rigid_starts , rigid_ends ), axis = 0 ) slowdown_masks = mask ( starts_slowing , rigid_starts ) . astype ( float ) speedup_masks = mask ( rigid_ends , ends_moving ) . astype ( float ) # We have to define an inline function in order to make this code JIT-able def linsp ( mask , start , end , begin_val , carry_fun ): range = end - start def true_fun ( carry , x ): return ( carry_fun ( carry , range ), 1 - carry ) def false_fun ( carry , x ): return ( carry , x ) def f ( carry , x ): return jax . lax . cond ( x == 0 , true_fun , false_fun , * ( carry , x )) return jax . lax . scan ( f , begin_val , mask )[ 1 ] linsp_desc = jax . vmap ( lambda m , s1 , s2 : linsp ( m , s1 , s2 , 0.0 , lambda carry , range : carry + 1 / range )) slowdown_mask = jnp . prod ( linsp_desc ( slowdown_masks , starts_slowing , rigid_starts ), axis = 0 ) linsp_asc = jax . vmap ( lambda m , s1 , s2 : linsp ( m , s1 , s2 , 1.0 , lambda carry , range : carry - 1 / range )) speedup_mask = jnp . prod ( linsp_asc ( speedup_masks , rigid_ends , ends_moving ), axis = 0 ) return jnp . min ( jnp . stack ([ rigid_mask , slowdown_mask , speedup_mask ]), axis = 0 ) # Random generator: Uses the motion_amplifier to dampen/null the randomly generated angles. def random_angles_with_rigid_phases_over_time ( key_t , key_ang , dt , key_rigid_phases , n_rigid_phases = 3 , rigid_duration_cov = jnp . array ([ 0.02 ] * 3 ), transition_cov = jnp . array ([ 0.1 ] * 3 ), config : x_xy . algorithms . MotionConfig = x_xy . algorithms . MotionConfig () ) -& gt ; jax . Array : mask = motion_amplifier ( config . T , dt , key_rigid_phases , n_rigid_phases , rigid_duration_cov , transition_cov ) qs = x_xy . algorithms . random_angle_over_time ( key_t = key_t , key_ang = key_ang , ANG_0 = config . ang0_max , dang_min = config . dang_min , dang_max = config . dang_max , delta_ang_min = config . delta_ang_min , delta_ang_max = config . delta_ang_max , t_min = config . t_min , t_max = config . t_max , T = config . T , Ts = dt , randomized_interpolation = config . randomized_interpolation_angle , range_of_motion = config . range_of_motion_hinge , range_of_motion_method = config . range_of_motion_hinge_method ) # derivate qs qs_diff = jnp . diff ( qs , axis = 0 ) # mulitply with motion amplifier qs_diff = qs_diff * mask [: - 1 ] # integrate qs_diff qs_rigid_phases = jnp . concatenate (( qs [ 0 : 1 ], jnp . cumsum ( qs_diff , axis = 0 ))) return qs_rigid_phases Defining the random joint function \u00a4 First of all, we have to define our problem. This means, parameterzing the random function. Two possible scenarios are implemented below: \"BEST_RUN\" and \"MANY_TINY_STOPS\", both of which achieved adequate results. The problems are defined as \\(P=(N, \\mathbf{\\sigma}_{r}, \\mathbf{\\sigma}_{tr})\\) , with \\(N\\) being the number of rigid phases, \\(\\mathbf{\\sigma}_r\\) the covariance used for calculating the length of each rigid phase and \\(\\mathbf{\\sigma}_{tr}\\) for the length of each transition phase respectively. It also holds that \\(\\mathbf{\\sigma}_r, \\mathbf{\\sigma}_{tr} \\in \\mathbb{R}^N\\) , with each entry being the variance for exactly one rigid phase. BEST_RUN = ( 1 , jnp . array ([ 0.02 ]), jnp . array ([ 0.1 ])) MANY_TINY_STOPS = ( 30 , jnp . array ([ 0.001 ] * 30 ), jnp . array ([ 0.0001 ] * 30 )) ################################################################################## # Define your own problem configuration here :) # PROBLEM = BEST_RUN # &lt;- Change this assignment to use it. ################################################################################## def define_joints (): def _draw_sometimes_rigid ( config : x_xy . algorithms . MotionConfig , key_t : jax . Array , key_value : jax . Array , dt : float , joint_params : jax . Array ) -& gt ; jax . Array : key_t , key_rigid_phases = jax . random . split ( key_t ) return random_angles_with_rigid_phases_over_time ( key_t = key_t , key_ang = key_value , dt = dt , key_rigid_phases = key_rigid_phases , n_rigid_phases = PROBLEM [ 0 ], rigid_duration_cov = PROBLEM [ 1 ], transition_cov = PROBLEM [ 2 ], config = config ) def _rxyz_transform ( q , _ , axis ): q = jnp . squeeze ( q ) rot = x_xy . maths . quat_rot_axis ( axis , q ) return x_xy . base . Transform . create ( rot = rot ) rsrx_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 1.0 , 0 , 0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) rsry_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 0 , 1.0 , 0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) rsrz_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 0 , 0 , 1.0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) try : x_xy . algorithms . register_new_joint_type ( \"rsrx\" , rsrx_joint , 1 ) x_xy . algorithms . register_new_joint_type ( \"rsry\" , rsry_joint , 1 ) x_xy . algorithms . register_new_joint_type ( \"rsrz\" , rsrz_joint , 1 ) except AssertionError : print ( \"Warning: Joints have already been registered!\" ) define_joints () Note: it is also possible to support multiple problems at the same time, by implementing them as seperate joint types, or by injecting the x_xy.algorithms.MotionConfig class e.g. by inheritance. After we defined the joint type, we can load the system: sys_rigid = x_xy . io . load_sys_from_str ( three_seg_rigid ) sys_inference = x_xy . io . load_sys_from_str ( dustin_exp_xml_seg1 ) Generating raw data \u00a4 For both training and inference, we first need a set of raw data. In our example, sys_rigid is used to generate the problem-specific data for each IMU. This data will be used for training and later by sys_inference to estimate the position and orientation of seg2 , which has no IMU attached. def finalize_fn_imu_data ( key , q , x , sys ): imu_seg_attachment = { \"imu1\" : \"seg1\" , \"imu2\" : \"seg3\" } X = {} for imu , seg in imu_seg_attachment . items (): key , consume = jax . random . split ( key ) X [ seg ] = x_xy . algorithms . imu ( x . take ( sys . name_to_idx ( imu ), 1 ), sys . gravity , sys . dt , consume , True ) return X def finalize_fn_rel_pose_data ( key , _ , x , sys ): y = x_xy . algorithms . rel_pose ( sys_scan = sys_inference , xs = x , sys_xs = sys ) return y def finalize_fn ( key , q , x , sys ): X = finalize_fn_imu_data ( key , q , x , sys ) # Since no IMU is attached to seg2, we need to provide dummy data. X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) y = finalize_fn_rel_pose_data ( key , q , x , sys ) return X , y The generated data comes is returned in the tuple \\((\\mathbf{X}, \\mathbf{y})\\) , with \\(\\mathbf{X}\\) being the generated IMU accelorometer and gyroscope data and \\(\\mathbf{y}\\) the orientation of each segment, in form of a unit quaternion. Train the model \u00a4 Before we begin with the actual training, we first define a setup function. This is called before training on each time series. The function below alters the length of segments and the position of the IMUs of the system, to simulate inaccuracies, e.g. when dealing with experimental data. def setup_fn_seg2 ( key , sys : x_xy . base . System ) -& gt ; x_xy . base . System : def replace_pos ( transforms , new_pos , name : str ): i = sys . name_to_idx ( name ) return transforms . index_set ( i , transforms [ i ] . replace ( pos = new_pos )) def draw_pos_uniform ( key , pos_min , pos_max ): key , c1 , c2 , c3 = jax . random . split ( key , num = 4 ) pos = jnp . array ( [ jax . random . uniform ( c1 , minval = pos_min [ 0 ], maxval = pos_max [ 0 ]), jax . random . uniform ( c2 , minval = pos_min [ 1 ], maxval = pos_max [ 1 ]), jax . random . uniform ( c3 , minval = pos_min [ 2 ], maxval = pos_max [ 2 ]), ] ) return key , pos ts = sys . links . transform1 # seg1 relative to seg2 key , pos = draw_pos_uniform ( key , [ - 0.3 , - 0.02 , - 0.02 ], [ - 0.05 , 0.02 , 0.02 ]) ts = replace_pos ( ts , pos , \"seg1\" ) # imu1 relative to seg1 key , pos = draw_pos_uniform ( key , [ - 0.25 , - 0.05 , - 0.05 ], [ - 0.05 , 0.05 , 0.05 ]) ts = replace_pos ( ts , pos , \"imu1\" ) # seg3 relative to seg2 key , pos = draw_pos_uniform ( key , [ 0.05 , - 0.02 , - 0.02 ], [ 0.3 , 0.02 , 0.02 ]) ts = replace_pos ( ts , pos , \"seg3\" ) # imu2 relative to seg2 key , pos = draw_pos_uniform ( key , [ 0.05 , - 0.05 , - 0.05 ], [ 0.25 , 0.05 , 0.05 ]) ts = replace_pos ( ts , pos , \"imu2\" ) return sys . replace ( links = sys . links . replace ( transform1 = ts )) With this, we can now train the model: We first define the batch size and number of epochs. For good results, a relatively large number of epochs is required, as the mean average angle error in training converges relatively late in training. Then we plug together the setup- and finalize functions in a generator function, which will provide the batched training data. A logger might also be added, such as a neptune logger. When using neptune, the environment-variables NEPTUNE_TOKEN and NEPTUNE_PROJECT must be set accordingly. TRAINING_BATCH_SIZE = 80 EPOCHS = 1500 params_path = \"parameters.pickle\" KEY_GEN = random . PRNGKey ( 1 ) KEY_NETWORK = random . PRNGKey ( 1 ) gen = x_xy . algorithms . build_generator ( sys_rigid , x_xy . algorithms . MotionConfig (), setup_fn_seg2 , finalize_fn ) gen = x_xy . algorithms . batch_generators_lazy ( gen , TRAINING_BATCH_SIZE ) # Set 'upload' to True if a logger is attached. save_params = callbacks . SaveParamsTrainingLoopCallback ( params_path , upload = False ) loggers = [] # loggers.append(NeptuneLogger()) # You may add loggers here, e.g. a Neptune Logger network = rnno . make_rnno ( sys_inference ) WARNING! Executing this code can take a long time (due to the very high number of epochs) and will probably take up a huge portion of your memory. If you run this code on a GPU, a batch size of 80 takes more than 50 GB of VRAM, so if the execution fails, it might be because of missing GPU memory. To circumvent this, the batch size can be decreased, however, the results will suffer from that. train ( gen , EPOCHS , network , loggers = loggers , callbacks = [ save_params ], key_generator = KEY_GEN , key_network = KEY_NETWORK ) Infering data \u00a4 def finalize_fn_inference ( key , q , x , sys ): X = finalize_fn_imu_data ( key , q , x , sys ) y = finalize_fn_rel_pose_data ( key , q , x , sys ) return X , y , x def generate_inference_data ( sys , config : x_xy . algorithms . MotionConfig , seed = random . PRNGKey ( 1 ,)): generator = x_xy . algorithms . build_generator ( sys , config , finalize_fn = finalize_fn_inference ) X , y , xs = generator ( seed ) return X , y , xs To control the data generated, the MotionConfig data is used. It contains all necessary information about the to-be-generated data series, e.g. time ( config.T ), except for the sampling rate, which is stored in the system object ( <sys>.dt ) and set in the XML-definition. The finalize function and its return values are similiar to the training finilaize function, however, an addtitional \\(\\mathbf{xs}\\) is returned, containing the actual position and rotation. This can be used for rendering purposes later. Also, the data is not batched, as we currently are only interested in one time series. config = x_xy . algorithms . MotionConfig () print ( f \"Generating data for a time series of { config . T } seconds, with a sampling rate of { 1 / sys_inference . dt } Hz.\" ) # If you are unhappy with your data series, you can alter this seed: seed = random . PRNGKey ( 1337 ,) X , y , xs = generate_inference_data ( sys_rigid , config , seed ) # Add dummy IMU data for segment 2 (which has no IMU attached) X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) Generating data for a time series of 60.0 seconds, with a sampling rate of 100.0 Hz. Inference \u00a4 To do inference, we first need to load the parameters (weights) of our model. params = load ( \"parameters.pickle\" ) Finally, we have everything we need to do inference! Let's see how our network performs... # Run prediction: X_3d = tree_utils . to_3d_if_2d ( X , strict = True ) initial_params , state = network . init ( random . PRNGKey ( 1 ,), X_3d ) yhat , _ = network . apply ( params , tree_utils . add_batch_dim ( state ), X_3d ) yhat = tree_utils . to_2d_if_3d ( yhat , strict = True ) # Plot prediction: def plot_segment ( segment : str , axis : str , ax ): axis_idx = \"xyz\" . index ( axis ) euler_angles_hat_seg2 = jnp . rad2deg ( x_xy . maths . quat_to_euler ( yhat [ segment ])[:, axis_idx ]) euler_angles_seg2 = jnp . rad2deg ( x_xy . maths . quat_to_euler ( y [ segment ])[:, axis_idx ]) ax . plot ( euler_angles_hat_seg2 , label = \"prediction\" ) ax . set_ylim (( - 180 , 180 )) ax . set_title ( f \" { segment } ( { axis } -axis)\" ) ax . plot ( euler_angles_seg2 , label = \"truth\" ) ax . set_xlabel ( \"time [s]\" ) ax . set_ylabel ( \"euler angles [deg]\" ) ax . legend () print ( f \" { segment } : medium absolute error { jnp . average ( jnp . abs ( euler_angles_hat_seg2 - euler_angles_seg2 )) } deg\" ) fig , axs = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) plot_segment ( \"seg2\" , 'y' , axs [ 0 ]) plot_segment ( \"seg3\" , 'z' , axs [ 1 ]) plt . show () seg2: medium absolute error 0.524849534034729 deg seg3: medium absolute error 0.5137953162193298 deg Let's also render a video of the prediction and the truth: # Extract translations from data-generating system... translations , rotations = sim2real . unzip_xs ( sys_inference , sim2real . match_xs ( sys_inference , xs , sys_rigid )) yhat_inv = jax . tree_map ( lambda quat : x_xy . maths . quat_inv ( quat ), yhat ) # ... swap rotations with predicted ones... rotations_hat = [] for i , name in enumerate ( sys_inference . link_names ): if name in yhat_inv : rotations_name = x_xy . Transform . create ( rot = yhat_inv [ name ]) else : rotations_name = rotations . take ( i , axis = 1 ) rotations_hat . append ( rotations_name ) # ... and plug the positions and rotations back together. rotations_hat = rotations_hat [ 0 ] . batch ( * rotations_hat [ 1 :]) . transpose (( 1 , 0 , 2 )) xs_hat = sim2real . zip_xs ( sys_inference , translations , rotations_hat ) # Create combined system that shall be rendered and its transforms sys_render = sys_composer . inject_system ( sys_rigid , sys_inference . add_prefix_suffix ( suffix = \"_hat\" )) xs_render = x_xy . Transform . concatenate ( xs , xs_hat , axis = 1 ) # Render prediction and truth: frames = x_xy . render ( sys_render , [ xs_render [ i ] for i in range ( xs_render . shape ( axis = 0 ))], camera = 'target' ) media . show_video ([ frame [ ... , : 3 ] for frame in frames ], fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000/6000 [00:16<00:00, 374.76it/s] This browser does not support the video tag.","title":"Notebook"},{"location":"prism/ss_23_marcel_thomas/notebook/#training-the-rnno-with-rigid-phases-prism-ss2023","text":"In this notebook, we define a custom hinge joint, which is configured to generate pauses (no movement) inside the generated data series. We use this joint to train the RNNO and perfrom inference with the generated parameters. import x_xy import jax import jax.numpy as jnp import jax.random as random from x_xy.subpkgs.ml import rnno , callbacks , train , load from x_xy.subpkgs import sim2real , sys_composer import tree_utils import matplotlib.pyplot as plt import mediapy as media","title":"Training the RNNO with rigid phases (PRISM SS2023)"},{"location":"prism/ss_23_marcel_thomas/notebook/#defining-the-system","text":"A system is defined in an XML structure. To read a system, an XML file may be used. It is also possible to define the system inline by using a string in XML-syntax. In the following, we define two three-segment chains: three_seg_rigid = r \"\"\" <x_xy model=\"three_seg_rigid\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg2\"> <geom color=\"red\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"rsry\" name=\"seg1\" pos=\"0 0 0\"> <geom color=\"yellow\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"-0.1 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.1 0.0 0.03\"> <geom color=\"green\" dim=\"0.05 0.01 0.01\" mass=\"2\" pos=\"0 0 0\" type=\"box\"></geom> </body> </body> <body joint=\"rsrz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom color=\"blue\" dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.1 0.0 0.03\"> <geom color=\"green\" dim=\"0.05 0.01 0.01\" mass=\"2\" pos=\"0 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> <defaults> <geom color=\"1 0.8 0.7 1\" edge_color=\"black\"></geom> </defaults> </x_xy> \"\"\" dustin_exp_xml_seg1 = r \"\"\" <x_xy model=\"dustin_exp\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <worldbody> <body joint=\"free\" name=\"seg1\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"-0.1 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg2\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> <body joint=\"rz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom dim=\"0.2 0.05 0.05\" mass=\"10\" pos=\"0.1 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\"","title":"Defining the System"},{"location":"prism/ss_23_marcel_thomas/notebook/#registering-the-joint-axis","text":"For this scenario, we define two systems: One for generating data with rigid phases and one for inference. To generate the random data with rigid phases, we first have to register a joint type, that allows for the creation of such data. We call this joint 'rsr\\<x|y|z>', a hinge joint that produces r andom s ometimes r igid data, and turns around the respective axis \\(x\\) , \\(y\\) or \\(z\\) in its frame. </x|y|z>","title":"Registering the joint axis"},{"location":"prism/ss_23_marcel_thomas/notebook/#generating-random-data","text":"The random data is generated by the following functions: # Helper function - Creates an array of values x &lt;- [0, 1] which may be multiplied to another sequence. def motion_amplifier ( time : float , sampling_rate : float , key_rigid_phases : jax . Array , n_rigid_phases = 3 , rigid_duration_cov = jnp . array ([ 0.02 ] * 3 ), transition_cov = jnp . array ([ 0.1 ] * 3 ) ) -& gt ; jax . Array : error_msg = \"motion_amplifier: There must be a variance for each rigid phase!\" assert rigid_duration_cov . shape == ( n_rigid_phases ,) == transition_cov . shape , error_msg n_frames = int ( time / sampling_rate ) key_rigid_means , key_rigid_variances , key_slope_down_variances , key_slope_up_variances = random . split ( key_rigid_phases , 4 ) # Calculate center points of rigid phases means = jnp . sort ( random . uniform ( key_rigid_means , shape = ( n_rigid_phases , 1 ), minval = 0 , maxval = n_frames ) . T ) # Calculate durations, which is twice the rigid distance from the center points for each rigid phase. rigid_distances = jnp . abs ( random . multivariate_normal ( key_rigid_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( rigid_duration_cov * n_frames ) ** 2 ))) # Calculate transition durations transition_slowdown_durations = jnp . abs ( random . multivariate_normal ( key_slope_down_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( transition_cov * n_frames ) ** 2 ) )) transition_speedup_durations = jnp . abs ( random . multivariate_normal ( key_slope_up_variances , mean = jnp . zeros_like ( means ), cov = jnp . diag (( transition_cov * n_frames ) ** 2 ) )) # Phase start and end points rigid_starts = ( means - rigid_distances ) . astype ( int ) . flatten () rigid_ends = ( means + rigid_distances ) . astype ( int ) . flatten () starts_slowing = ( means - rigid_distances - transition_slowdown_durations ) . astype ( int ) . flatten () ends_moving = ( means + rigid_distances + transition_speedup_durations ) . astype ( int ) . flatten () # Create masks def create_mask ( start , end ): nonlocal n_frames return jnp . where ( jnp . arange ( n_frames ) & lt ; start , 1 , 0 ) + jnp . where ( jnp . arange ( n_frames ) & gt ; = end , 1 , 0 ) mask = jax . vmap ( create_mask ) rigid_mask = jnp . prod ( mask ( rigid_starts , rigid_ends ), axis = 0 ) slowdown_masks = mask ( starts_slowing , rigid_starts ) . astype ( float ) speedup_masks = mask ( rigid_ends , ends_moving ) . astype ( float ) # We have to define an inline function in order to make this code JIT-able def linsp ( mask , start , end , begin_val , carry_fun ): range = end - start def true_fun ( carry , x ): return ( carry_fun ( carry , range ), 1 - carry ) def false_fun ( carry , x ): return ( carry , x ) def f ( carry , x ): return jax . lax . cond ( x == 0 , true_fun , false_fun , * ( carry , x )) return jax . lax . scan ( f , begin_val , mask )[ 1 ] linsp_desc = jax . vmap ( lambda m , s1 , s2 : linsp ( m , s1 , s2 , 0.0 , lambda carry , range : carry + 1 / range )) slowdown_mask = jnp . prod ( linsp_desc ( slowdown_masks , starts_slowing , rigid_starts ), axis = 0 ) linsp_asc = jax . vmap ( lambda m , s1 , s2 : linsp ( m , s1 , s2 , 1.0 , lambda carry , range : carry - 1 / range )) speedup_mask = jnp . prod ( linsp_asc ( speedup_masks , rigid_ends , ends_moving ), axis = 0 ) return jnp . min ( jnp . stack ([ rigid_mask , slowdown_mask , speedup_mask ]), axis = 0 ) # Random generator: Uses the motion_amplifier to dampen/null the randomly generated angles. def random_angles_with_rigid_phases_over_time ( key_t , key_ang , dt , key_rigid_phases , n_rigid_phases = 3 , rigid_duration_cov = jnp . array ([ 0.02 ] * 3 ), transition_cov = jnp . array ([ 0.1 ] * 3 ), config : x_xy . algorithms . MotionConfig = x_xy . algorithms . MotionConfig () ) -& gt ; jax . Array : mask = motion_amplifier ( config . T , dt , key_rigid_phases , n_rigid_phases , rigid_duration_cov , transition_cov ) qs = x_xy . algorithms . random_angle_over_time ( key_t = key_t , key_ang = key_ang , ANG_0 = config . ang0_max , dang_min = config . dang_min , dang_max = config . dang_max , delta_ang_min = config . delta_ang_min , delta_ang_max = config . delta_ang_max , t_min = config . t_min , t_max = config . t_max , T = config . T , Ts = dt , randomized_interpolation = config . randomized_interpolation_angle , range_of_motion = config . range_of_motion_hinge , range_of_motion_method = config . range_of_motion_hinge_method ) # derivate qs qs_diff = jnp . diff ( qs , axis = 0 ) # mulitply with motion amplifier qs_diff = qs_diff * mask [: - 1 ] # integrate qs_diff qs_rigid_phases = jnp . concatenate (( qs [ 0 : 1 ], jnp . cumsum ( qs_diff , axis = 0 ))) return qs_rigid_phases","title":"Generating random data"},{"location":"prism/ss_23_marcel_thomas/notebook/#defining-the-random-joint-function","text":"First of all, we have to define our problem. This means, parameterzing the random function. Two possible scenarios are implemented below: \"BEST_RUN\" and \"MANY_TINY_STOPS\", both of which achieved adequate results. The problems are defined as \\(P=(N, \\mathbf{\\sigma}_{r}, \\mathbf{\\sigma}_{tr})\\) , with \\(N\\) being the number of rigid phases, \\(\\mathbf{\\sigma}_r\\) the covariance used for calculating the length of each rigid phase and \\(\\mathbf{\\sigma}_{tr}\\) for the length of each transition phase respectively. It also holds that \\(\\mathbf{\\sigma}_r, \\mathbf{\\sigma}_{tr} \\in \\mathbb{R}^N\\) , with each entry being the variance for exactly one rigid phase. BEST_RUN = ( 1 , jnp . array ([ 0.02 ]), jnp . array ([ 0.1 ])) MANY_TINY_STOPS = ( 30 , jnp . array ([ 0.001 ] * 30 ), jnp . array ([ 0.0001 ] * 30 )) ################################################################################## # Define your own problem configuration here :) # PROBLEM = BEST_RUN # &lt;- Change this assignment to use it. ################################################################################## def define_joints (): def _draw_sometimes_rigid ( config : x_xy . algorithms . MotionConfig , key_t : jax . Array , key_value : jax . Array , dt : float , joint_params : jax . Array ) -& gt ; jax . Array : key_t , key_rigid_phases = jax . random . split ( key_t ) return random_angles_with_rigid_phases_over_time ( key_t = key_t , key_ang = key_value , dt = dt , key_rigid_phases = key_rigid_phases , n_rigid_phases = PROBLEM [ 0 ], rigid_duration_cov = PROBLEM [ 1 ], transition_cov = PROBLEM [ 2 ], config = config ) def _rxyz_transform ( q , _ , axis ): q = jnp . squeeze ( q ) rot = x_xy . maths . quat_rot_axis ( axis , q ) return x_xy . base . Transform . create ( rot = rot ) rsrx_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 1.0 , 0 , 0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) rsry_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 0 , 1.0 , 0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) rsrz_joint = x_xy . algorithms . JointModel ( lambda q , _ : _rxyz_transform ( q , _ , jnp . array ([ 0 , 0 , 1.0 ])), [ None ], rcmg_draw_fn = _draw_sometimes_rigid ) try : x_xy . algorithms . register_new_joint_type ( \"rsrx\" , rsrx_joint , 1 ) x_xy . algorithms . register_new_joint_type ( \"rsry\" , rsry_joint , 1 ) x_xy . algorithms . register_new_joint_type ( \"rsrz\" , rsrz_joint , 1 ) except AssertionError : print ( \"Warning: Joints have already been registered!\" ) define_joints () Note: it is also possible to support multiple problems at the same time, by implementing them as seperate joint types, or by injecting the x_xy.algorithms.MotionConfig class e.g. by inheritance. After we defined the joint type, we can load the system: sys_rigid = x_xy . io . load_sys_from_str ( three_seg_rigid ) sys_inference = x_xy . io . load_sys_from_str ( dustin_exp_xml_seg1 )","title":"Defining the random joint function"},{"location":"prism/ss_23_marcel_thomas/notebook/#generating-raw-data","text":"For both training and inference, we first need a set of raw data. In our example, sys_rigid is used to generate the problem-specific data for each IMU. This data will be used for training and later by sys_inference to estimate the position and orientation of seg2 , which has no IMU attached. def finalize_fn_imu_data ( key , q , x , sys ): imu_seg_attachment = { \"imu1\" : \"seg1\" , \"imu2\" : \"seg3\" } X = {} for imu , seg in imu_seg_attachment . items (): key , consume = jax . random . split ( key ) X [ seg ] = x_xy . algorithms . imu ( x . take ( sys . name_to_idx ( imu ), 1 ), sys . gravity , sys . dt , consume , True ) return X def finalize_fn_rel_pose_data ( key , _ , x , sys ): y = x_xy . algorithms . rel_pose ( sys_scan = sys_inference , xs = x , sys_xs = sys ) return y def finalize_fn ( key , q , x , sys ): X = finalize_fn_imu_data ( key , q , x , sys ) # Since no IMU is attached to seg2, we need to provide dummy data. X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) y = finalize_fn_rel_pose_data ( key , q , x , sys ) return X , y The generated data comes is returned in the tuple \\((\\mathbf{X}, \\mathbf{y})\\) , with \\(\\mathbf{X}\\) being the generated IMU accelorometer and gyroscope data and \\(\\mathbf{y}\\) the orientation of each segment, in form of a unit quaternion.","title":"Generating raw data"},{"location":"prism/ss_23_marcel_thomas/notebook/#train-the-model","text":"Before we begin with the actual training, we first define a setup function. This is called before training on each time series. The function below alters the length of segments and the position of the IMUs of the system, to simulate inaccuracies, e.g. when dealing with experimental data. def setup_fn_seg2 ( key , sys : x_xy . base . System ) -& gt ; x_xy . base . System : def replace_pos ( transforms , new_pos , name : str ): i = sys . name_to_idx ( name ) return transforms . index_set ( i , transforms [ i ] . replace ( pos = new_pos )) def draw_pos_uniform ( key , pos_min , pos_max ): key , c1 , c2 , c3 = jax . random . split ( key , num = 4 ) pos = jnp . array ( [ jax . random . uniform ( c1 , minval = pos_min [ 0 ], maxval = pos_max [ 0 ]), jax . random . uniform ( c2 , minval = pos_min [ 1 ], maxval = pos_max [ 1 ]), jax . random . uniform ( c3 , minval = pos_min [ 2 ], maxval = pos_max [ 2 ]), ] ) return key , pos ts = sys . links . transform1 # seg1 relative to seg2 key , pos = draw_pos_uniform ( key , [ - 0.3 , - 0.02 , - 0.02 ], [ - 0.05 , 0.02 , 0.02 ]) ts = replace_pos ( ts , pos , \"seg1\" ) # imu1 relative to seg1 key , pos = draw_pos_uniform ( key , [ - 0.25 , - 0.05 , - 0.05 ], [ - 0.05 , 0.05 , 0.05 ]) ts = replace_pos ( ts , pos , \"imu1\" ) # seg3 relative to seg2 key , pos = draw_pos_uniform ( key , [ 0.05 , - 0.02 , - 0.02 ], [ 0.3 , 0.02 , 0.02 ]) ts = replace_pos ( ts , pos , \"seg3\" ) # imu2 relative to seg2 key , pos = draw_pos_uniform ( key , [ 0.05 , - 0.05 , - 0.05 ], [ 0.25 , 0.05 , 0.05 ]) ts = replace_pos ( ts , pos , \"imu2\" ) return sys . replace ( links = sys . links . replace ( transform1 = ts )) With this, we can now train the model: We first define the batch size and number of epochs. For good results, a relatively large number of epochs is required, as the mean average angle error in training converges relatively late in training. Then we plug together the setup- and finalize functions in a generator function, which will provide the batched training data. A logger might also be added, such as a neptune logger. When using neptune, the environment-variables NEPTUNE_TOKEN and NEPTUNE_PROJECT must be set accordingly. TRAINING_BATCH_SIZE = 80 EPOCHS = 1500 params_path = \"parameters.pickle\" KEY_GEN = random . PRNGKey ( 1 ) KEY_NETWORK = random . PRNGKey ( 1 ) gen = x_xy . algorithms . build_generator ( sys_rigid , x_xy . algorithms . MotionConfig (), setup_fn_seg2 , finalize_fn ) gen = x_xy . algorithms . batch_generators_lazy ( gen , TRAINING_BATCH_SIZE ) # Set 'upload' to True if a logger is attached. save_params = callbacks . SaveParamsTrainingLoopCallback ( params_path , upload = False ) loggers = [] # loggers.append(NeptuneLogger()) # You may add loggers here, e.g. a Neptune Logger network = rnno . make_rnno ( sys_inference ) WARNING! Executing this code can take a long time (due to the very high number of epochs) and will probably take up a huge portion of your memory. If you run this code on a GPU, a batch size of 80 takes more than 50 GB of VRAM, so if the execution fails, it might be because of missing GPU memory. To circumvent this, the batch size can be decreased, however, the results will suffer from that. train ( gen , EPOCHS , network , loggers = loggers , callbacks = [ save_params ], key_generator = KEY_GEN , key_network = KEY_NETWORK )","title":"Train the model"},{"location":"prism/ss_23_marcel_thomas/notebook/#infering-data","text":"def finalize_fn_inference ( key , q , x , sys ): X = finalize_fn_imu_data ( key , q , x , sys ) y = finalize_fn_rel_pose_data ( key , q , x , sys ) return X , y , x def generate_inference_data ( sys , config : x_xy . algorithms . MotionConfig , seed = random . PRNGKey ( 1 ,)): generator = x_xy . algorithms . build_generator ( sys , config , finalize_fn = finalize_fn_inference ) X , y , xs = generator ( seed ) return X , y , xs To control the data generated, the MotionConfig data is used. It contains all necessary information about the to-be-generated data series, e.g. time ( config.T ), except for the sampling rate, which is stored in the system object ( <sys>.dt ) and set in the XML-definition. The finalize function and its return values are similiar to the training finilaize function, however, an addtitional \\(\\mathbf{xs}\\) is returned, containing the actual position and rotation. This can be used for rendering purposes later. Also, the data is not batched, as we currently are only interested in one time series. config = x_xy . algorithms . MotionConfig () print ( f \"Generating data for a time series of { config . T } seconds, with a sampling rate of { 1 / sys_inference . dt } Hz.\" ) # If you are unhappy with your data series, you can alter this seed: seed = random . PRNGKey ( 1337 ,) X , y , xs = generate_inference_data ( sys_rigid , config , seed ) # Add dummy IMU data for segment 2 (which has no IMU attached) X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) Generating data for a time series of 60.0 seconds, with a sampling rate of 100.0 Hz.","title":"Infering data"},{"location":"prism/ss_23_marcel_thomas/notebook/#inference","text":"To do inference, we first need to load the parameters (weights) of our model. params = load ( \"parameters.pickle\" ) Finally, we have everything we need to do inference! Let's see how our network performs... # Run prediction: X_3d = tree_utils . to_3d_if_2d ( X , strict = True ) initial_params , state = network . init ( random . PRNGKey ( 1 ,), X_3d ) yhat , _ = network . apply ( params , tree_utils . add_batch_dim ( state ), X_3d ) yhat = tree_utils . to_2d_if_3d ( yhat , strict = True ) # Plot prediction: def plot_segment ( segment : str , axis : str , ax ): axis_idx = \"xyz\" . index ( axis ) euler_angles_hat_seg2 = jnp . rad2deg ( x_xy . maths . quat_to_euler ( yhat [ segment ])[:, axis_idx ]) euler_angles_seg2 = jnp . rad2deg ( x_xy . maths . quat_to_euler ( y [ segment ])[:, axis_idx ]) ax . plot ( euler_angles_hat_seg2 , label = \"prediction\" ) ax . set_ylim (( - 180 , 180 )) ax . set_title ( f \" { segment } ( { axis } -axis)\" ) ax . plot ( euler_angles_seg2 , label = \"truth\" ) ax . set_xlabel ( \"time [s]\" ) ax . set_ylabel ( \"euler angles [deg]\" ) ax . legend () print ( f \" { segment } : medium absolute error { jnp . average ( jnp . abs ( euler_angles_hat_seg2 - euler_angles_seg2 )) } deg\" ) fig , axs = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) plot_segment ( \"seg2\" , 'y' , axs [ 0 ]) plot_segment ( \"seg3\" , 'z' , axs [ 1 ]) plt . show () seg2: medium absolute error 0.524849534034729 deg seg3: medium absolute error 0.5137953162193298 deg Let's also render a video of the prediction and the truth: # Extract translations from data-generating system... translations , rotations = sim2real . unzip_xs ( sys_inference , sim2real . match_xs ( sys_inference , xs , sys_rigid )) yhat_inv = jax . tree_map ( lambda quat : x_xy . maths . quat_inv ( quat ), yhat ) # ... swap rotations with predicted ones... rotations_hat = [] for i , name in enumerate ( sys_inference . link_names ): if name in yhat_inv : rotations_name = x_xy . Transform . create ( rot = yhat_inv [ name ]) else : rotations_name = rotations . take ( i , axis = 1 ) rotations_hat . append ( rotations_name ) # ... and plug the positions and rotations back together. rotations_hat = rotations_hat [ 0 ] . batch ( * rotations_hat [ 1 :]) . transpose (( 1 , 0 , 2 )) xs_hat = sim2real . zip_xs ( sys_inference , translations , rotations_hat ) # Create combined system that shall be rendered and its transforms sys_render = sys_composer . inject_system ( sys_rigid , sys_inference . add_prefix_suffix ( suffix = \"_hat\" )) xs_render = x_xy . Transform . concatenate ( xs , xs_hat , axis = 1 ) # Render prediction and truth: frames = x_xy . render ( sys_render , [ xs_render [ i ] for i in range ( xs_render . shape ( axis = 0 ))], camera = 'target' ) media . show_video ([ frame [ ... , : 3 ] for frame in frames ], fps = 25 ) Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000/6000 [00:16<00:00, 374.76it/s] This browser does not support the video tag.","title":"Inference"},{"location":"prism/ss_23_moritz/notebook/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Training the RNNo with a custom loss function \u00a4 This notebook showcases how train an RNNo network with a custom loss function rather than the default mean-reduces angle error. This is showcased by scaling the error by a softmax over the time axis, which puts more weight on the time intervals with a higher deviation compared to ones with lower deviation. import jax import jax.numpy as jnp import tree_utils from jax.nn import softmax import matplotlib.pyplot as plt import mediapy import x_xy from x_xy.subpkgs import ml , sim2real , sys_composer Set the batch size and number of training episodes according to the available hardware. BATCHSIZE = 32 NUM_TRAINING_EPISODES = 1500 Defining the systems \u00a4 We use two separate systems, both parsed from XML strings: one for training ( sys ) and one for inference ( dustin_sys ). sys_str = r \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"orange\"></geom> </defaults> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"red\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"red\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . io . load_sys_from_str ( sys_str ) dustin_exp_xml_seg1 = r \"\"\" <x_xy model=\"dustin_exp\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"white\"></geom> </defaults> <worldbody> <body joint=\"free\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg2\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"rz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys_inference = x_xy . io . load_sys_from_str ( dustin_exp_xml_seg1 ) Generating the motion data \u00a4 Our motion data will be automatically generated using a Generator , which can be customised using an MotionConfig . The Generator will generate data for both q , that is the state of all the joint angles in the system, as well as xs , which describes the orientations of all the links in the system. To use this data for training our RNNo, we first have to bring it into the correct form using a finalise_fn . def finalise_fn ( key : jax . Array , q : jax . Array , xs : x_xy . Transform , sys : x_xy . System ): def xs_by_name ( name : str ): return xs . take ( sys . name_to_idx ( name ), axis = 1 ) key , * consume = jax . random . split ( key , 3 ) # the input X to our RNNo is the IMU data of segments 1 and 3 X = { \"seg1\" : x_xy . imu ( xs_by_name ( \"imu1\" ), sys . gravity , sys . dt , consume [ 0 ], True ), \"seg3\" : x_xy . imu ( xs_by_name ( \"imu2\" ), sys . gravity , sys . dt , consume [ 1 ], True ), } # seg2 has no IMU, but we still need to make an entry in our X X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) # the output of the RNNo is the estimated relative poses of our segments y = x_xy . algorithms . rel_pose ( sys_scan = sys_inference , xs = xs , sys_xs = sys ) return X , y config = x_xy . algorithms . MotionConfig ( dpos_max = 0.3 , ang0_min = 0.0 , ang0_max = 0.0 ) gen = x_xy . build_generator ( sys , config , finalize_fn = finalise_fn ) gen = x_xy . batch_generator ( gen , BATCHSIZE ) Custom loss function \u00a4 To customise the loss function of the RNNo, we transform the error values before they are averaged. The input to our loss function will be both \\(q\\) , the real joint state, as well as \\(\\hat{q}\\) , the joint space estimated by our RNNo. q and q_hat will both be jax.Array s of shape (T_tbp, 4) , where the first axis is slice over time (of our TBPTT length) and the second axis are the 4 components of a quaternion. In this notebook we want to change the relative weightings of the errors at different times using a softmax function in order to put more weight on larger errors. First we convert the errors from quaterions to angles. Then we scale each error angle by a factor, calculated from a softmax over the angles. The calculation of the factors includes a call to jax.lax.stop_gradient to make it so our gradients are only from the errors themselves, not the factors as well. def make_loss_fn ( beta ): def metric_fn ( q , q_hat ): return x_xy . maths . angle_error ( q , q_hat ) ** 2 if beta is not None : def loss_fn ( q , q_hat ): # q.shape == q_hat.shape == (1000, 4) angles = metric_fn ( q , q_hat ) factors = angles . shape [ - 1 ] * softmax ( beta * jax . lax . stop_gradient ( angles ), axis =- 1 ) errors = factors * angles return errors else : loss_fn = metric_fn return loss_fn beta determines the strength of our weighting: the larger beta, the more relative weight we put on the larger errors, while beta = 0.0 makes the scaling factors uniform one and gives us back our unweighted errors. Alternatively beta = None bypasses the scaling altogether. beta = 1.0 rnno = ml . make_rnno ( sys_inference ) loss_fn = make_loss_fn ( beta ) save_params = ml . callbacks . SaveParamsTrainingLoopCallback ( \"parameters.pickle\" , upload = False ) ml . train ( gen , NUM_TRAINING_EPISODES , rnno , callbacks = [ save_params ], loss_fn = loss_fn ) To visualise our network, we can render it using mediapy. First we generate some motion data. gen = x_xy . build_generator ( sys , config ) key = jax . random . PRNGKey ( 1 ) q , xs = gen ( key ) We need to again bring the motion data in the correct form for our RNNo and can then run inference of the generated data. params = ml . load ( \"parameters.pickle\" ) X , y = finalise_fn ( key , q , xs , sys ) X = tree_utils . add_batch_dim ( X ) _ , state = rnno . init ( key , X ) state = tree_utils . add_batch_dim ( state ) y_hat , _ = rnno . apply ( params , state , X ) y_hat = tree_utils . to_2d_if_3d ( y_hat , strict = True ) First we want to plot the angle error for both segment 2 and segment 3 over time. y [ \"seg2\" ][: 10 ] y_hat [ \"seg2\" ] fig , ax = plt . subplots () angle_error2 = jnp . rad2deg ( x_xy . maths . angle_error ( y [ \"seg2\" ], y_hat [ \"seg2\" ])) angle_error3 = jnp . rad2deg ( x_xy . maths . angle_error ( y [ \"seg3\" ], y_hat [ \"seg3\" ])) T = jnp . arange ( angle_error2 . size ) * sys_inference . dt ax . plot ( T , angle_error2 , label = \"seg2\" ) ax . plot ( T , angle_error3 , label = \"seg3\" ) ax . set_xlabel ( \"time [s]\" ) ax . set_ylabel ( \"abs. angle error [deg]\" ) ax . legend () plt . show () Next we have to create an xs_hat of the estimated orientations, so that we can render them. # Extract translations from data-generating system... translations , rotations = sim2real . unzip_xs ( sys_inference , sim2real . match_xs ( sys_inference , xs , sys ) ) y_hat_inv = jax . tree_map ( lambda quat : x_xy . maths . quat_inv ( quat ), y_hat ) # ... swap rotations with predicted ones... rotations_hat = [] for i , name in enumerate ( sys_inference . link_names ): if name in y_hat_inv : rotations_name = x_xy . Transform . create ( rot = y_hat_inv [ name ]) else : rotations_name = rotations . take ( i , axis = 1 ) rotations_hat . append ( rotations_name ) # ... and plug the positions and rotations back together. rotations_hat = rotations_hat [ 0 ] . batch ( * rotations_hat [ 1 :]) . transpose (( 1 , 0 , 2 )) xs_hat = sim2real . zip_xs ( sys_inference , translations , rotations_hat ) # Create combined system that shall be rendered and its transforms sys_render = sys_composer . inject_system ( sys , sys_inference . add_prefix_suffix ( suffix = \"_hat\" )) xs_render = x_xy . Transform . concatenate ( xs , xs_hat , axis = 1 ) Now we can render both the predicted system (in white) as well as the real system (in orange). xs_list = [ xs_render [ i ] for i in range ( xs_render . shape ())] frames = x_xy . render ( sys_render , xs_list , camera = \"targetfar\" ) mediapy . show_video ([ frame [ ... , : 3 ] for frame in frames ], fps = int ( 1 / sys . dt ))","title":"Notebook"},{"location":"prism/ss_23_moritz/notebook/#training-the-rnno-with-a-custom-loss-function","text":"This notebook showcases how train an RNNo network with a custom loss function rather than the default mean-reduces angle error. This is showcased by scaling the error by a softmax over the time axis, which puts more weight on the time intervals with a higher deviation compared to ones with lower deviation. import jax import jax.numpy as jnp import tree_utils from jax.nn import softmax import matplotlib.pyplot as plt import mediapy import x_xy from x_xy.subpkgs import ml , sim2real , sys_composer Set the batch size and number of training episodes according to the available hardware. BATCHSIZE = 32 NUM_TRAINING_EPISODES = 1500","title":"Training the RNNo with a custom loss function"},{"location":"prism/ss_23_moritz/notebook/#defining-the-systems","text":"We use two separate systems, both parsed from XML strings: one for training ( sys ) and one for inference ( dustin_sys ). sys_str = r \"\"\" <x_xy model=\"three_segment_kinematic_chain\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"orange\"></geom> </defaults> <worldbody> <body joint=\"free\" name=\"seg2\" pos=\"0 0 2\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu1\" pos=\"-0.5 0 0.125\"> <geom color=\"red\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> <body joint=\"rz\" name=\"seg3\" pos=\"1 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"0.1\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"frozen\" name=\"imu2\" pos=\"0.5 0 -0.125\"> <geom color=\"red\" dim=\"0.2 0.2 0.05\" mass=\"0.05\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys = x_xy . io . load_sys_from_str ( sys_str ) dustin_exp_xml_seg1 = r \"\"\" <x_xy model=\"dustin_exp\"> <options dt=\"0.01\" gravity=\"0 0 9.81\"></options> <defaults> <geom color=\"white\"></geom> </defaults> <worldbody> <body joint=\"free\" name=\"seg1\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"-0.5 0 0\" type=\"box\"></geom> <body joint=\"ry\" name=\"seg2\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> <body joint=\"rz\" name=\"seg3\" pos=\"0.2 0 0\"> <geom dim=\"1 0.25 0.2\" mass=\"10\" pos=\"0.5 0 0\" type=\"box\"></geom> </body> </body> </body> </worldbody> </x_xy> \"\"\" sys_inference = x_xy . io . load_sys_from_str ( dustin_exp_xml_seg1 )","title":"Defining the systems"},{"location":"prism/ss_23_moritz/notebook/#generating-the-motion-data","text":"Our motion data will be automatically generated using a Generator , which can be customised using an MotionConfig . The Generator will generate data for both q , that is the state of all the joint angles in the system, as well as xs , which describes the orientations of all the links in the system. To use this data for training our RNNo, we first have to bring it into the correct form using a finalise_fn . def finalise_fn ( key : jax . Array , q : jax . Array , xs : x_xy . Transform , sys : x_xy . System ): def xs_by_name ( name : str ): return xs . take ( sys . name_to_idx ( name ), axis = 1 ) key , * consume = jax . random . split ( key , 3 ) # the input X to our RNNo is the IMU data of segments 1 and 3 X = { \"seg1\" : x_xy . imu ( xs_by_name ( \"imu1\" ), sys . gravity , sys . dt , consume [ 0 ], True ), \"seg3\" : x_xy . imu ( xs_by_name ( \"imu2\" ), sys . gravity , sys . dt , consume [ 1 ], True ), } # seg2 has no IMU, but we still need to make an entry in our X X [ \"seg2\" ] = tree_utils . tree_zeros_like ( X [ \"seg1\" ]) # the output of the RNNo is the estimated relative poses of our segments y = x_xy . algorithms . rel_pose ( sys_scan = sys_inference , xs = xs , sys_xs = sys ) return X , y config = x_xy . algorithms . MotionConfig ( dpos_max = 0.3 , ang0_min = 0.0 , ang0_max = 0.0 ) gen = x_xy . build_generator ( sys , config , finalize_fn = finalise_fn ) gen = x_xy . batch_generator ( gen , BATCHSIZE )","title":"Generating the motion data"},{"location":"prism/ss_23_moritz/notebook/#custom-loss-function","text":"To customise the loss function of the RNNo, we transform the error values before they are averaged. The input to our loss function will be both \\(q\\) , the real joint state, as well as \\(\\hat{q}\\) , the joint space estimated by our RNNo. q and q_hat will both be jax.Array s of shape (T_tbp, 4) , where the first axis is slice over time (of our TBPTT length) and the second axis are the 4 components of a quaternion. In this notebook we want to change the relative weightings of the errors at different times using a softmax function in order to put more weight on larger errors. First we convert the errors from quaterions to angles. Then we scale each error angle by a factor, calculated from a softmax over the angles. The calculation of the factors includes a call to jax.lax.stop_gradient to make it so our gradients are only from the errors themselves, not the factors as well. def make_loss_fn ( beta ): def metric_fn ( q , q_hat ): return x_xy . maths . angle_error ( q , q_hat ) ** 2 if beta is not None : def loss_fn ( q , q_hat ): # q.shape == q_hat.shape == (1000, 4) angles = metric_fn ( q , q_hat ) factors = angles . shape [ - 1 ] * softmax ( beta * jax . lax . stop_gradient ( angles ), axis =- 1 ) errors = factors * angles return errors else : loss_fn = metric_fn return loss_fn beta determines the strength of our weighting: the larger beta, the more relative weight we put on the larger errors, while beta = 0.0 makes the scaling factors uniform one and gives us back our unweighted errors. Alternatively beta = None bypasses the scaling altogether. beta = 1.0 rnno = ml . make_rnno ( sys_inference ) loss_fn = make_loss_fn ( beta ) save_params = ml . callbacks . SaveParamsTrainingLoopCallback ( \"parameters.pickle\" , upload = False ) ml . train ( gen , NUM_TRAINING_EPISODES , rnno , callbacks = [ save_params ], loss_fn = loss_fn ) To visualise our network, we can render it using mediapy. First we generate some motion data. gen = x_xy . build_generator ( sys , config ) key = jax . random . PRNGKey ( 1 ) q , xs = gen ( key ) We need to again bring the motion data in the correct form for our RNNo and can then run inference of the generated data. params = ml . load ( \"parameters.pickle\" ) X , y = finalise_fn ( key , q , xs , sys ) X = tree_utils . add_batch_dim ( X ) _ , state = rnno . init ( key , X ) state = tree_utils . add_batch_dim ( state ) y_hat , _ = rnno . apply ( params , state , X ) y_hat = tree_utils . to_2d_if_3d ( y_hat , strict = True ) First we want to plot the angle error for both segment 2 and segment 3 over time. y [ \"seg2\" ][: 10 ] y_hat [ \"seg2\" ] fig , ax = plt . subplots () angle_error2 = jnp . rad2deg ( x_xy . maths . angle_error ( y [ \"seg2\" ], y_hat [ \"seg2\" ])) angle_error3 = jnp . rad2deg ( x_xy . maths . angle_error ( y [ \"seg3\" ], y_hat [ \"seg3\" ])) T = jnp . arange ( angle_error2 . size ) * sys_inference . dt ax . plot ( T , angle_error2 , label = \"seg2\" ) ax . plot ( T , angle_error3 , label = \"seg3\" ) ax . set_xlabel ( \"time [s]\" ) ax . set_ylabel ( \"abs. angle error [deg]\" ) ax . legend () plt . show () Next we have to create an xs_hat of the estimated orientations, so that we can render them. # Extract translations from data-generating system... translations , rotations = sim2real . unzip_xs ( sys_inference , sim2real . match_xs ( sys_inference , xs , sys ) ) y_hat_inv = jax . tree_map ( lambda quat : x_xy . maths . quat_inv ( quat ), y_hat ) # ... swap rotations with predicted ones... rotations_hat = [] for i , name in enumerate ( sys_inference . link_names ): if name in y_hat_inv : rotations_name = x_xy . Transform . create ( rot = y_hat_inv [ name ]) else : rotations_name = rotations . take ( i , axis = 1 ) rotations_hat . append ( rotations_name ) # ... and plug the positions and rotations back together. rotations_hat = rotations_hat [ 0 ] . batch ( * rotations_hat [ 1 :]) . transpose (( 1 , 0 , 2 )) xs_hat = sim2real . zip_xs ( sys_inference , translations , rotations_hat ) # Create combined system that shall be rendered and its transforms sys_render = sys_composer . inject_system ( sys , sys_inference . add_prefix_suffix ( suffix = \"_hat\" )) xs_render = x_xy . Transform . concatenate ( xs , xs_hat , axis = 1 ) Now we can render both the predicted system (in white) as well as the real system (in orange). xs_list = [ xs_render [ i ] for i in range ( xs_render . shape ())] frames = x_xy . render ( sys_render , xs_list , camera = \"targetfar\" ) mediapy . show_video ([ frame [ ... , : 3 ] for frame in frames ], fps = int ( 1 / sys . dt ))","title":"Custom loss function"}]}